<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[windows安装make]]></title>
    <url>%2F2021%2F04%2F14%2Fwindows%E5%AE%89%E8%A3%85make%2F</url>
    <content type="text"><![CDATA[记录Windows如何安装make。 [TOC] 安装chocolatey 法一——官网安装 地址传送门 法二——使用命令行安装 @&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot; 安装make以管理员打开terminal： choco install make 测试： make --version Enjoy it !]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows搭建hadoop环境]]></title>
    <url>%2F2021%2F04%2F10%2Fwindows%E6%90%AD%E5%BB%BAhadoop%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[之前虽然在wsl和docker上都搭建了hadoop的环境，但由于需要本地的代码调试，不得以而再次搭建windows平台的运行环境。 [TOC] 下载首先下载我们需要的hadoop文件（这里的bin 和etc文件已经替换过，配置后直接使用即可）： 下载地址 提取码：owtg 强调：将该文件解压到一个没有中文与空格的路径下 拷贝dll文件解压之后拷贝bin目录下的hadoop.dll到 C:\Windows\System32目录 配置环境变量配置JAVA_HOME将自己的jdk目录添加到环境变量中 配置HADOOP_HOME就是刚才你解压的路径，不要有中文或者空格。 配置PATH将hadoop和java的环境变量配置好。 %HADOOP_HOME%\bin%JAVA_HOME%\bin 检验打开cmd窗口，如果是之前打开的就关掉重新打开。 java -version hadoop version 可以显示出版本就代表环境变量配置完成。 伪分布式配置修改hadoop-env.cmd 使用编辑器打开 解压路径\hadoop-2.7.7\etc\hadoop\hadoop-env.cmd 修改JAVA_HOME的路径 修改hdfs-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/D:/Program/hadoop-2.7.7/data/namenode&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/D:/Program/hadoop-2.7.7/data/datanode&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 记得改成你的解压路径： 检验以管理员打开cmd： hdfs namenode -format 等待完成之后，进入到hadoop文件夹下，并启动hadoop： .\sbin\start-all.cmd 也可以使用jps来查看当前进程： 关闭hadoop .\sbin\stop-all.cmd Enjoy it !]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用docker搭建大数据环境]]></title>
    <url>%2F2021%2F04%2F10%2F%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BA%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[使用docker进行构建单机伪分布式hadoop环境。 [TOC] Instruction 搭建的docker-images使用的软件版本如下： hadoop版本：2.7.7 spark版本：3.1.1 jdk版本：1.8 hive版本：待添加 Hbase版本：1.4.13 ps： 1. 请先确保你的 git 、docker 和 make 是可用的。 2. 镜像内的用户密码为：qwe 使用方法 clone本仓库到你的本地 git clone git@github.com:Liuyang0001/docker-hadoop.git 使用make进行docker镜像下载 进到仓库目录下： cd docker-hadoop 使用make语句进行拉取docker镜像： make pull 启动镜像 make up 进入镜像 make bash 启动hadoop伪分布式： cd ~/onekeysh run.sh 打开网址查看： http://localhost:50070/ 关闭hadoop集群 sh ~/onekey/stop.sh #关闭hadoopexit # 退出bash 退出并解除容器 make down Enjoy it.]]></content>
      <categories>
        <category>大数据学习笔记</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Hadoop</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSL搭建Hadoop与Spark环境]]></title>
    <url>%2F2021%2F03%2F20%2FWSL%E6%90%AD%E5%BB%BAHadoop%E4%B8%8ESpark%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[在wsl上搭建大数据Hadoop与Spark环境。 [TOC] ❤❤❤ jdk安装下载首先在oracle官网下载jdk1.8，最好选这个版本，其他版本可能会出现问题。 版本支持信息如下： 解压找到下载的文件进行解压： sudo tar -zxvf jdk-*-linux-x64.tar.gz -C /usr/local #解压到/usr/local目录下 改名 sudo mv jdk* jdk8 添加环境变量 sudo vim ~/.zshrc # 不是用zsh就改成.bashrc 在最后添加环境后，:x 保存退出 # jdk环境export JAVA_HOME=/usr/local/jdk8export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 使之生效 source ~/.zshrc 检验java -version ❤❤❤ Hadoop安装下载下载最新版的hadoop，当前为3.3.0： 镜像下载 解压找到下载的文件进行解压： sudo tar -zxvf hadoop*.tar.gz -C /usr/local #解压到/usr/local目录下 改名 cd /usr/localsudo mv hadoop* hadoop 添加环境变量 sudo vim ~/.zshrc # 不是用zsh就改成.bashrc 在最后添加环境后，:x 保存退出 # Hadoop环境export HADOOP_HOME=/usr/local/hadoopexport HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/nativeexport PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbinexport JAVA_LIBRAY_PATH=/usr/local/hadoop/lib/native 使之生效 source ~/.zshrc 检验hadoop version ❤❤❤ Hadoop伪分布式模式配置文件配置进到配置目录 cd /usr/local/hadoop/etc/hadoop 修改hadoop-env.sh添加hadoop_opts和jdk路径 export JAVA_HOME=/usr/local/jdk8# 解决Unable to load native-hadoop library for your platform...export HADOOP_OPTS="-Djava.library.path=$&#123;HADOOP_HOME&#125;/lib/native" 修改core-site.xmlsudo vim core-site.xml 修改配置如下： &lt;configuration&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp&lt;/value&gt; &lt;description&gt;Abase for other temporary directories.&lt;/description&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改hdfs-site.xmlsudo vim hdfs-site.xml 修改如下： &lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;file:/usr/local/hadoop/tmp/dfs/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; ❤❤❤ 测试HDFS启动sshsudo service ssh start NameNode格式化/usr/local/hadoop/bin/hdfs namenode –format 启动dfs/usr/local/hadoop/sbin/start-dfs.sh jps 启动完成后，可以通过命令 jps 来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode” 和 “SecondaryNameNode” 查看hadoop页面浏览器输入： http://localhost:9870 ❤❤❤ YARN单机配置修改mapred-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.map.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.reduce.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=$&#123;HADOOP_HOME&#125;&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 修改yarn-site.xml&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 查看资源管理页面/usr/local/hadoop/sbin/start-all.sh 打开网址： http://localhost:8088/ ❤❤❤ Spark安装下载spark下载地址 解压sudo tar -zxvf spark*.gz -C /usr/local #解压到/usr/local目录下 改名 sudo mv spark* spark 配置环境sudo vim ~/.zshrc 添加： export SPARK_HOME=/usr/local/sparkexport PATH=$PATH: $&#123;SPARK_HOME&#125;/bin 使之生效： source ~/.zshrc ❤❤❤ 配置Sparkcd /usr/local/spark/conf 修改spark-env.shsudo vim spark-env.sh 添加： export LD_LIBRARY_PATH=$JAVA_LIBRARY_PATHexport JAVA_HOME=/usr/local/jdk8export SPARK_MASTER_IP=localhostexport SPARK_WORKER_MEMORY=4g 启动/usr/local/spark/sbin/start-all.sh 打开网址： http://localhost:8080/ 启动pysparkpyspark --master local[2] Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl安装systemd]]></title>
    <url>%2F2020%2F08%2F11%2Fwsl%E5%AE%89%E8%A3%85systemd%2F</url>
    <content type="text"><![CDATA[wsl默认是没有systemd服务的，需要自行去安装。 安装daemonize和fontconfig sudo apt install -y fontconfig daemonize 编辑/etc/profile脚本，加入如下内容： sudo nano /etc/profile SYSTEMD_PID=$(ps -ef | grep '/lib/systemd/systemd --system-unit=basic.target$' | grep -v unshare | awk '&#123;print $2&#125;')if [ -z "$SYSTEMD_PID" ]; then sudo /usr/bin/daemonize /usr/bin/unshare --fork --pid --mount-proc /lib/systemd/systemd --system-unit=basic.target SYSTEMD_PID=$(ps -ef | grep '/lib/systemd/systemd --system-unit=basic.target$' | grep -v unshare | awk '&#123;print $2&#125;')fiif [ -n "$SYSTEMD_PID" ] &amp;&amp; [ "$SYSTEMD_PID" != "1" ]; then exec sudo /usr/bin/nsenter -t $SYSTEMD_PID -a su - $LOGNAMEfi 修改/etc/sudoers文件，加入如下内容： sudo nano /etc/sudoers %sudo ALL=(ALL) NOPASSWD: /usr/sbin/daemonize /usr/bin/unshare --fork --pid --mount-proc /lib/systemd/systemd --system-unit=basic.target%sudo ALL=(ALL) NOPASSWD: /usr/bin/nsenter -t [0-9]* -a su - [a-zA-Z0-9]* 执行source /etc/profile source /etc/profile 执行systemctl验证是否能够正常操作。 systemctl --version 参考文章地址 Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl安装docker]]></title>
    <url>%2F2020%2F08%2F11%2Fwsl%E5%AE%89%E8%A3%85docker%2F</url>
    <content type="text"><![CDATA[记录如何在wsl2上启用docker服务。 [TOC] 【更新】 之前的作废，并不建议在wsl中安装docker，而是建议直接在Windows上安装docker-desktop。 安装之后的docker也可以直接在wsl中进行使用。 下载下载地址点击这里 直接安装即可，默认会勾选使用wsl引擎。 配置安装成功后，按照图中的顺序在设置里进行选择在wsl中启用即可。 检验进入wsl，并尝试查看docker镜像： ps：不使用sudo，可能会报权限问题 以下作废，不建议使用！！！ 安装过程 安装依赖 sudo apt-get install apt-transport-https ca-certificates curl gnupg2 software-properties-common 信任 Docker 的 GPG 公钥 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 添加软件仓库 sudo add-apt-repository \ "deb [arch=amd64] https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/ubuntu \ $(lsb_release -cs) \ stable" 最后安装 sudo apt-get updatesudo apt-get install docker-ce 配置环境 添加用户 sudo adduser $USER docker 重启服务 sudo service docker restart 尝试运行 docker run hello-world docker images 如果报错，可能是被墙了，建议翻墙后再次尝试。还是不管用的，建议先试试wsl –shutdown重启wsl。 Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl配置java环境]]></title>
    <url>%2F2020%2F08%2F03%2Fwsl%E9%85%8D%E7%BD%AEjava%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[记录如何在wsl中配置java编译环境，以及如何使用vscode进行编译调试。 [TOC] 下载jdk 点击进入到oracle/jdk的下载页面 选择合适的安装包 解压 tar -zxvf ./jdk-* 移动到自己的软件目录 cp -r jdk1* ~/jdk 下载maven 点击进入maven的下载页面 解压 tar -zxvf ./apache* 移动到自己的软件目录 cp -r apache* ~/mvn 配置环境变量 打开sh配置文件 如果用的是bash，就打开.bashrc，我这里用的是zsh，则打开.zshrc sudo nano ~/.zshrc 加入jdk的环境变量 # jdk环境export JAVA_HOME=/home/你的用户名/jdkexport JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH# maven环境export MAVEN_HOME=/home/你的用户名/mvnexport PATH=$MAVEN_HOME/bin:$PATH 重新加载zshrc source ~/.zshrc 测试环境 java -version mvn -version 使用vscode调试java 新建一个java目录 mkdir ~/java 进入java，创建一个java文件 cd ~/java &amp;&amp; touch test.java 进入到vscode中 code . 下载插件 java扩展包 如果遇到问题：【很抱歉，激活面向 Java 的 IntelliCode 支持时遇到问题。有关详细信息，请查看“针对 Java 的语言支持”和 “VS IntelliCode” 输出窗口】 手动降级language support…..到0.64.1 打开刚创建的java文件输入 public class test &#123; public static void main(String[] args) &#123; System.out.println("你好，世界"); int x = 0; while (x &lt; 5) &#123; System.out.println("value of x: " + x); x++; &#125; &#125;&#125; 指定当前的路径下的java路径，如果没有则自己再.vscode下创建一个setting.json文件 &#123; "java.home":"/home/liu/jdk",&#125; 添加断点，使用F5调试运行 完美运行 Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用CDN加速GithubPage访问速度]]></title>
    <url>%2F2020%2F07%2F30%2F%E5%88%A9%E7%94%A8CDN%E5%8A%A0%E9%80%9FGithubPage%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[在国内，githubpage的访问速度相当感人，于是使用CDN加速就变得十分有必要了。 [TOC] Github PageGithub Pages为Github提供的一项静态站点托管服务，它直接从Github仓库获取静态文件进行发布，然后提供一个github.io的二级域名供用户访问，支持绑定自定义域名，支持开启HTTPS，开启HTTPS会自动申请证书同时在证书过期前自动续签，这一切都是免费的，使用极其简单，只需要将你的静态文件提交到Github，然后开启Pages服务即可，我的博客就托管于Github Pages Github Pages免费且稳定的服务让我可以专注内容，而无需考虑成本及维护的问题，非常方便广受好评，但其最大的一个问题就是国内访问速度很慢，如何简单快速又低成本的解决这个问题呢？这里介绍一个服务：Netlify NetlifyNetlify是一家提供静态网站托管的综合平台，支持自动从Github等仓库拉取代码并构建成静态网站进行发布，同时也支持自定义域名，自动申请SSL证书等功能，更为重要的是自动启用CDN加速，国内访问速度要快很多 以下分别是Github Pages和Netlify两个平台同一项目请求速度的对比图 从上图的测试结果可以看出国内各地的访问速度Netlify都能完胜，接下来详细介绍下如何通过Netlify给你的Github Pages加速 打开Netlify官网，点击右上角的Sign up注册账号，这里推荐关联Github账号 关联认证后进入Netlify的后台页面，如下图，点击New site from Git 选择网站源码托管的代码仓库类型，支持Github、Gitlab以及Bitbucket，选择GitHub 然后会进入Github的认证授权页面，点击Authorize Netlify by Netlify 点击Only select repositories选择要授权的Github仓库，当然也可以直接选择授权所有仓库，这个授权在设置中可以改 授权完成回到Netlify后台页面，选择我们刚刚授权的Github仓库继续 选择部署的用户以及分支，如果是一些需要编译的项目，还支持定义编译的命令以及最终发布的目录，纯静态网站的话都不需要填写，直接点击Deploy site即可完成部署 部署完成后，Netlify会自动生成一个随机的二级域名xxx.netlify.com，我们可以修改为自定义的二级域名，点击Site Settings General -&gt; Site details下点击Change site name，可以为这个站点设置一个自定义的名字，二级域名也会相应改变 如果你想绑定自己的域名，需要先在域名管理系统里新建解析，将域名CNAME指向到你的netlify二级域名，以阿里云为例如下 然后进入Netlify管理后台，Domain management -&gt; Domains，点击Add domain alias，填入你的自定义域名 待域名解析生效后就会看到新绑定的域名变为绿色，并且设置为了主域名 最后为自定义域名开启HTTPS支持，Domain management -&gt; HTTPS，点击Verify DNS configuration，域名验证通过则会自动申请证书 至此Netlify与Github绑定完成，可以通过自定义域名访问网站了，之后你每一次提交代码到Github，便会自动发布至Netlify，无需额外操作，非常方便 其他说明如果你是主域名要绑定Netlify，且必须使用A记录的话，可以直接ping一下你的Netlify二级域名地址得到的IP便可以作为域名解析，例如我的域名是ops-coffee.netlify.com，ping之后得到的地址是157.230.35.153，可以多ping几次得到不同的地址，都绑定到域名上以防止单节点故障 国内也有类似于Github pages这样的服务，例如Gitee和Coding提供的pages服务，在速度方面要有不少的优势，但稳定性欠佳，且可能会面临层层审查域名备案等问题 如果你的域名有备案，项目又是纯静态的话还可以考虑直接托管在国内的一些对象存储服务上，例如七牛云、腾讯云等，然后开启CDN加速，效果也不错，并且大多都有免费流量可以使用 Github Pages和Netlify这种免费且可高度自定义的方案，在满足我们个性化需求的同时，省去了维护成本和资金压力，可以让站点活得更久，从而让我们把重点放在持续不断的输出内容，形成良性循环，赶紧试试吧 本篇转载于ops-coffee，仅个人使用。 Enjoy it !]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>CDN</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl配置nodejs环境]]></title>
    <url>%2F2020%2F07%2F30%2Fwsl%E9%85%8D%E7%BD%AEnodejs%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[记录如何在wsl-ubuntu下配置最新的node.js环境。 [TOC] 下载与安装 打开Node.js官网 下载安装包 最好放在一个容易找到的位置 打开wsl找到安装包的位置，进行解压。 tar -xvf node-v*.xz 拷贝解压的文件夹 cp -r node* ~/nodejs 把nodejs添加至环境变量 如果使用的是zsh： sudo nano ~/.zshrc 如果使用的是bash： sudo nano ~/.bashrc 添加nodejs进环境变量： export PATH=/home/你的账号名/nodejs/bin:$PATH 测试环境 node -v npm -v Nodejs的使用 占位，后续更新。 Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl安装字体与配置mlt]]></title>
    <url>%2F2020%2F07%2F30%2Fwsl%E5%AE%89%E8%A3%85SimHei%E5%AD%97%E4%BD%93%2F</url>
    <content type="text"><![CDATA[wsl默认是没有中文字体的，所以使用matplotlib绘图时存在中文就无法显示。所以本篇记录一下如何安装ttf字体，以及在Matplotplotlib中增加该字体。 [TOC] 安装字体下载字体直接百度搜索下载SimHei字体，就可以找到对应网页进行下载。 更改路径与权限 拷贝字体到 usr/share/fonts sudo cp SimHei.ttf /usr/share/fonts/SimHei.ttf 更改该文件夹的权限 sudo chmod 777 /usr/share/fonts 配置matplotlib删除原来的缓存 找到缓存路径 删除缓存 sudo rm -rf /home/liu/.cache/matplotlib 修改配置 找到配置文件路径 编辑配置文件 sudo nano /home/liu/anaconda3/lib/python3.7/site-packages/matplotlib/mpl-data/matplotlibrc 添加下列数据： font.family : sans-seriffont.sans-serif : SimHeiaxes.unicode_minus : False 重启jupyter即可 Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl中使用jupyter-lab]]></title>
    <url>%2F2020%2F07%2F29%2Fwsl%E4%B8%AD%E4%BD%BF%E7%94%A8jupyter-lab%2F</url>
    <content type="text"><![CDATA[wsl安装完成直接使用jupyter-lab，会出现无法自动打开浏览器，即使打开浏览器也会出现“找不到文件”的问题，这篇记录一下如何完美解决这些问题。 [TOC] 安装jupyter-lab其实直接安装anaconda3就可以了，具体请参考这里 使用jupyter-lab打开wsl，键入 jupyter lab 就可以了。 jupyter lab 这时候我们虽然不能正常的跳转浏览器打开，但可以看到对应的链接，ctrl+鼠标左键点击就可进入正确的界面了。 解决自动跳转问题1.找到浏览器的位置 点开快捷方式的属性，复制“目标位置”中的路径 C:\Program Files (x86)\Google\Chrome\Application\chrome.exe 在wsl中找到该位置，其实就是在将该路径转换成linux中的路径 注意：所有的空格或者符号前都需要加防转义符‘\’ 如果和我的路径一样，直接复制下面即可 /mnt/c/Program\ Files\ \(x86\)/Google/Chrome/Application/chrome.exe 在wsl中键入下面命令尝试访问，如果能正确的打开浏览器，说明路径是对的 /mnt/c/Program\ Files\ \(x86\)/Google/Chrome/Application/chrome.exe "https://liuyang0001.github.io/" 这个路径太长了，而且手打起来很麻烦，所以我们建立一个软连接 sudo ln -s /mnt/c/Program\ Files\ \(x86\)/Google/Chrome/Application/chrome.exe /usr/bin/chrome 验证软连接是否成功，看能否成功驱动浏览器 chrome https://liuyang0001.github.io/ 2.编辑jupyter配置文件 首先我们先生成默认配置文件 jupyter notebook --generate-config 打开配置文件，更改浏览器的驱动路径 nano ~/.jupyter/jupyter_notebook_config.py 编辑器这里推荐使用nano，因为可以很方便的进行搜索等操作，当然vim也可以 我们直接在文件的最后面，加上下面这段代码： ## 自定义浏览器import webbrowserwebbrowser.register('chrome',None,webbrowser.GenericBrowser('/usr/bin/chrome'))c.NotebookApp.browser = 'chrome'# -------------------------------------------------- nano操作：Ctrl+O保存，确认，Ctrl+X退出 运行jupyter lab 尝试，发现浏览器已经可以正常打开了，但是会出现找不到文件的情况： 这是由于WSL使用重定向文件启动浏览器可能会导致浏览器无法加载。【浏览器之间的文件结构/路径不同】 所以需要设置禁用重定向，从而允许浏览器使用URL和可见标记启动。 设置禁用重定向 重新打开刚才的配置文件 nano ~/.jupyter/jupyter_notebook_config.py Ctrl +W进行搜索c.NotebookApp.use_redirect_file, 并该项设为False 保存退出，重新打开jupyter lab就已经可以正常运行了 Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl使用zsh与终端美化]]></title>
    <url>%2F2020%2F07%2F28%2Fwsl%E4%BD%BF%E7%94%A8zsh%E4%B8%8E%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96%2F</url>
    <content type="text"><![CDATA[记录如何从bash切换到zsh，如何使用oh-my-zsh对终端进行美化以及zsh一些常用插件的安装。 [TOC] 安装zsh 直接使用apt命令安装即可 sudo apt-get install zsh 切换为shell为zsh chsh -s /bin/zsh 美化zsh这是我修改后的终端样式： 安装Oh My Zsh 注意：这一步最好在~目录下打开。否则可能会出错。 cd ~ 选择一种方式进行安装： 使用 curl 命令 sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 或者使用wget命令 sh -c "$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)" 安装 Powerlevel10k主题 使用git进行下载 git clone --depth=1 https://github.com/romkatv/powerlevel10k.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/themes/powerlevel10k 打开zsh的配置文件 sudo vim ~/.zshrc 选择主题为我们下载主题 ZSH_THEME=powerlevel10k/powerlevel10k 使之生效 source ~/.zshrc 安装字体为了防止终端可能会出现乱码，也是因为你的电脑不支持那么多字体，所以我们需要先安装扩展字体。 Powerlevel10k 作者推荐使用 Meslo Nerd Font 字体，Download these four ttf files: MesloLGS NF Regular.ttf MesloLGS NF Bold.ttf MesloLGS NF Italic.ttf MesloLGS NF Bold Italic.ttf Double-click on each file and click “Install”. This will make MesloLGS NF font available to all applications on your system. WSL配置字体其实就是配置终端的字体，点击设置会自动跳转到一个json格式的文档。 将文档中对应部分换成下面这个，对应的美化配置都有注释，可自行调整： "defaults": &#123; // Put settings here that you want to apply to all profiles. "acrylicOpacity": 0.8, //背景透明度 // "useAcrylic": true, // 启用毛玻璃 //"backgroundImage": "C:\\Users\\Liu\\Pictures\\ubuntu.jpg", //背景图片 // "backgroundImageOpacity": 0.5, //图片透明度 "backgroundImageStretchMode": "fill", //填充模式 "icon": "C:\\Users\\Liu\\Pictures\\最近\\1121490.png", //图标 "fontFace": "MesloLGS NF", //字体 "fontSize": 14, //文字大小 //"colorScheme": "Solarized Light", //主题 "cursorColor": "#FFFFFF", //光标颜色 "cursorShape": "bar" //光标形状 &#125;, 配置 Powerlevel10k 在上面source ~/.zshrc应该就会自动进入自动配置了。 后面想再修改使用该命令即可 自动配置脚本Powerlevel10k 提供了一个配置脚本，运行脚本后只需回答几个简单的问题即可完成配置。 直接输入 p10k configure 即可进入配置问答界面， p10k configure 完成后会生成一个配置文件 ~/.p10k.zsh，并且在 ~/.zshrc 中自动加入了 # To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.[[ -f ~/.p10k.zsh ]] &amp;&amp; source ~/.p10k.zsh 在配置过程中需要注意的是，Instant Promt Mode 尽量选择打开，可以加快终端启动速度，详情请见这里。 个性化设置在 Powerlevel10k 新生成的配置文件 ~/.p10k.zsh 中根据个人喜好进行个性化设置。 每次修改配置文件后重启终端或者新开一个 tab 即可显示。在 vim 中可以通过 :/str 来执行搜索，通过 N 或 n 键来跳转到上一个结果或下一个结果。 重新加载配置重新加载zsh的配置文件，使得配置能够生效。 source ~/.zshrc 安装插件Oh My Zsh 有非常丰富的插件，使用插件可以使得在终端的效率翻倍，下面介绍 5 个我常用的插件。插件均需在配置文件 ~/.zshrc 中写出，如下： plugins=( git github autojump zsh-syntax-highlighting zsh-autosuggestions) gitgit plugin 提供丰富的 git 别名与几个有用的函数。 githubgithub plugin 提供几个快捷的函数。 autojump使用apt安装即可 sudo apt-get install autojump autojump 可以记录下来你之前 cd 到访过的所有目录，下次要去那个目录时不需要输入完整的路径，直接 j somedir 即可到达，甚至那个目标目录的名称只输入开头也可以。 github地址 zsh-syntax-highlightingzsh-syntax-highlighting，终端命令语法高亮。 克隆 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 在~/.zshrc 中配置 plugins=(zsh-syntax-highlighting) zsh-autosuggestionszsh-autosuggestions 终端命令自动推荐，会记录下来之前使用过的命令，当你输入开头时，会暗色提示之前的历史命令供你选择，可直接按右方向键选中该命令。 克隆 git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 在~/.zshrc 中配置 plugins=(zsh-autosuggestions) 更多插件，请自行点击查看github。 zsh配置环境变量这里拿之前装好的anaconda3举例： sudo vim ~/.zshrc 在其中加入anaconda3的环境变量，路径换成自己的： export PATH=/home/liu/anaconda3/bin:$PATH 运行python测试结果： 成功运行，环境变量配置成功。 Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl导致vmmem占用高解决办法]]></title>
    <url>%2F2020%2F07%2F26%2Fwsl%E5%AF%BC%E8%87%B4vmmem%E5%8D%A0%E7%94%A8%E9%AB%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[自从装了wsl我这个年迈的电脑就更加吃力，尤其是内存基本上都要占到90%以上，打开任务管理器一看内存一半以上都是被vmmem吃掉了，于是在网上寻找解决办法，并记录优化过程。 定期执行缓存删除 在WSL bash上，执行以下命令，并进入编辑模式 sudo crontab -e -u root 第一次运行会让你选择编译器，我选择了nano，感觉更加友好。 并添加以下行： */15 * * * * sync; echo 3 &gt; /proc/sys/vm/drop_caches; touch /root/drop_caches_last_run */15 表示将每15分钟执行一次。您可以根据需要更改它 自动启动cron服务 在~/.bashrc 上添加以下行，允许启动cron服务而无需输入root密码， sudo nano ~/.bashrc [ -z &quot;$(ps -ef | grep cron | grep -v grep)&quot; ] &amp;&amp; sudo /etc/init.d/cron start &amp;&gt; /dev/null 如果使用zsh，也在zshrc添加这句话。 在WSL bash上执行并添加以下行： sudo visudo sudo ALL=NOPASSWD: /etc/init.d/cron start 硬限制最大内存 打开文件夹，在地址栏输入%UserProfile%，并回车。 新建文件.wslconfig，并编辑内容： [wsl2]memory=4GBswap=8GBlocalhostForwarding=true 使配置生效要确保所有更改都生效，请在powershell上执行 wsl --shutdown 。然后重新打开您的WSL终端. wsl --shutdown 在wsl终端上可以通过查看/ root / drop_caches_last_run上次修改日期来检查cron作业是否正在相应地运行： sudo stat -c '%y' /root/drop_caches_last_run 上面设置的十五分钟一次，你可以计时看看有没有记录。 ISSUE这个问题，在github以上已经大量反馈，点击这里查看issue详情 Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl安装/卸载mysql]]></title>
    <url>%2F2020%2F07%2F26%2Fwsl%E5%AE%89%E8%A3%85mysql%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[记录下安装mysql的过程，以及遇到的问题和解决方法。 安装基于Ubuntu-18.04，之前尝试了20.04版本尝试了各种方式无果。 安装mysql 首先更新软件源，保证其为最新。 sudo apt-get update sudo apt-get upgrade 然后通过apt命令安装mysql sudo apt-get install mysql-server 静静等待完成，如果没有出现报错，将会得到下面这样： 但是不知道你有没有注意到，正常我们安装是会让你输入mysql密码，但是我们没有。于是尝试启动报错： sudo service mysql start 提示没有权限，于是我们先停止服务给它权限 sudo service mysql stop sudo usermod -d /var/lib/mysql/ mysql 重启服务，尝试登陆，依旧报错. sudo service mysql start mysql -u root -p 这是由于我们安装的过程中并没有输入密码造成的，于是我们需要给自己生成一个密码。 解决办法： 直接修改文件使得我们可以先无需密码进行登录： sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 在图中的位置加上下面这句： skip-grant-tables 重启mysql服务并进行无密码登陆 sudo service mysql restart mysql -u root -p 进入mysql后，分别执行下面三句话： use mysql; update user set authentication_string=password(&quot;你的密码&quot;) where user=&quot;root&quot;; flush privileges; 查看当前的状态 select user,plugin from user; root用户的密码并为成功修改，于是我们再次修改表单： update user set authentication_string=password(&quot;你的密码&quot;),plugin=&apos;mysql_native_password&apos; where user=&apos;root&apos;; 查看修改成功后退出 select user,plugin from user; quit 随后去掉我们之前设置的无密码登陆语句，或者注释掉 sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf 重启mysql服务，尝试登陆。 sudo service mysql start mysql -u root -p 输入刚才设置的密码，root用户使用密码成功登陆。 卸载mysql安装的过程难免会出错，这时候就可能需要卸载掉软件。下面记录下如何完全卸载掉mysql，便于之后重新安装。 自动卸载mysql*相关的软件 sudo apt-get autoremove --purge mysql* 删除掉卸载不完全留下的文件目录 sudo rm -rf /etc/mysql /var/lib/mysql 自动卸载无用的程序 sudo apt-get autoremove 自动清理卸载后的残留信息 sudo apt-get autoclean 这样就mysql就完全卸载好了，之后遵循上面的安装步骤进行安装即可。 Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl使用vscode调试cpp]]></title>
    <url>%2F2020%2F07%2F26%2Fwsl%E4%BD%BF%E7%94%A8vscode%E8%B0%83%E8%AF%95cpp%2F</url>
    <content type="text"><![CDATA[记录如何实现在wsl中使用本地vscode进行调试，编译。 wls安装编译环境安装gcc存储库包含一个名为build-essential的元包，它包含GCC编译器以及编译软件所需的许多库和其他实用程序。 所以我们直接安装它。 sudo apt-get install build-essential 安装gdb这个我们直接apt安装就可以了。 sudo apt-get install gdb 测试测试是否完成了上面的安装，免得后面出问题。 whereis gdb whereis g++ 新建一个cpp文件夹cd ~ mkdir cpp cd cpp 在vscode中打开当前目录在命令行中输入code . 首次会自动安装驱动vscode的程序，随后自动打开vscode。 code . vscode配置安装插件之前在windows安装的插件，都会自动给你推荐适合wsl的版本，直接点击在,xxxx中安装就可以了。 Remote三件套 在扩展商店搜remote，前三个必装，后面的看你自己的实际需求。 安装 C/cpp扩展 安装code runner 配置c/c++扩展 ctrl+shift+p 输入c/c++,找到并点击打开 修改配置如图 配置Tasks 在当前目录新建一个cpp文件，方便后面检测到任务 ctrl+shift+p 输入tasks，找到并点击打开 选择g++ 复制下面的配置到任务json中 &#123; "version": "2.0.0", "windows": &#123; "options": &#123; "shell": &#123; "executable": "bash.exe", "args": [ "-c" ] &#125; &#125; &#125;, "tasks": [ &#123; "label": "g++ build active file", "type": "shell", "command": "/usr/bin/g++", "args": [ "-g", "$&#123;file&#125;", "-o", "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;" ], "group": &#123; "kind": "build", "isDefault": true &#125; &#125;, &#123; "type": "shell", "label": "C/C++: g++ build active file", "command": "/usr/bin/g++", "args": [ "-g", "$&#123;file&#125;", "-o", "$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;" ], "options": &#123; "cwd": "$&#123;workspaceFolder&#125;" &#125;, "problemMatcher": [ "$gcc" ], "group": &#123; "kind": "build", "isDefault": true &#125;, "presentation": &#123; "echo": true, "reveal": "always", "focus": false, "panel": "shared", "showReuseMessage": true, "clear": false &#125; &#125; ]&#125; F5 运行调试 运行调试成功 Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
        <tag>Cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl迁移非系统盘]]></title>
    <url>%2F2020%2F07%2F26%2Fwsl%E8%BF%81%E7%A7%BB%E9%9D%9E%E7%B3%BB%E7%BB%9F%E7%9B%98%2F</url>
    <content type="text"><![CDATA[记录了如何将wsl环境迁移至非系统盘，节约本就不富裕的系统盘空间。 下载 LxRunOffline 点击这里，选择最新版下载即可。 使用与迁移 使用管理员权限打开powershell，并找到解压好的文件 查看当前的wsl环境 .\LxRunOffline.exe list 使用move命令进行迁移 .\LxRunOffline.exe move -n 分发版 -d 目录 我这里还好没出现任何报错或警告，网上说出现警告也没有任何的问题。 打开检测软件能够正常运行 检查一下目前的路径也没有问题 .\LxRunOffline.exe get-dir -n Ubuntu-18.04 更多的用法请输入.\LxRunOffline查询。 Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl安装anaconda]]></title>
    <url>%2F2020%2F07%2F24%2Fwsl%E5%AE%89%E8%A3%85anaconda%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[记录如何在wsl中安装anaconda。 下载与安装 点击打开Anaconda的官网，找到下方的Download按钮，来到下载界面。 下载框中的文件，完成后找到下载的文件位置(最好放在好找的位置) 在wsl中找到这个文件 开始安装 bash Anaconda3-2020.02-Linux-x86_64.sh 随后进入安装过程，有提示时候输入yes，一路回车，等待安装结束。 这里我们需要记下框中的路径，也就conda的路径，我们需要把它添加进环境变量中。 配置环境变量bash终端 编辑profile sudo vim /etc/profile 配置conda等的环境变量，就是上面提到的路径，写到bin即可。 在文件的最底端，加上下面的这句： export PATH=/home/liu/anaconda3/bin:$PATH 重新加载环境变量 source /etc/profile 检查是否成功，输入python，看其是否在anaconda环境下。 zsh终端如果终端已经修改为zsh（没有请略过） sudo vim ~/.zshrc 在其中加入anaconda3的环境变量，路径换成自己的： export PATH=/home/liu/anaconda3/bin:$PATH 运行python测试结果： 更改源更改pypi源 创建文件夹 mkdir ~/.pip 写入配置 sudo nano ~/.pip/pip.conf [global]index-url = https://pypi.doubanio.com/simple/[install]trusted-host=pypi.doubanio.com 更改conda源conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes Enjoy it !]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl配置git环境]]></title>
    <url>%2F2020%2F07%2F24%2Fwsl%E9%85%8D%E7%BD%AEgit%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[这篇记录下在WSL(Ubuntu-20.04)下如何配置git环境。 安装git直接使用apt-get即可。 sudo apt-get install git 随后使用whereis git 或者git --version检查是否安装完成。 配置git 配置你的用户名 git config --global user.name xxx 配置你的邮箱地址 git config --global user.email xxx@xxx.com 查看是否配置成功 git config --list 配置SSH秘钥 生成ssh秘钥，把xxx换成你上面填的邮箱 ssh-keygen -t rsa -C "xxxx@xxx.com" 找到我们生成秘钥并打开公钥 cd ~/.ssh/ 复制公钥的内容并且打开你的github设置界面 找到SSHkey设置，点击右上角的New SSH key 把刚复制的公钥内容添加进去。 回到我们的linux命令行，使用ssh命令检查是否配置成功 ssh git@github.com 这里要输入yes，而不是直接敲回车，切记。 到这里就配置完成了，Enjoy it. 后记很简单的步骤，万万没想到，我还是踩坑了。 总结起来一句话就是：ssh key配置好了也不代表能用https的方式免密码clone和push，其实已经配置好了，只是用了错误的clone方式。 顺便记录一下已经用https方式clone项目的解决办法： 移除当前的源地址。 git remote remove origin 添加ssh格式的源地址 git remote add origin git@github.com:用户名/Repo名称.git]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl的安装/升级笔记]]></title>
    <url>%2F2020%2F07%2F23%2FWSL2%E7%9A%84%E5%AE%89%E8%A3%85%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这部分记录了如何安装wsl，以及如何升级到wsl2的心酸历程。 版本要求安装wsl2对系统版本有硬性的要求： 运行 Windows 10（已更新到版本 2004 的内部版本 19041 或更高版本）。 通过按 Windows 徽标键 + R，检查你的 Windows 版本，然后键入 winver，选择“确定”。 如果内部版本低于 19041，请更新到最新的 Windows 版本。 升级windows 如果版本达到了要求，则跳过此步骤。 Win+S 搜索预览体验计划 加入预览体验计划，获取更新版本。 进行windows更新 然后就是漫长的等待过程，无论是下载还是安装的过程都很漫长。 WSL的安装 使用管理员权限打开powershell 启用“适用于 Linux 的 Windows 子系统”可选功能 dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 这时候wsl其实已经启用了，重启就可以了，但还要更新到wsl2，就在后面一起重启了。 升级到WSL2 启用“虚拟机平台”可选组件 dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重启电脑。 重新管理员身份打开powershell，用下面的命令将wsl2设置为默认。 wsl --set-default-version 2 出现上面这行就是好了，如果有问题请参考后文中遇到的问题及解决办法。 安装linux分发版选择一个你喜欢的就可以了，任君挑选。 打开 Microsoft Store，并选择你偏好的 Linux 分发版。 单击以下链接会打开每个分发版的 Microsoft Store 页面： Ubuntu 16.04 LTS Ubuntu 18.04 LTS Ubuntu 20.04 LTS openSUSE Leap 15.1 SUSE Linux Enterprise Server 12 SP5 SUSE Linux Enterprise Server 15 SP1 Kali Linux Debian GNU/Linux Fedora Remix for WSL Pengwin Pengwin Enterprise Alpine WSL 在分发版的页面中，选择“获取”。 安心等待片刻，就安装好了，这时你点击开始，就可以在最近安装看见你安装好的分发版了。 初次启动它会进行一个初始化的过程，需要等待一段时间。完成之后会让你设置账号和密码。 排查安装问题下面是相关的错误和建议的修复措施。 有关其他常见错误及其解决方法，请参阅 WSL 故障排除页。 安装失败并出现错误 0x80070003 适用于 Linux 的 Windows 子系统只能在系统驱动器（通常是 C: 驱动器）中运行。 请确保分发版存储在系统驱动器上： 打开“设置”-&gt;“存储”-&gt;“更多存储设置： 更改新内容的保存位置” WslRegisterDistribution 失败并出现错误 0x8007019e 未启用“适用于 Linux 的 Windows 子系统”可选组件： 打开“控制面板” -&gt; “程序和功能” -&gt; “打开或关闭 Windows 功能”-&gt; 选中“适用于 Linux 的 Windows 子系统”，或使用本文开头所述的 PowerShell cmdlet。 安装失败，出现错误 0x80070003 或错误 0x80370102 请确保在计算机的 BIOS 内已启用虚拟化。 有关如何执行此操作的说明因计算机而异，并且很可能在 CPU 相关选项下。 尝试升级时出错：Invalid command line option: wsl --set-version Ubuntu 2 请确保已启用适用于 Linux 的 Windows 子系统，并且你使用的是 Windows 内部版本 19041 或更高版本。 若要启用 WSL，请在 PowerShell 提示符下以具有管理员权限的身份运行此命令：Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux。 可在此处找到完整的 WSL 安装说明。 由于虚拟磁盘系统的某个限制，无法完成所请求的操作。虚拟硬盘文件必须是解压缩的且未加密的，并且不能是稀疏的。 请检查 WSL GitHub 主题 #4103，其中跟踪了此问题以提供更新的信息。 无法将词语“wsl”识别为 cmdlet、函数、脚本文件或可运行程序的名称。 请确保已安装“适用于 Linux 的 Windows 子系统”可选组件。 此外，如果你使用的是 ARM64 设备，并从 PowerShell 运行此命令，则会收到此错误。 请改为从 PowerShell Core 或从命令提示符运行 wsl.exe。 相关链接常见问题 WSL 2 常见问题解答 疑难解答 记录所踩的坑 上面的问题和解决办法，是官方的手册给的，下面说记录下安装的心酸历程，如果上面没找到你的问题，可以看看我的经历是不是能给你点帮助： 首先是windows版本，我一直保持着最新的版本，想当然的以为版本足够，查了各种方法也装不上wsl2，后来在一个大佬的笔记里发现要打开预览版本更新。 之后就是安装WSL 2遇到了 requires an update to its kernel component. For information please visit https://aka.ms/wsl2kernel的问题，然后就下载了最新版本的内核。 然后又遇到内核无法安装的问题，这时我已经要炸了，冷静下来想起了解决之前问题时候尝试装过一次内核，随后找到应用卸载的界面卸载了之前装的内核，安装新内核成功。 之后也成功的切换到了wsl2，但是从应用商店下载的Ubuntu20,04第一次打开加载报错，不信邪的我切换回了wsl1，再打开Ubuntu成功运行，这时候我心态已经有点崩了，搞来搞去wsl2还是不能用。 我又在应用商店下载了Ubuntu18.04，切换回了wsl2重新安装，还是失败，看了下报错0xc03a001a，找到一个大佬的解答说是因为开了压缩内容以便节省磁盘空间的原因，首先确定你的一些或者所有的文件夹右上角是否都有两个相对的蓝色箭头，然后找到路径:C:\Users\你的用户名\AppData\Local\Packages\CanonicalGroupLimited.xxxx (xxx为你所下载的对应Linux发行版)这个文件夹，若它确实是右上角带有两个相对箭头，那么： 右键 -&gt; 属性 -&gt; 常规 -&gt; 高级 -&gt; 取消勾选 压缩内容以便节省磁盘空间 这一项 -&gt; 确定再次启动所安装的 Linux 发行版应该就可正常使用。 随后我以为终于可以解决了，然而并没有。还是报错，具体是什么忘记了，也没查到答案。最后问题还是自己解决的。我灵机一动，既然wsl1环境可以正常安装，那我是不是在1环境下安装，再转换到2环境下呢？最后问题完美解决。 wsl --set-version Ubuntu-20.04 2 上面解决办法可能是对的，可能只是需要重启一下再点开安装就行了。 终于等到你，还好我没放弃！]]></content>
      <categories>
        <category>WSL使用笔记</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫项目:Leetcode-Helper]]></title>
    <url>%2F2020%2F06%2F20%2F%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE-Leetcode-Helper%2F</url>
    <content type="text"><![CDATA[哪个程序员😁不想一键下载写过的代码，自动上传Github，并且还能生成一份好看的README呢？ 有用的话点个⭐吧，谢谢你。项目传送门 |🚪| 💕主要功能💕 🍉 模拟登陆力扣中国站(leetcode-cn) 🍉 爬取每题提交的ac代码，保存至本地。 🍉 自动生成优美的README文件至本地。 🍉 支持自动更新至Github仓库。 🍉 加入失败重试机制，减少延时，加快下载速度。 🍉 加入增量更新功能(根据最近的提交来更新已存在的题库)。【默认】 🆕 少啰嗦，先看东西 : 具体效果,点击这里 😃 生成的README效果图： 生成的源码效果图： 💕使用说明💕 clone 该项目到你的本地。 git clone https://github.com/Liuyang0001/Leetcode-Helper.git 配置你的cofig.json文件。 &#123; "email": "xx账号xxxx", "password": "xxx密码xxx", "repo_path": "x:/xxx源码仓库的本地路径xxx/", "git_url": "https://github.com/xxxxx/xxx仓库名xx/tree/master/codes_auto/", "download_start_id": 1, "download_end_id": 1000000, "refresh": false, "get_recent_submissions_nums": 40&#125; 安装依赖库 依赖库为retry ，pandas ，requests，gitpython可自行安装，或者使用： pip install -r requirement.txt 运行main.py文件 python main.py 其他说明： 第一次运行比较慢，主要是需要建立本地数据库，请耐心等待。 后续会增加增量更新，请持续关注。 已加入，默认获取最近40次提交，可以在config修改。 如果发生异常，请尝试重新运行 。 已加入失败重试机制。 为了运行速度，已生成代码不会覆盖，相同题的代码仅保留一份ac的。 如果大家有需求的话，可能还会写个GUI界面，会更直观一点。 本人是一个准研一的小菜🐔，在家无事的练手项目，求轻喷。 Enjoy coding！]]></content>
      <categories>
        <category>爬虫项目</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>git</tag>
        <tag>Spider Study Notes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同时存在unicode-escape和utf-8的解码方法]]></title>
    <url>%2F2020%2F06%2F09%2F%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8unicode-escape%E5%92%8Cutf-8%E7%9A%84%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在爬取lc提交代码的时候遇到的一个问题，在爬取到的源码中，符号是采用unicode-escape编码的，而其中的中文是采用utf-8编码的，正常解码无论怎样都会出现乱码，本文记录下解决办法。 [TOC] 示例下面是lc第一题爬取的源码，编码为”utf-8”，中文可以正确显示，但是换行符等符号并不能正确显示，因此需要转换。 code = "class Solution:\u000A def twoSum(self, nums: List[int], target: int) \u002D\u003E List[int]:\u000A dic \u003D defaultdict(int) # 哈希字典\u000A for i,num in enumerate(nums):\u000A if num in dic: return [dic[num],i]\u000A dic[target\u002Dnum]\u003Di" 正常我们的解码是这样的： code = code.encode(&quot;utf-8&quot;).decode(&quot;unicode-escape&quot;) 这样上面的换行符等就可以正确显示为\n等正确的编码，但是原本上面的中文就是utf-8了，解码为unicode-escape就会出现乱码，输出文件就会像下面的这样。 解决办法 其实很简单，就是局部解码就可以了： 首先利用正则表达式找到所有采用unicode-escape编码的字符， 然后将其解码再替换原字符串 code = re.sub(r'(\\u[\s\S]&#123;4&#125;)',lambda x:x.group(1).encode("utf-8").decode("unicode-escape"),code) 再来查看一下我们写入的文件，就没有乱码的情况了。]]></content>
      <categories>
        <category>Spider Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020中传计算机专硕考研经验贴]]></title>
    <url>%2F2020%2F05%2F29%2F2020%E4%B8%AD%E4%BC%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E7%A1%95%E8%80%83%E7%A0%94%E7%BB%8F%E9%AA%8C%E8%B4%B4%2F</url>
    <content type="text"><![CDATA[本文仅仅是我个人的经验贴，记录下考研总结和反思，如果能给你带来一点收获，那就太好了。 对了，纯主观，不接受反驳。 😃 考前须知如果你还没考虑好是不是要考中传，那下面这些点可能会有些劝退，如果很坚决的想考，那么这些也一定要知道。我只拿专硕举例，学硕我也没什么发言权。 优先一志愿问题：官网写的调剂和一志愿分别排名，优先一志愿。实际情况是今年扩招了，一志愿未满，仍然一志愿按1:1.2左右的比例录取，然后招30个调剂。【后面有很多一志愿补录成功，基本上都上岸了，个人猜测是有一部分调剂上岸，最后并没有来。】至于往年，没有收过调剂，今年比较特殊。按往年的情况来讲，对你影响不大。 复试时间问题：中传的复试时间很晚，若一志愿未上，调剂基本上也不剩什么了，今年情况特殊还有一些，往年更惨一点。 校内调剂问题：没有校内调剂这个说法。 压分问题：专业课没感觉有压分现象，政治，英语常规操作，不过大家都一样。 专业课难度：在只考数据结构里难度中上，甚至考了手写图的代码题。多选题比较爱失分，但好好复习考个110应该问题不大。如果你做过北交大的专业课难度，你就知道我在说什么，北交的专业课真的简单，不过就一门专业课，可以多花点时间，所以还好。 录取分数问题：今年最低分国家线录取，但这不具有代表性，今年情况太特殊了。 学硕调专硕问题：可以报名，但是没有优先政策，就是和所有调剂生一起排名。还是那句话，往年没有收过调剂，今年比较特殊。按往年的情况来讲，对你影响不大。 初试部分如果你能接受中传上面“略显”苛刻的情况，那么就往下看吧。 英语一英语这部分我没有什么发言权，毕竟只有过线的成绩。不过我的自我总结可以给你一些忠告： 英语真题要趁早做，反复做，做到这张卷子里的每个单词你都认识就算合格了。 可以留一年或者两年de真题，留着模拟考试。 不用看恋恋有词，不用看恋恋有词，不用看恋恋有词，重要的事情说三遍，不是说不好，是太磨叽了，很浪费时间。 背单词的软件，我推荐墨墨背单词。 网课不用看太多，我推荐先把去年的刘晓燕救命班看一遍，你就知道你需要前期的储备是什么。阅读可以看唐迟的。 不要买模拟试题，用处不大，别浪费钱。 数学一数学这部分其实核心就是多做题，多总结，无他，唯手熟尔。 数学这部分还是推荐看视频的（可以倍速看，1.5x很爽），不过要一边看一遍记录，不然可能会很快睡着，其实看谁的视频取决于个人风格，张宇确实很有意思，不过我可能更想推荐高昆仑，讲课逻辑很清晰，也经常会给你一些小套路，让你觉得解题挺有意思的，强推。另外，各位也可以支持下我高数老师们的b站号梨米特爱讲课，免费分享各种考研数学的课程，干货很多，各位可以去看看。 我个人对回归教材这个观点不是很赞同的，我就喜欢看别人给我总结完的，看教材我是真的看不下去，而且我都没买辅导教材（题除外），一般就是打印了一遍网课的讲义，做做笔记这样子，也没感觉有什么不行的，而且很省钱！ 关于习题，我做了两遍题源一千题，但是感觉自己还是很菜，我可能是个榆木脑袋，233333。对了，线代部分没有做，线代部分是我永乐大帝的线代笔记。 10月开始做真题，两天一套，要掐时间做，我做了15年的，可能有点少，时间不大够了，前期花的时间太多了。所以你可以9月就开始了。 之后就是最后模拟冲刺阶段了，做了李6，李4，张4. 然后基本上就考试了。 政治政治我能给你的帮助也不太多，几点建议： 没必要买肖秀荣三件套，你不会翻几次的，相信我。只需要买肖1000题就够了，练练选择手感。 网课我推荐徐涛的，听过就知道了，可以后台倍速放着当bgm，玄学：锻炼政治语感。据说腿姐的也不错，我们这年腿姐押题压的很准，可惜我没看，心痛。 对了，我非常推荐小白考研的小程序，可以刷题。很值得买，强推，而且省钱，连上面的肖1000的钱都省下来了，我感觉省钱这一中心思想，贯穿了我公共课的主线。233333 最后阶段就是背了，这个背诵肖四的话可以关注一下b站的“空卡”小姐姐，他的背诵视频很有用。 北京地区的政治确实是存在一定压分情况的，但是你们是一样的，而且你选择中传也调剂的希望不多了，所以压不压分对你一志愿没什么影响，但对你调剂有影响，水区的政治主观题给的真的多一些。 数据结构最后就是专业课了，数据结构，这部分反而简单了，我的建议，时间足够的话，王道书+习题三遍，时间不够也至少要两遍。天勤我没做，这里就不推荐了，想看也可以，但两本书的代码风格完全不一样，很容易乱，推荐选一本看，有时间可以做另一本的题。 往年真题里有数据结构的，我都建议做，比如821的计网+数据结构 ，还有程序设计里的数据结构题。至少做一遍吧，感受下往年的难度，当练手了吧，最好限时做。 最后说一下新改的824数据结构的题型：15道单选，填空，10道判断，10道多选，应用题，代码题。 总体来说，代码部分有难度，我们甚至考了图的代码题，不能拿这个赌还是要掌握，其次就是多选题很容易失分，我们当初大纲都没写这个，吃了大亏啊。 复试部分总成绩构成总成绩 = (初试分数/5)*0.6 + 复试成绩(百分制)*0.4 复试成绩 = 外语听说成绩*0.1 + 专业知识与综合素养*0.9 也就是说总成绩的1分=初试的8.333分=复试成绩的2.5分，这也就意味着你复试比别人高1分就可以抹平初试3.333分的差距，复试的重要性不用我多说了吧，所以高别人30分的也不代表你就稳了(特别高的话，当我没说)，还是要好好复习专业课，低分的更要好好复习去逆袭，我自己本身就是个很好的例子。 专业知识与综合素养部分这部分分成三部分的考核，首先是一分钟自我介绍，然后是专业课抽题部分，个人感觉这部分占比不是很大，我答成什么样子我心理是有b数的，最后成绩很高，只是后面答得比较好，简历写得比较好。回正题，考试官会让你从十个编号里选一个作为你挑选的题目，每个编号里5个问题，你可以从中任意选择3个作答，我们是网络面试，所以是老师读题，你可以选择回答或者不回答当前问题，不会可以跳过，但最后要回答满三个问题。这五个题，一般情况都是数据结构，计算机网络，操作系统，软件工程各一道，剩下还有一道半开放的问题，比如对人工智能的了解，对深度学习算法的理解，对融媒体的了解之类的。下面是我能记起来的考试时出的问题角度，当时考试太紧张，很多都忘了，只能想起这么多了，仅供参考。 专业课抽题（5选3） 数据结构——直接排序，归并排序比较 计网——时分复用 软件工程——类图 最后就是专业课提问的部分，主要是从你的个人陈述（简历），科研设想部分出题，所以我想提醒大家的是：只要是写在你简历上的东西，一定要是自己能有把握回答的东西，要是被问住了，很影响分数。对了，关于简历部分，最重要的是突出亮点，把你最牛逼的，最让人眼前一亮的东西展示出来。对于计算机专业，最重要的肯定是代码能力，比如你熟悉什么语言（c/python/java…）,做了哪些项目，用到了哪些技术栈，有没有竞赛获奖（ACM大佬带带我），或者奖学金，绩点高的也可以写上去(像我一样很低的,还挂了好几科的就算了吧),对了，如果你有博客也可以写上去，也是有加分的。最后再强调一遍，只要是写在你简历上的东西，一定要是自己能有把握回答的东西！不太熟的弄懂，不然就别写，(或者侥幸心里的话这种不太熟的放在后面也行)。 下面是我面试问到的问题，仅供参考。 专业课面试提问 阐述下项目xxx的难点。 介绍一下另一个项目xxxx? 在python中你熟悉的库有哪些? 开放问题——你最熟悉的语言，遇到的问题，如何解决? 谈一下你的科研设想。 你为什么要选择大数据方向？ 英语听说能力部分这部分占比很低，也拉不开什么差距，占复试成绩里的10分，也就是总成绩的4分，基本上不会有超过1分的分差，所以像我这种英语只能过线的水平也不用太过担心。说下流程，主要是两个部分的考核，第一部分是一分钟英语自我介绍，第二部分是十选一抽题作答。第一部分没什么好说的，第二部分主要是一些生活类的话题，或者一些很浅的专业知识相关的问题。重复一下，真的不用担心，拉不开差距的一部分，放轻松把自我介绍背熟就ok了，抽题听不懂的话老师也会给你重复。还听不懂还会用英语给你解释，没问题的，老师都很nice，对了，忘了说，你的考官还是专业面的老师，就是一起考完所有的。自我介绍我写的很水，基本上机器翻译的，给你们做个参考吧。 一分钟自我介绍 Good afternoon, respected professors! My name is Liu Yang, 24 years old. I graduated in Electronic Information Engineering from Tianjin Polytechnic University. After graduation，the more I experienced， the clearer I realized the shortcomings of myself. I’m eager to learn more about computer science and I hope I can study further in CUC. I am a hard-working student and I will try my best to finish my project no matter how difficult it is. Besides ,In my spare time, I would like to write my blog, which is a good way to record what I’ve learned or something interesting in my life. I am very glad to be here for this interview. I hope I can make a good performance today. That’s all, Thank you ! 10选1抽题作答 在你学习c或者python中，遇到的问题如何解决的?(感觉抽到的和上面老师的重了，但是换成英语了) 复试名单问题中传出的复试名单都是乱序的，所以拿到名单第一时间筛选出有用的部分，从而来判断自己的竞争力还是很有必要的，至少你要知道你在复试中排名多少，前后的分数差距。 这是个很好解决的问题，你的考生号都是有规律的，基本上就是：中传编号+地区号+学院号+方向号+顺序号，我们需要拿到的有效的数据是：学院号+方向号,比如说今年学硕学院号是09，专硕是16，方向号一般为10，20，30这种，根据你们的情况来判断就可以了。会py的可以直接拿我写过的脚本修改一下正则表达式，将名单转成csv格式，然后直接跑就行，不会的就直接Excel搜索也行。脚本文件还有我们这届的复试名单，我放github了，脚本传送门。或者给我留言吧，有时间我也可以帮忙，如果我看的到的话。 写在最后这么又臭又长的流水账能看到这里的应该都是真爱了，祝各位都能如愿上岸！ 有问题留言吧，我看到的话会回的，发邮件也行，对了也可以加群，群里学长很多的，他们说当初收到了很多人的帮助，想要帮助一下下一届，他们真是可爱的人呢。 群号：1057574055]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>cuc</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客更新计划]]></title>
    <url>%2F2020%2F05%2F08%2F%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[近期对博客进行调整： 1.加入置顶权重，而不是仅仅依靠时间线来展示顺序。【已完成】 2.由于最近忙于复试，很多题解没更新也没时间进行整理，打算复试后抽出时间进行整理归纳。【在做了，进度1%】 3.写一个爬虫，用来辅助更新LeetCode的readme，应该不是很难得一个脚本，最近有点懒，抽空写完并把其过程记录下来。【已完成】 4.改变代码块风格，使其不显示行号，同时增加一键复制功能。【已完成】 我真的太想念书了，毕竟啊，人菜就要多读书。 努力提升自己永远都不会出错，加油！]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[筛选复试名单]]></title>
    <url>%2F2020%2F05%2F08%2F%E7%AD%9B%E9%80%89%E5%A4%8D%E8%AF%95%E5%90%8D%E5%8D%95%2F</url>
    <content type="text"><![CDATA[今天高高兴兴，因为复试名单公布了，但拿到名单的时候发现是乱序的，那么怎么样才能拿到本专业的真实名单呢？ 所以打算利用所学，来筛选出符合条件的名单，轻松判断自己所处的位置及竞争力。 导入库函数 os ——用来获取当前路径 re ——用来正则匹配考生编号 pandas ——用来操作csv，读取和写入 import reimport osimport pandas as pd 实现方法写出对应的正则表达式 首先我们需要明确要匹配的字符的构成 考生编号：学校编号+地区号+学院号+方向+流水号 根据需要书写正则表达式 # 【计算机专硕】匹配规则pat1 = "^10033[0-9]&#123;4&#125;16[123]0[0-9]&#123;2&#125;$" 读取csv文件这里我们是用pandas进行读取文件，将其格式化为df类型。 需要注意的是：windows默认的编码方式为gbk，而不是utf-8 with open(read_path, encoding="gbk") as file: data = pd.read_csv(file) 取得对应的考生编号，并匹配取得第i行的第一列元素，将其转换成字符串，便于后续对其进行正则匹配 # 取到15位准考证号number = data.iloc[[i], 0].to_string()[-15:] 正则匹配利用re.match()进行匹配，判断当前是否为我们所查找的。 如果匹配，则取到该行的所有元素。 if re.match(rule, number): df = data.iloc[[i], :] 输出到csv文件pandas的df类型数据直接就有输出到csv文件的方法，直接调用输出即可。 不过有几点需要注意： 输出依旧要采用gbk编码 索引值要置为False，不然会多一列我们并不想要的原先数据的索引列 输出模式要选择附加模式，这样不会覆盖原数据 df.to_csv(write_path, mode="a", index=False,header=None, encoding="gbk") 源码Github项目源码地址]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pandas</tag>
        <tag>re</tag>
        <tag>csv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[100-相同的树]]></title>
    <url>%2F2020%2F04%2F01%2F100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91%2F</url>
    <content type="text"><![CDATA[给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例示例 1: 输入: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3]输出: true 示例 2: 输入: 1 1 / \ 2 2 [1,2], [1,null,2]输出: false 示例 3: 输入: 1 1 / \ / \ 2 1 1 2 [1,2,1], [1,1,2]输出: false 解法 核心思想：两棵树同步递归遍历相比较即可。 class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool: # 两个空结点 if not p and not q: return True # 结点均非空且值相等 if p and q and p.val == q.val: return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right) return False 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[99-恢复二叉搜索树]]></title>
    <url>%2F2020%2F04%2F01%2F99-%E6%81%A2%E5%A4%8D%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉搜索树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。 示例示例 1: 输入: [1,3,null,null,2] 1 / 3 \ 2输出: [3,1,null,null,2] 3 / 1 \ 2 示例 2: 输入: [3,1,4,null,null,2] 3 / \1 4 / 2输出: [2,1,4,null,null,3] 2 / \1 4 / 3 进阶: 使用 O(n) 空间复杂度的解法很容易实现。 你能想出一个只使用常数空间的解决方案吗？ 解法 核心思想：两次利用中序遍历该树，第一次遍历为扫描结点值，第二次遍历为把排序后的结点值依次填入。 注意：取排序后的列表值，不能使用pop() class Solution: def recoverTree(self, root: TreeNode) -&gt; None: """ Do not return anything, modify root in-place instead. """ tree = [] def helper(root,flag): if not root: return helper(root.left,flag) if flag=="traverse": tree.append(root.val) elif flag == "modify": # 注意:这里不能使用pop() # 排序不会改变pop的顺序 root.val = tree[0] del tree[0] helper(root.right, flag) # 先遍历 helper(root, flag="traverse") # 排序 tree.sort() # 再替换 helper(root, flag="modify") 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[98-验证二叉搜索树]]></title>
    <url>%2F2020%2F04%2F01%2F98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例示例 1: 输入: 2 / \ 1 3输出: true 示例 2: 输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解法 核心思想：中序遍历该树，得到的数列有序即可证明是一颗二叉排序树 注意：得到的数列应该无重复字符 class Solution: def isValidBST(self, root: TreeNode) -&gt; bool: tree = [] def helper(root): if not root: return helper(root.left) tree.append(root.val) helper(root.right) helper(root) # print(tree,sorted(tree)) # 需判断是否存在重复结点 return tree==sorted(tree) and len(set(tree))==len(tree) 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[96-不同的二叉搜索树]]></title>
    <url>%2F2020%2F04%2F01%2F96-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解法 核心思想：卡特兰数问题，典型的dp解决 class Solution: def numTrees(self, n: int) -&gt; int: dp_list = [0] * (n + 1) dp_list[0] = 1 dp_list[1] = 1 # G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0) for i in range(2, n + 1): for j in range(i): dp_list[i] += dp_list[j]*dp_list[i-j-1] return dp_list[-1] 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>树</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[95-不同的二叉搜索树-ii]]></title>
    <url>%2F2020%2F04%2F01%2F95-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-ii%2F</url>
    <content type="text"><![CDATA[给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解法 核心思想：利用二叉搜索树的性质，左子树只能比当前结点小，右子树只能比当前结点大。每个结点均有可能做为根结点。 技巧点：利用lru_cache收集每一个返回的值 import functoolsclass Solution: # Notice：返回值应为List[TreeNode] def generateTrees(self, n: int) -&gt; List[TreeNode]: if n == 0: return [] # 收集每次的返回值，组成缓存列表,None为动态调节大小 @functools.lru_cache(None) def helper(start, end): res = [] if start &gt; end: res.append(None) for val in range(start, end + 1): # 左子树均小于val for left in helper(start, val - 1): # 右子树均大于val for right in helper(val + 1, end): # 构建树节点 root = TreeNode(val,left,right) res.append(root) return res return helper(1, n) 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>树</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[94-二叉树的中序遍历]]></title>
    <url>%2F2020%2F04%2F01%2F94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[给定一个二叉树，返回它的中序 遍历。 示例输入: [1,null,2,3] 1 \ 2 / 3输出: [1,3,2] 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解法 核心思想：利用递归算法即可 class Solution: def inorderTraversal(self, root: TreeNode) -&gt; List[int]: res = [] def helper(root): if not root: return helper(root.left) res.append(root.val) helper(root.right) helper(root) return res 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>树</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[93-复原ip地址]]></title>
    <url>%2F2020%2F04%2F01%2F93-%E5%A4%8D%E5%8E%9Fip%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。 示例输入: &quot;25525511135&quot;输出: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 解法 核心思想：回溯算法：利用分割4次之后剩余的字符串是否为空，来界定是不是有效的结果 count记录分割次数, ip记录当前的字符串, s记录剩余字符串 注意：分割一次加一个“.”，最后会多出一个点号 class Solution: def restoreIpAddresses(self, s: str) -&gt; List[str]: res = [] # count记录分割次数, ip记录当前的字符串, s记录剩余字符串 def backtrack(count, ip, s): if count == 4: if s=="": # 最后面会有个点号 res.append(ip[:-1]) return if len(s) &gt; 0: # 需考虑[0.0.0.0]的情况 backtrack(count + 1, ip + s[:1] + ".", s[1:]) if len(s) &gt; 1 and s[0] != "0": backtrack(count + 1, ip + s[:2] + ".", s[2:]) if len(s) &gt; 2 and s[0] != "0" and int(s[:3]) &lt; 256: backtrack(count + 1, ip + s[:3] + ".", s[3:]) backtrack(0, "", s) return res 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[92-反转链表]]></title>
    <url>%2F2020%2F04%2F01%2F92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明:1 ≤ m ≤ n ≤ 链表长度。 示例输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 解法 核心思想：需要翻转的部分使用头插法即可 技巧：在原链表添加一个头部，更便于操作 class Solution(): def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode: dummy = ListNode(-1) dummy.next = head pre = dummy # 找到翻转链表部分的前一个节点 for _ in range(m-1): pre = pre.next # print("pre:", pre.val) rear1 = pre # 翻转部分的前一个结点 rear2 = pre.next # 翻转部分的第一个结点，翻转后为尾结点 cur_node = pre.next # 翻转部分的头结点 dummy2 = ListNode(-1) for _ in range(n-m+1): # 头插法翻转链表 save_node = cur_node.next cur_node.next = dummy2.next dummy2.next = cur_node cur_node = save_node # 拼接 rear2.next = cur_node rear1.next = dummy2.next # head结点可能已经改变，返回头结点的下一节点 return dummy.next 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[91-解码方法]]></title>
    <url>%2F2020%2F04%2F01%2F91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[给定一个只包含数字的非空字符串，请计算解码方法的总数。 一条包含字母 A-Z 的消息通过以下方式进行了编码： &apos;A&apos; -&gt; 1&apos;B&apos; -&gt; 2...&apos;Z&apos; -&gt; 26 示例示例 1: 输入: &quot;12&quot;输出: 2解释: 它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。 示例 2: 输入: &quot;226&quot;输出: 3解释: 它可以解码为 &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), 或者 &quot;BBF&quot; (2 2 6) 。 解法 核心思想：利用动态规划的思想，利用前两位来更新当前位置 算法设计如下： 特判，若s为空或者s[0]==”0”，返回0 初始化dp=[0,…,0]，长度为n+1，dp[0]=1,dp[1]=1。dp[1]=1表示第一位的解码方法，dp[0]的作用，在于两位时，如：”12”，dp[2]=dp[1]+dp[0]。 遍历s，遍历区间[1,n)： 若s[i]==”0”： 若s[i-1]==&quot;1&quot; or s[i-1]==&quot;2&quot;： 此时，到当前位置的解码方法dp[i+1]和上上一位的相同， 因为上一位和本位置结合在了一起。dp[i+1]=dp[i-1] 否则，返回0，表示无法解码 否则： 判断何时既可以自身解码也可以和前一位结合： 若上一位s[i-1]==”1”，则当前位既可以单独解码也可以和上一位结合。 或者上一位s[i]==”2”，则此时，若1”&lt;=s[i]&lt;=”6”，也是可以的。 综上，s[i-1]==&quot;1&quot; or (s[i-1]==&quot;2&quot; and &quot;1&quot;&lt;=s[i]&lt;=&quot;6&quot;)。 此时，dp[i+1]=dp[i]+dp[i-1]，等于上一位和上上位的解码方法之和。 否则，dp[i+1]=dp[i] 返回dp[n] class Solution: def numDecodings(self, s: str) -&gt; int: if not s or s[0] == "0": return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(1,n): if s[i] == "0": if s[i - 1] == "1" or s[i - 1] == "2": dp[i + 1] = dp[i - 1] else: return 0 else: if s[i - 1] == "1" or (s[i - 1] == "2" and "1" &lt;= s[i] &lt;= "6"): dp[i + 1] = dp[i] + dp[i - 1] else: dp[i + 1] = dp[i] return dp[n] 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[90-子集II]]></title>
    <url>%2F2020%2F03%2F30%2F90-%E5%AD%90%E9%9B%86II%2F</url>
    <content type="text"><![CDATA[给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] 解法 核心思想：利用回溯算法， 关键点：去重—-&gt;【排序+当前值与上一个值判断】 class Solution: def subsetsWithDup(self, nums: List[int]) -&gt; List[List[int]]: res = [] n = len(nums) nums.sort() def backtrack(index, tem): res.append(tem) for i in range(index, n): if i &gt; index and nums[i] == nums[i-1]: continue backtrack(i + 1, tem + [nums[i]]) backtrack(0, []) return res 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[89-格雷编码]]></title>
    <url>%2F2020%2F03%2F30%2F89-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。格雷编码序列必须以 0 开头。 示例示例 1: 输入: 2输出: [0,1,3,2]解释:00 - 001 - 111 - 310 - 2对于给定的 n，其格雷编码序列并不唯一。例如，[0,2,3,1] 也是一个有效的格雷编码序列。00 - 010 - 211 - 301 - 1 示例 2: 输入: 0输出: [0]解释: 我们定义格雷编码序列必须以 0 开头。 给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。 因此，当 n = 0 时，其格雷编码序列为 [0]。 解法 核心思想：第n个格雷码：G(n) = (n&gt;&gt;1) OXR n，即最高位保留，其他位相异或 class Solution: def grayCode(self, n: int) -&gt; List[int]: res = [] for i in range(2 ** n): # 最高位保留，其他位异或操作 res.append(i ^ (i &gt;&gt; 1)) return res 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>回溯算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[88-合并两个有序数组]]></title>
    <url>%2F2020%2F03%2F30%2F88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 解法 核心思想：先合并，在排序。 坑：有的0有效有的0无效，所以第一个列表有效部分直接取[:-m] class Solution: def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None: """ Do not return anything, modify nums1 in-place instead. """ n = len(nums2) if n == 0: return nums =nums1[:-n] + nums2 nums1[:] = sorted(nums) 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[86-分隔链表]]></title>
    <url>%2F2020%2F03%2F30%2F86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。 你应当保留两个分区中每个节点的初始相对位置。 示例输入: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3输出: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5 解法 核心思想：x为边界，拆分成两个链表处理，最后在合在一起即可。 class Solution: def partition(self, head: ListNode, x: int) -&gt; ListNode: p = head p1 = head1 = ListNode(-1) p2 = head2 = ListNode(-1) while p != None: if p.val &lt; x: p1.next = p p1 = p1.next else: p2.next = p p2 = p2.next p = p.next p1.next = head2.next p2.next = None # 尾边界 del head2 return head1.next 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[84-柱状图中的最大矩形]]></title>
    <url>%2F2020%2F03%2F30%2F84-%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 示例 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 输入: [2,1,5,6,2,3]输出: 10 解法 核心思想：遍历寻找以第i根柱子为最高柱子所能延伸的最大面积 即 找栈顶左右两边第一个比栈顶小的元素，【利用“单调栈”】 巧妙地点：在两侧加上0柱子便于处理边界 class Solution: def largestRectangleArea(self, heights: List[int]) -&gt; int: stack = [] # 在原柱子两端加上两个高度为0的柱子，便于计算边界 heights = [0] + heights + [0] res = 0 # 遍历：以第i根柱子为最高柱子所能延伸的最大面积 # 即 找栈顶左右两边第一个比栈顶小的元素 for i in range(len(heights)): # print(stack) # 调整位置 while stack and heights[stack[-1]] &gt; heights[i]: tmp = stack.pop() res = max(res, (i - stack[-1] - 1) * heights[tmp]) # 当前元素无论如何也要放进去，不同的只是需不需要pop来调整位置 stack.append(i) return res 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[83-删除排序链表中的重复元素]]></title>
    <url>%2F2020%2F03%2F30%2F83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例示例 1: 输入: 1-&gt;1-&gt;2输出: 1-&gt;2 示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 解法 核心思想：利用双指针，跳过重复的结点 class Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: if head and head.next: pre = head p = head.next else: return head while p: if pre.val == p.val: pre.next = p.next p = p.next else: pre = pre.next p = p.next return head 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[82-删除排序链表中的重复元素II]]></title>
    <url>%2F2020%2F03%2F30%2F82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II%2F</url>
    <content type="text"><![CDATA[给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例示例 1: 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2: 输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 解法 核心思想：1.转换成列表 2.利用counter()计数3.将计数为1的重新构建链表 from collections import Counterclass Solution: def deleteDuplicates(self, head: ListNode) -&gt; ListNode: ls = [] p = head # 先将所有结点值扫描进列表 while p: ls.append(p.val) p = p.next # 利用Counter进行计数 nums_dict = Counter(ls) H = ListNode(-1) p = H # 将所有value值为1的重新建立结点 for i in nums_dict.keys(): if nums_dict[i] == 1: p.next = ListNode(i) p = p.next return H.next 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[81-搜索旋转排序数组II]]></title>
    <url>%2F2020%2F03%2F30%2F81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84II%2F</url>
    <content type="text"><![CDATA[假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 进阶: 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 示例示例 1: 输入: nums = [2,5,6,0,0,1,2], target = 0输出: true 示例 2: 输入: nums = [2,5,6,0,0,1,2], target = 3输出: false 解法 核心思想：采用二分查找的思想，判断在那一部分出现完整的升序序列， 需要注意的点：可能存在l=r=mid的情况 class Solution: def search(self, nums: List[int], target: int) -&gt; int: mid, left, right = 0, 0, len(nums)-1 while left &lt;= right: # 二分法 mid = (left + right) // 2 # 找到该点索引值 if nums[mid] == target: return True # 出现重复值，如[1,2,1,1,1]情况 if nums[left] == nums[mid] == nums[right]: left += 1 right -= 1 continue # 旋转点T在mid右区间 # [left......mid....T....right] if nums[left] &lt;= nums[mid]: # target在[left,mid)的升序空间中 if nums[left] &lt;= target &lt; nums[mid]: right = mid # target在(mid,T]或者[T,right]中 else: left = mid + 1 # 旋转点T在mid左区间 # [left...T...mid........right] elif nums[left] &gt; nums[mid]: # target在(mid,right]的升序空间中 if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 # target在[left,T]或者[T，mid) else: right = mid # 未找到该点 return False 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[80-删除排序数组中的重复项II]]></title>
    <url>%2F2020%2F03%2F27%2F80-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9II%2F</url>
    <content type="text"><![CDATA[给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 示例示例 1: 给定 nums = [1,1,1,2,2,3],函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,1,2,3,3],函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。你不需要考虑数组中超出新长度后面的元素。 解法 核心思想：利用双指针，一快一慢，快指针用于遍历，慢指针用于确定新数组的尾端。 class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: # 双指针+计数器 count = 1 # 元素出现的次数 n = len(nums) L, R = 1, 1 while R &lt; n: if nums[R] == nums[R-1]: # 出现重复元素，记录出现的次数 count += 1 else: count = 1 # 若不是重复元素，重置计数器 if count &lt;= 2: # 若只有2个及以下的重复元素，移动L nums[L] = nums[R] L += 1 R += 1 return L 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[79-单词搜索]]></title>
    <url>%2F2020%2F03%2F27%2F79-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 提示： board 和 word 中只包含大写和小写英文字母。 1 &lt;= board.length &lt;= 200 1 &lt;= board[i].length &lt;= 200 1 &lt;= word.length &lt;= 10^3 示例board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]给定 word = &quot;ABCCED&quot;, 返回 true给定 word = &quot;SEE&quot;, 返回 true给定 word = &quot;ABCB&quot;, 返回 false 解法 核心思想：使用回溯算法（dfs），寻找当前字母的上下左右是否存在符合条件的单词，找不到就返回上一层 class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: row = len(board) col = len(board[0]) def __dfs(i, j, wd_len, visited): if wd_len == len(word): return True for x, y in [(-1, 0), (1, 0), (0, 1), (0, -1)]: tem_i = x + i tem_j = y + j if 0 &lt;= tem_i &lt; row and 0 &lt;= tem_j &lt; col \ and board[tem_i][tem_j] == word[wd_len] \ and (tem_i, tem_j) not in visited: visited.add((tem_i, tem_j)) if __dfs(tem_i, tem_j, wd_len+1, visited): return True visited.remove((tem_i, tem_j)) return False for i in range(row): for j in range(col): if board[i][j] == word[0] and __dfs(i, j, 1, &#123;(i, j)&#125;): return True return False 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[78-子集]]></title>
    <url>%2F2020%2F03%2F27%2F78-%E5%AD%90%E9%9B%86%2F</url>
    <content type="text"><![CDATA[给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 解法 核心思想：利用回溯算法，每添加一个数字，加到res一次 class Solution: def subsets(self, nums: List[int]) -&gt; List[List[int]]: res = [] n = len(nums) # 回溯函数 def backtrack(index, tem): res.append(tem) for i in range(index,n): backtrack(i+1, tem+[nums[i]]) backtrack(0, []) return res 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>回溯算法</tag>
        <tag>位操作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[77-组合]]></title>
    <url>%2F2020%2F03%2F27%2F77-%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 解法1 核心思想：使用库函数combinations，直接生成。 from itertools import combinationsclass Solution: def combine(self, n: int, k: int) -&gt; List[List[int]]: return list(combinations(range(1,n+1),k)) 解法2 核心思想：利用回溯算法，每到列表中的长度=k时，添加到res一次 class Solution: def combine(self, n: int, k: int) -&gt; List[List[int]]: res = [] def backtrack(i, k, tem): if k == 0: res.append(tem) return for j in range(i, n+1): backtrack(j + 1, k - 1, tem+[j]) backtrack(1, k, []) return res 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[75-颜色分类]]></title>
    <url>%2F2020%2F03%2F23%2F75-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例输入: [2,0,2,1,1,0]输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 解法 核心思想：使用Counter进行对012进行计数，再依次进行替换原数组即可 class Solution: def sortColors(self, nums: List[int]) -&gt; None: """ Do not return anything, modify nums in-place instead. """ # 调用Counter()进行统计每个数字的个数 c_nums = Counter(nums) index = 0 # 重新对原数组进行覆盖 for i in range(3): for _ in range(c_nums[i]): nums[index] = i index += 1 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[74-搜索二维矩阵]]></title>
    <url>%2F2020%2F03%2F23%2F74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。 该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前一行的最后一个整数。 示例示例 1: 输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3输出: true 示例 2: 输入:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13输出: false 解法 核心思想：将二维数组转为字符串，使用正则表达式匹配 class Solution: def searchMatrix(self, matrix: List[List[int]], target: int) -&gt; bool: s = str(matrix) # 利用正则去掉target前后均有数字的匹配项 if re.findall("[^0-9\-]"+str(target)+"[^0-9]", s): return True else: return False 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>二分查找</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[73-矩阵置零]]></title>
    <url>%2F2020%2F03%2F23%2F73-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。 进阶: 一个直接的解决方案是使用 O(mn) 的额外空间，但这并不是一个好的解决方案。 一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。 你能想出一个常数空间的解决方案吗？ 示例示例 1: 输入: [ [1,1,1], [1,0,1], [1,1,1]]输出: [ [1,0,1], [0,0,0], [1,0,1]] 示例 2: 输入: [ [0,1,2,0], [3,4,5,2], [1,3,1,5]]输出: [ [0,0,0,0], [0,4,5,0], [0,3,1,0]] 解法 核心思想：第一次遍历，将需要置零的行列找出来；第二次遍历，将需要的位置置零 class Solution: def setZeroes(self, matrix: List[List[int]]) -&gt; None: """ Do not return anything, modify matrix in-place instead. """ zero_x, zero_y = [], [] # 遍历矩阵找到需要变0的行和列 for x in range(len(matrix)): for y in range(len(matrix[0])): if matrix[x][y] == 0: zero_x.append(x) zero_y.append(y) # 对应位置变零 for x in range(len(matrix)): for y in range(len(matrix[0])): if x in zero_x or y in zero_y: matrix[x][y] = 0 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[70-爬楼梯]]></title>
    <url>%2F2020%2F03%2F23%2F70-%E7%88%AC%E6%A5%BC%E6%A2%AF%2F</url>
    <content type="text"><![CDATA[假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例示例 1： 输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 解法 核心思想：使用dp，维护dp[n+1]数组 class Solution: def climbStairs(self, n: int) -&gt; int: # 特判 if n &lt; 3: return n # 初始化dp数组 dp_list = [0] * (n + 1) dp_list[1] = 1 dp_list[2] = 2 # 开始dp for i in range(3, n + 1): # dp公式：当前项=前两项之和 dp_list[i] = dp_list[i - 1] + dp_list[i - 2] return dp_list[n] 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[69-x的平方根]]></title>
    <url>%2F2020%2F03%2F23%2F69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例示例 1: 输入: 4输出: 2 示例 2: 输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解法 核心思想：二分查找法。 class Solution: def mySqrt(self, x: int) -&gt; int: if x == 1 or x==0: return x left = 0 right = x//2 while left &lt;= right: mid = left + (right - left) // 2 tmp = mid * mid if tmp == x: return mid elif tmp &lt; x: left = mid + 1 else: right = mid - 1 return right 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[67-二进制求和]]></title>
    <url>%2F2020%2F03%2F23%2F67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定两个二进制字符串，返回他们的和（用二进制表示）。 输入为非空字符串且只包含数字 1 和 0。 示例示例 1: 输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2: 输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 解法 核心思想：转换成整形相加，再转为二进制即可 class Solution: def addBinary(self, a: str, b: str) -&gt; str: res = int(a, base=2) + int(b, base=2) return bin(res)[2:] 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[66-加一]]></title>
    <url>%2F2020%2F03%2F23%2F66-%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例示例 1: 输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 解法 核心思想：分情况讨论： 最后一位为9：转换成整形加一再转成数组（可能会有进位） 最后一位不为9：直接将其加一即可 class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: if digits[-1] != 9: digits[-1] += 1 else: num = "".join(str(item) for item in digits) num = int(num) + 1 digits = [int(x) for x in str(num)] return digits 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[65-有效数字]]></title>
    <url>%2F2020%2F03%2F23%2F65-%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[验证给定的字符串是否可以解释为十进制数字。 说明: 我们有意将问题陈述地比较模糊。在实现代码之前，你应当事先思考所有可能的情况。这里给出一份可能存在于有效十进制数字中的字符列表： 数字 0-9 指数 - “e” 正/负号 - “+”/“-“ 小数点 - “.” 当然，在输入中，这些字符的上下文也很重要。 更新于 2015-02-10:C++函数的形式已经更新了。如果你仍然看见你的函数接收 const char * 类型的参数，请点击重载按钮重置你的代码。 示例&quot;0&quot;` =&gt; `true``&quot; 0.1 &quot;` =&gt; `true``&quot;abc&quot;` =&gt; `false``&quot;1 a&quot;` =&gt; `false``&quot;2e10&quot;` =&gt; `true``&quot; -90e3 &quot;` =&gt; `true``&quot; 1e&quot;` =&gt; `false``&quot;e3&quot;` =&gt; `false``&quot; 6e-1&quot;` =&gt; `true``&quot; 99e2.5 &quot;` =&gt; `false``&quot;53.5e93&quot;` =&gt; `true``&quot; --6 &quot;` =&gt; `false``&quot;-+3&quot;` =&gt; `false``&quot;95a54e53&quot;` =&gt; `false 解法 核心思想：使用float()函数进行尝试转换，出现异常则为False，否则为True class Solution: def isNumber(self, s: str) -&gt; bool: try: float(s.strip()) return True except: return False 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[64-最小路径和]]></title>
    <url>%2F2020%2F03%2F23%2F64-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例输入:[ [1,3,1], [1,5,1], [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。 解法 核心思想：使用动态规划的思想 第一行的情况：当前值更新为当前值➕左侧值 第一列的情况：当前值更新为当前值➕上侧值 不是首行首列：当前值更新为当前值➕min{左侧，上侧} class Solution: def minPathSum(self, grid: List[List[int]]) -&gt; int: if not grid: return 0 m, n = len(grid), len(grid[0]) if m == 1: # 只有一行 return sum(grid[0]) if n == 1: # 只有一列 return sum(list(*zip(*grid))) for i in range(m): for j in range(n): if i == j == 0: continue elif i == 0: grid[i][j] = grid[0][j-1] + grid[0][j] elif j == 0: grid[i][j] = grid[i-1][0] + grid[i][0] else: grid[i][j] = min(grid[i-1][j],grid[i][j-1]) + grid[i][j] return grid[-1][-1] 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[63-不同路径II]]></title>
    <url>%2F2020%2F03%2F14%2F63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II%2F</url>
    <content type="text"><![CDATA[一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：*m 和 n* 的值均不超过 100。 示例输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 解法 核心思想：和上题类似，只需考虑障碍的问题，所以dp的第一行和第一列不能直接初始化为1，更新dp时也需要考虑当前点是否为障碍点，剩下的就和上题的dp公式相同 class Solution: def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int: if not obstacleGrid: # 空 return 0 # 起点或者终点存在障碍 if obstacleGrid[0][0] or obstacleGrid[-1][-1]: return 0 m = len(obstacleGrid) n = len(obstacleGrid[0]) dp = [[0]*n for _ in range(m)] dp[0][0] = 1 # 重新初始第一行与第一列 for i in range(1, n): if(obstacleGrid[0][i] != 1): dp[0][i] = dp[0][i - 1] for j in range(1, m): if(obstacleGrid[j][0] != 1): dp[j][0] = dp[j - 1][0] # 动态规划 for x in range(1, m): for y in range(1, n): if(obstacleGrid[x][y] != 1): dp[x][y] = dp[x-1][y]+dp[x][y-1] return dp[-1][-1] 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[62-不同路径]]></title>
    <url>%2F2020%2F03%2F14%2F62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明： m 和 n 的值均不超过 100。 示例示例 1: 输入: m = 3, n = 2输出: 3解释:从左上角开始，总共有 3 条路径可以到达右下角。1. 向右 -&gt; 向右 -&gt; 向下2. 向右 -&gt; 向下 -&gt; 向右3. 向下 -&gt; 向右 -&gt; 向右 示例 2: 输入: m = 7, n = 3输出: 28 解法 核心思想：维护一个二维的dp数组，到达该点的路径数=到达该点上方的路径数+到达该点左方的路径数 class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: # 初始化DP数组为第一行第一列均为1，其余为0 dp=[[1]*n]+[[1]+[0]*(n-1) for _ in range(m-1)] for i in range(1,m): for j in range(1,n): dp[i][j]=dp[i-1][j]+dp[i][j-1] return dp[-1][-1] 优化Dp数组为按行更新，故使用一行或者一列进行更新维护即可。 class Solution: def uniquePaths(self, m: int, n: int) -&gt; int: cur=[1]*n for i in range(1,m): for j in range(1,n): cur[j]+=cur[j-1] return cur[-1] 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[61-旋转链表]]></title>
    <url>%2F2020%2F03%2F14%2F61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例示例 1: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2: 输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 解法 核心思想：根据规律找出旋转点，再重新构建链表。 class Solution: def rotateRight(self, head: ListNode, k: int) -&gt; ListNode: if head == None or head.next == None or k == 0: return head p = head # 指针 len_ListLink = 1 # 遍历计算链表长度 while p.next: len_ListLink += 1 p = p.next # 找到原表尾的位置 rear = p # 转折点位置 t = len_ListLink - (k % len_ListLink) if t == len_ListLink: return head p = head # 第二次遍历指针 while t &gt; 1: t -= 1 p = p.next newRear = p newHead = p.next # 重新构建链表 newRear.next = None rear.next = head return newHead 另外解的思想：将链表转换为list，排列后在生成链表 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[60-第k个排列]]></title>
    <url>%2F2020%2F02%2F25%2F60-%E7%AC%ACk%E4%B8%AA%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[给出集合 [1,2,3,…,*n*]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，给定 n 和 k，返回第 k 个排列。 当 n = 3 时, 所有排列如下： &quot;123&quot; &quot;132&quot; &quot;213&quot; &quot;231&quot; &quot;312&quot; `”321” 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例示例 1: 输入: n = 3, k = 3输出: &quot;213&quot; 示例 2: 输入: n = 4, k = 9输出: &quot;2314&quot; 解法 核心思想：回溯算法+剪枝 class Solution: def getPermutation(self, n: int, k: int) -&gt; str: # 阶乘表 fac = [1,1,2,6,24,120,720,5040,40320,362880] nums = [i for i in range(1, n + 1)] # 回溯函数 def backTrack(nums,tmp, k): if not nums: return tmp for i in range(len(nums)): if fac[len(nums)-1] &lt; k: k -= fac[len(nums)-1] continue return backTrack(nums[:i]+nums[i+1:], tmp+str(nums[i]), k) return backTrack(nums,"", k) 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[59-螺旋矩阵II]]></title>
    <url>%2F2020%2F02%2F25%2F59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II%2F</url>
    <content type="text"><![CDATA[给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例输入: 3输出:[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ]] 解法 核心思想：设立上下左右四个边界即可，先开辟等大的空数组，再依次填入数字 class Solution: def generateMatrix(self, n: int) -&gt; List[List[int]]: # 设定四个边界值，并初始化要求大的数组，初始为0 l, r, t, b = 0, n - 1, 0, n - 1 mat = [[0 for _ in range(n)] for _ in range(n)] num, tar = 1, n * n while num &lt;= tar: for i in range(l, r + 1): # left to right mat[t][i] = num num += 1 t += 1 for i in range(t, b + 1): # top to bottom mat[i][r] = num num += 1 r -= 1 for i in range(r, l - 1, -1): # right to left mat[b][i] = num num += 1 b -= 1 for i in range(b, t - 1, -1): # bottom to top mat[i][l] = num num += 1 l += 1 return mat 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[58-最后一个单词的长度]]></title>
    <url>%2F2020%2F02%2F25%2F58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串 s，返回其最后一个单词的长度。 如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格的 最大子字符串。 示例输入: &quot;Hello World&quot;输出: 5 解法 核心思想：去除首尾空格后，利用空格进行切片，返回最后一个元素的长度即可。 class Solution: def lengthOfLastWord(self, s: str) -&gt; int: res = s.strip().split(" ") return len(res[-1]) 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[57-插入区间]]></title>
    <url>%2F2020%2F02%2F16%2F57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[给出一个无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例示例 1: 输入: intervals = [[1,3],[6,9]], newInterval = [2,5]输出: [[1,5],[6,9]] 示例 2: 输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]输出: [[1,2],[3,10],[12,16]]解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 解法 核心思想：先添加到原数组中，按左端点排序后，判断后一个的起始点是否包含在前一个区间中。 class Solution: def insert(self, intervals: List[List[int]], newInterval: List[int]) -&gt; List[List[int]]: intervals.append(newInterval) n = len(intervals) if n &lt; 2: return intervals intervals.sort() for i in range(n-1): # 后一个区间中包含在前一个区间内的元素 if intervals[i + 1][0] in range(intervals[i][0], intervals[i][1] + 1): # 新的区间范围 l1, l2 = intervals[i][0], max( intervals[i][1], intervals[i+1][1]) intervals[i+1] = [l1, l2] intervals[i] = "*" res = [i for i in intervals if i != "*" ] return res 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[56-合并区间]]></title>
    <url>%2F2020%2F02%2F16%2F56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[给出一个区间的集合，请合并所有重叠的区间。 示例示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]]输出: [[1,6],[8,10],[15,18]]解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: [[1,4],[4,5]]输出: [[1,5]]解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 解法 核心思想：按左端点排序后，判断后一个的起始点是否包含在前一个区间中 class Solution: def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]: n = len(intervals) if n &lt; 2: return intervals res = [] intervals.sort() for i in range(n-1): # 后一个区间中包含在前一个区间内的元素 if intervals[i + 1][0] in range(intervals[i][0], intervals[i][1] + 1): # 新的区间范围 l1, l2 = intervals[i][0], max(intervals[i][1], intervals[i+1][1]) intervals[i+1] = [l1, l2] intervals[i] = "*" res = [ i for i in intervals if i != "*" ] return res 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[55-跳跃游戏]]></title>
    <url>%2F2020%2F02%2F16%2F55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。 示例示例 1: 输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 解法 核心思想：贪心算法。从头开始遍历，不断更新当前位置能达到的最大位置，最大索引大于数组长度则可以到达。 class Solution: def canJump(self, nums: List[int]) -&gt; bool: max_i = 0 # 初始化当前能到达最远的位置 # i为当前位置，jump是当前位置的跳数 for i, jump in enumerate(nums): # 如果当前位置能到达，并且当前位置+跳数&gt;最远位置 if max_i &gt;= i and i+jump &gt; max_i: max_i = i+jump # 更新最远能到达位置 return max_i &gt;= i 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[54-螺旋矩阵]]></title>
    <url>%2F2020%2F02%2F16%2F54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例示例 1: 输入:[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ]]输出: [1,2,3,6,9,8,7,4,5] 示例 2: 输入:[ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12]]输出: [1,2,3,4,8,12,11,10,9,5,6,7] 解法 核心思想：输出一次-&gt;删掉-&gt;旋转一次 class Solution: def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]: res = [] while matrix: res += matrix.pop(0) matrix = list(map(list, zip(*matrix)))[::-1] return res 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[53-最大子序和]]></title>
    <url>%2F2020%2F02%2F15%2F53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 示例输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 解法 核心思想：使用动态规划的思想，直接在原数组上修改 class Solution: def maxSubArray(self, nums: List[int]) -&gt; int: n = len(nums) max_sum = nums[0] for i in range(1, n): if nums[i - 1] &gt; 0: # 保存到当前位置可能的最大子序和 nums[i] += nums[i - 1] # 更新max值 max_sum = max(nums[i], max_sum) return max_sum 相关信息LeetCode：Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[50-pow-x-n]]></title>
    <url>%2F2020%2F02%2F15%2F50-pow-x-n%2F</url>
    <content type="text"><![CDATA[实现 pow(x, n)，即计算 x 的 n 次幂函数。 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 示例输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 示例 1: 输入: 2.00000, 10输出: 1024.00000 示例 2: 输入: 2.10000, 3输出: 9.26100 示例 3: 输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 解法 核心思想：转换成二进制计算法 class Solution: def myPow(self, x: float, n: int) -&gt; float: flag = True if n &gt; 0 else False res, n = 1, abs(n) while n: # 每次取得最后一位 if n &amp; 0x01: res *= x x *= x n &gt;&gt;= 1 return res if flag else 1/res 相关信息Discussion | Solution]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[49-字母异位词分组]]></title>
    <url>%2F2020%2F02%2F14%2F49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84%2F</url>
    <content type="text"><![CDATA[给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 示例输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],输出:[ [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;], [&quot;nat&quot;,&quot;tan&quot;], [&quot;bat&quot;]] 解法 核心思想：维护一个ans的映射表，key为字母的拆散后排序形成的元祖，value为字符串列表，默认为空列表。 class Solution: def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]: # value默认值为空列表 ans = collections.defaultdict(list) for s in strs: ans[tuple(sorted(s))].append(s) print(ans) return ans.values() 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[48-旋转图像]]></title>
    <url>%2F2020%2F02%2F12%2F48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F%2F</url>
    <content type="text"><![CDATA[给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例示例 1:给定 matrix = [ [1,2,3], [4,5,6], [7,8,9]],原地旋转输入矩阵，使其变为:[ [7,4,1], [8,5,2], [9,6,3]] 示例 2:给定 matrix =[ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16]], 原地旋转输入矩阵，使其变为:[ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11]] 解法解法1 核心思想：先转置矩阵，再将每行逆置。 class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: n = len(matrix[0]) # 转置矩阵 for i in range(n): for j in range(i, n): matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i] # 翻转每行 for i in range(n): matrix[i].reverse() 该思路还可以一行代码解决： class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: """ Do not return anything, modify matrix in-place instead. """ matrix[:] = map(list,zip(*matrix[::-1])) 解法2核心思想：从外层到内层，每个元素旋转90度 class Solution: def rotate(self, matrix: List[List[int]]) -&gt; None: """ Do not return anext_ything, modify matrix in-place instead. """ # 求转90度后下一个坐标的位置 def next_xy(x, y, s): return y, s - 1 - x n = len(matrix) # 行数 for i in range(n): l = n - i * 2 if l &lt; 2: break # 列数 for j in range(l-1): x, y = 0, j tem = matrix[x + i][y + i] # 四条边上各有一个点 for _ in range(4): next_x, next_y = next_xy(x, y, l) tem_new = matrix[next_x+i][next_y+i] matrix[next_x+i][next_y+i] = tem x, y, tem = next_x, next_y, tem_new 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>叔祖</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[47-全排列II]]></title>
    <url>%2F2020%2F02%2F07%2F47-%E5%85%A8%E6%8E%92%E5%88%97II%2F</url>
    <content type="text"><![CDATA[给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例输入: [1,1,2]输出:[ [1,1,2], [1,2,1], [2,1,1]] 解法 核心思想：采用回溯算法。 class Solution: def permuteUnique(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() # 排序 # 设置访问数组 check = [0 for _ in range(len(nums))] res, tem = [], [] # 调用回溯函数 self.backtrack(nums, tem, res, check) return res # 回溯函数 def backtrack(self, nums: List[int], tem: List[int], res: List[int], check): if len(tem) == len(nums): res.append(tem[:]) else: for i in range(len(nums)): if check[i] == 1: continue # 剪枝 if i &gt; 0 and nums[i] == nums[i - 1] and check[i - 1] == 0: continue check[i] = 1 tem.append(nums[i]) self.backtrack(nums, tem, res, check) check[i] = 0 if tem == []: # 无法pop的情况 return tem.pop() 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>回溯算法l</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[46-全排列]]></title>
    <url>%2F2020%2F02%2F07%2F46-%E5%85%A8%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[给定一个没有重复数字的序列，返回其所有可能的全排列。 示例输入: [1,2,3]输出:[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]] 解法 核心思想：采用回溯算法。 class Solution: def permute(self, nums: List[int]) -&gt; List[List[int]]: nums.sort() len_nums = len(nums) # 设置访问标记 check = [0 for _ in range(len_nums)] res, tem = [], [] # 调用回溯函数 self.backtrack(nums, tem, res, check) return res # 回溯函数 def backtrack(self, nums: List[int], tem: List[int], res: List[int], check): if len(tem) == len(nums): res.append(tem[:]) else: for i in range(len(nums)): if check[i] == 1: continue check[i] = 1 tem.append(nums[i]) self.backtrack(nums, tem, res,check) check[i] = 0 if tem == []: # 无法pop的情况 return tem.pop() 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[43-字符串相乘]]></title>
    <url>%2F2020%2F02%2F06%2F43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98%2F</url>
    <content type="text"><![CDATA[给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 示例示例 1:输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;输出: &quot;6&quot; 示例 2:输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;输出: &quot;56088&quot; 解法 核心思想：用一个list来保存每一位（+进位后的），然后再转成字符串即可。 class Solution(object): def multiply(self, num1: str, num2: str) -&gt; str: if num1 == "0" or num2 == "0": return "0" num1, num2 = num1[::-1], num2[::-1] # 反转方便遍历相乘 lenNum = len(num1) + len(num2) # 保存最终最大的数字 returnNum = [0 for c in range(lenNum)] # 用list先存储 for index2 in range(len(num2)): multiplier2 = int(num2[index2]) # 就直接按照顺序放，最后再反过来！ for index1 in range(len(num1)): multiplier1 = int(num1[index1]) temp = multiplier2 * multiplier1 + returnNum[index1 + index2] if temp &gt;= 10: # 是否涉及进位问题 returnNum[index1 + index2] = temp % 10 returnNum[index1 + index2 + 1] += int(temp / 10) else: returnNum[index1 + index2] = temp returnNum = returnNum[::-1] while returnNum and returnNum[0] == 0: del returnNum[0] # 去除无效的0 returnNum = [str(c) for c in returnNum] # 将列表中的每一个元素转成字符串 return ''.join(returnNum) 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[42-接雨水]]></title>
    <url>%2F2020%2F02%2F05%2F42-%E6%8E%A5%E9%9B%A8%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 解法核心思路：使用双指针从两侧遍历,与当前的最大左右值相比，判断当前格子装了多少水。 class Solution: def trap(self, height: [int]) -&gt; int: size = len(height) if size &lt; 3: return 0 left, right = 0, size - 1 left_max, right_max = height[left], height[right] res = 0 while left &lt; right: if height[left] &lt;= height[right]: if height[left] &gt; left_max: left_max = height[left] else: res += left_max - height[left] left += 1 else: if height[right] &gt; right_max: right_max = height[right] else: res += right_max - height[right] right -= 1 return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[41-缺失的第一个正数]]></title>
    <url>%2F2020%2F02%2F04%2F41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 示例示例 1:输入: [1,2,0]输出: 3 示例 2:输入: [3,4,-1,1]输出: 2 示例 3:输入: [7,8,9,11,12]输出: 1 解法 核心思想：通过桶排序的思想，使得每个数字和其索引相对应。 负数和大于数组长度的数跳过 class Solution: # 3 应该放在索引为 2 的地方 # 4 应该放在索引为 3 的地方 def firstMissingPositive(self, nums: List[int]) -&gt; int: size = len(nums) for i in range(size): # 先判断这个数字是不是索引，然后判断这个数字是不是放在了正确的地方 # i != nums[i]-1 这里外层套nums是防止[1,1]出现死循环 while 1 &lt;= nums[i] &lt;= size and nums[i] != nums[nums[i] - 1]: nums[nums[i]-1], nums[i] = nums[i],nums[nums[i]-1] for i in range(size): if i + 1 != nums[i]: return i + 1 return size + 1 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[40-组合总和II]]></title>
    <url>%2F2020%2F02%2F03%2F40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII%2F</url>
    <content type="text"><![CDATA[给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例示例 1:输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2:输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 解法 核心思想：回溯算法 关键点：去重，如果上一个数和当前数字相同，则跳过 class Solution: def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]: begin, end = 0, len(candidates) if end == 0: return [] res, path = [], [] candidates.sort() self.helper(candidates, begin, end, target, path, res) return res def helper(self, candidates: List[int], begin: int, end: int, delta: int, path: List[int], res: List[int]): if delta == 0: res.append(path[:]) for index in range(begin, end): delta_new = delta-candidates[index] if delta_new &lt; 0: break # 剪枝 if index != begin and candidates[index-1] == candidates[index]: continue path.append(candidates[index]) # 与上题的不同在于每个元素不能重复使用 # 所以下一个区间为[index+1,end) self.helper(candidates, index+1, end, delta_new, path, res) path.pop() 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[39-组合总和]]></title>
    <url>%2F2020%2F02%2F03%2F39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例示例 1:输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]] 示例 2:输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 解法 核心思想：采用回溯算法 class Solution: def combinationSum(self, candidates: List[int], target: int) -&gt; List[List[int]]: begin, end = 0, len(candidates) if end == 0: return [] # 剪枝的前提是数组元素排序 # 深度深的边不能比深度浅的边还小 # 要排序的理由：1、前面用过的数后面不能再用；2、下一层边上的数不能小于上一层边上的数。 candidates.sort() # 在遍历的过程中记录路径，一般而言它是一个栈 path, res = [], [] # 注意要传入 end ，在 range 中， end 取不到 self.helper(candidates, 0, end, path, res, target) return res def helper(self, candidates, begin, end, path, res, target): # 先写递归终止的情况 if target == 0: # Python 中可变对象是引用传递，因此需要将当前 path 里的值拷贝出来 # 或者使用 path.copy() res.append(path[:]) for index in range(begin, end): delta = target - candidates[index] # “剪枝”操作，不必递归到下一层，并且后面的分支也不必执行 if delta &lt; 0: break path.append(candidates[index]) # 因为下一层不能比上一层还小，起始索引还从 index 开始 self.helper(candidates, index, end, path, res, delta) path.pop() 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[38-外观数列]]></title>
    <url>%2F2020%2F02%2F02%2F38-%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[外观数列是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。给定一个正整数 n（1 ≤ n ≤ 30），输出外观数列的第 n 项。 前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 被读作 (&quot;一个一&quot;) , 即 11。11 被读作 (&quot;两个一&quot;）, 即 21。21 被读作（&quot;一个二&quot; , &quot;一个一&quot;) , 即 1211。 注意：整数序列中的每一项将表示为一个字符串。 示例示例 1:输入: 1输出: &quot;1&quot; 示例 2:输入: 4输出: &quot;1211&quot;解释：当 n = 3 时，序列是 &quot;21&quot;，其中我们有 &quot;2&quot; 和 &quot;1&quot; 两组，&quot;2&quot; 可以读作 &quot;12&quot;，也就是出现频次 = 1 而 值 = 2；类似 &quot;1&quot; 可以读作 &quot;11&quot;。所以答案是 &quot;12&quot; 和 &quot;11&quot; 组合在一起，也就是 &quot;1211&quot;。 解法 核心思想：后一个序列是由前一个序列确定的，故采用递归法。 class Solution: def countAndSay(self, n: int) -&gt; str: if(n == 1): return '1' # 加上*，可以防止数组越界,不用考虑边界问题 num = self.countAndSay(n-1)+"*" nums_ls = list(num) # print(nums_ls) count, res = 1, "" for i in range(len(nums_ls) - 1): # 计数重复的数值 if nums_ls[i] == nums_ls[i+1]: count += 1 elif nums_ls[i] != nums_ls[i+1]: res += str(count) + nums_ls[i] # print(res) count = 1 return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[36-有效的数独]]></title>
    <url>%2F2020%2F02%2F02%2F36-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 ‘.’ 表示。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 ‘.’ 。 给定数独永远是 9x9 形式的。 示例示例 1:输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2:输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 解法 核心思想：使用三个哈希表进行计数，三个表中所有的value均不大于1时，返回True。 如何计算Box的索引值? 按照上图将9x9的数独分成0-8共九个3x3：则索引值为： box_index = row//3*3+column//3 完整代码： class Solution: def isValidSudoku(self, board: List[List[str]]) -&gt; bool: rows_ls = [&#123;&#125; for i in range(9)] columns_ls = [&#123;&#125; for i in range(9)] boxes_ls = [&#123;&#125; for i in range(9)] for row in range(9): for column in range(9): num = board[row][column] if num != ".": num = int(num) box_index = row//3*3+column//3 rows_ls[row][num] = rows_ls[row].get(num, 0) + 1 columns_ls[column][num] = columns_ls[column].get( num, 0) + 1 boxes_ls[box_index][num] = boxes_ls[box_index].get( num, 0) + 1 # check valid if rows_ls[row][num] &gt; 1 or columns_ls[column][num] &gt; 1 or boxes_ls[box_index][num] &gt; 1: return False return True 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[35-搜索插入位置]]></title>
    <url>%2F2020%2F02%2F02%2F35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例示例 1:输入: [1,3,5,6], 5输出: 2 示例 2:输入: [1,3,5,6], 2输出: 1 示例 3:输入: [1,3,5,6], 7输出: 4 示例 4:输入: [1,3,5,6], 0输出: 0 解法一行解法 核心思想：将小于target的元素生成一个列表，计算长度即可 class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: # 一行解法 return len([ i for i in nums if i&lt;target ]) 二分查找 核心思想：找到最大的不大于target的索引位置 class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: nums_len = len(nums) if nums_len == 0: return 0 left, right = 0, nums_len-1 while left &lt;= right: mid = (left+right)//2 if nums[mid] == target and nums[mid-1] &lt; target: return mid if nums[mid] &gt;= target: right = mid-1 else: left = mid+1 return left 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[34-排序数组中查找元素的第一和最后一个位置]]></title>
    <url>%2F2020%2F02%2F02%2F34-%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例示例 1:输入: nums = [5,7,7,8,8,10], target = 8输出: [3,4] 示例 2:输入: nums = [5,7,7,8,8,10], target = 6输出: [-1,-1] 解法 核心思想：采用两次二分查找，一次确定左边界，一次确定右边界。 为何要分两次？ 因为有重复的target值，当mid==target时，需要判定向左递归还是向右递归。 class Solution: def searchRange(self, nums: List[int], target: int) -&gt; List[int]: nums_len = len(nums) if nums_len == 0: return [-1, -1] return [self.getLeft(nums, 0, nums_len-1, target), self.getRight(nums, 0, nums_len-1, target)] # 寻找左边界 def getLeft(self, nums: List[int], left: int, right: int, target: int) -&gt; int: # 递归出口 if left &gt;= right: return left if nums[left] == target else - 1 mid = (left + right) // 2 if nums[mid] == target and nums[mid-1] != target: return mid # 递归入口 if nums[mid] &lt; target: return self.getLeft(nums, mid+1, right, target) elif nums[mid] &gt;= target: # mid==target时取左侧，向左递归 return self.getLeft(nums, left, mid-1, target) # 寻找右边界 def getRight(self, nums: List[int], left: int, right: int, target: int) -&gt; int: if left &gt;= right: return left if nums[left] == target else - 1 mid = (left + right) // 2 if nums[mid] == target and nums[mid+1] != target: return mid if nums[mid] &gt; target: return self.getRight(nums, left, mid-1, target) elif nums[mid] &lt;= target: # mid==target时取右侧，向右递归 return self.getRight(nums, mid+1, right, target) 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode刷题笔记分类]]></title>
    <url>%2F2020%2F01%2F31%2F%E7%BD%AE%E9%A1%B6-Leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Github源码仓库页 今天也是充满希望的一天，要努力刷题鸭！ 按照问题分类 字符串 数组问题 链表问题 按照解法分类 栈 队列 双指针 哈希算法 二分查找 动态规划 贪心算法 回溯算法]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[33-搜索旋转排序数组]]></title>
    <url>%2F2020%2F01%2F31%2F33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例示例 1:输入: nums = [4,5,6,7,0,1,2], target = 0输出: 4 示例 2:输入: nums = [4,5,6,7,0,1,2], target = 3输出: -1 解法 核心思路：使用二分法。关键点在与找到转折点T与mid点的关系，判断target是否在升序的那一部分中来更新left和right的值。 class Solution: def search(self, nums: List[int], target: int) -&gt; int: mid, left, right = 0, 0, len(nums)-1 while left &lt;= right: # 二分法 mid = (left + right) // 2 # 判断mid点是否为所求点 if nums[mid] == target: return mid # 旋转点T在mid右区间 # [left......mid....T....right] if nums[left] &lt;= nums[mid]: # target在[left,mid)的升序空间中 if nums[left] &lt;= target &lt; nums[mid]: right = mid # target在(mid,T]或者[T,right]中 else: left = mid + 1 # 旋转点T在mid左区间 # [left...T...mid........right] elif nums[left] &gt; nums[mid]: # target在(mid,right]的升序空间中 if nums[mid] &lt; target &lt;= nums[right]: left = mid + 1 # target在[left,T]或者[T，mid) else: right = mid # 未找到该点 return -1 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[32-最长有效括号]]></title>
    <url>%2F2020%2F01%2F23%2F32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。 示例示例 1:输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2:输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 解法利用栈思路： 特判，若s为空，返回0 初试化栈stack=[-1]，和结果res=0。栈中元素表示上一不匹配位置索引。 遍历s： 若s[i]==&quot;(&quot;，将当前位置索引加入stack。表示将当前左括号需要匹配，为不匹配索引。 若s[i]==&quot;)&quot;：出栈，stack.pop()。表示将对应左括号索引出栈，或者当栈中只有 ) 时，将上一 ) 索引出栈。若栈为空，表示之前的所有的 ( 匹配成功，上一步出栈的是栈底的-1或者是前一个不匹配的 ) 。则更新栈底为当前 ) 的索引，表示不匹配的位置。 否则，说明和栈中的 ( 匹配上了，此时更新最长序列res=max(res,i−stack[−1])。表示当前位置索引减去上一不匹配位置索引 和之前res中的较大值。 更新res class Solution: def longestValidParentheses(self, s: str) -&gt; int: if not s: return 0 res = 0 stack = [-1] # -1占位 for i in range(len(s)): if s[i] == "(": stack.append(i) elif s[i] == ")": stack.pop() # 弹出对应的左括号索引 # 空栈表示已经出现不合法的括号， # 把索引值压进栈中 if not stack: stack.append(i) else: # i-stack中倒数第一个的索引值 # 为当前合法的长度大小 res = max(res, i - stack[-1]) return res 动态规划思路： 特判，若s为空，返回0 初试化dp=[0,...,0]，长度为n。dp[i]表示到i位置的最长有效括号的长度。显然，当s[i]==(时，dp[i]=0 遍历字符串，遍历区间[1,n)： 当s[i]==)时，若s[i−1]==(，说明这两个有效。则dp[i]=dp[i-2]+2否则s[i-1]==)，此时找到上一匹配字符串的上一位i−dp[i−1]−1： 若s[i-dp[i-1]-1]==(，说明s[i]s[i]可以和s[i-dp[i-1]-1]匹配：则dp[i]=dp[i-1]+dp[i-dp[i-1]-2]+2，表示当前位置的最长有效括号长度等于上一位有效括号的长度加上自身匹配的上一位的有效括号的长度加上2。 更新res，res=max(res,dp[i]) # 动态规划class Solution: def longestValidParentheses(self, s: str) -&gt; int: if(not s): return 0 res = 0 n = len(s) dp = [0]*n for i in range(1, len(s)): if(s[i] == ")"): if(s[i-1] == "("): dp[i] = dp[i-2]+2 if(s[i-1] == ")" and i-dp[i-1]-1 &gt;= 0 and s[i-dp[i-1]-1] == "("): dp[i] = dp[i-1]+dp[i-dp[i-1]-2]+2 res = max(res, dp[i]) return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[31-下一个排列]]></title>
    <url>%2F2020%2F01%2F21%2F31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 示例1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1 解法核心思想： 先找出最大的索引 k 满足 nums[k] &lt; nums[k+1]，如果不存在，就翻转整个数组； 再找出另一个最大索引 l 满足 nums[l] &gt; nums[k]； 交换 nums[l] 和 nums[k]； 最后翻转 nums[k+1:]。 举个例子： 比如 nums = [1,2,7,4,3,1]，下一个排列是什么？ 我们找到第一个最大索引是 nums[1] = 2，则firstIndex=1 再找到第二个最大索引是 nums[4] = 3，则secondIndex=4 交换nums[1]和nums[4]，nums = [1,3,7,4,2,1]; 翻转[firstIndex+1:]，nums = [1,3,1,2,4,7] ，完毕! class Solution: def nextPermutation(self, nums: List[int]) -&gt; None: """ Do not return anything, modify nums in-place instead. """ # 初始化两个索引值 firstIndex, secondIndex = -1, -1 n = len(nums) # 找第一个最大索引 for i in range(n-2, -1, -1): if nums[i] &lt; nums[i+1]: firstIndex = i break # 未找到则反转整个数组 if firstIndex == -1: # nums[:]为使得nums的地址不变 nums[:]=nums[::-1] return # 找第二个索引 for i in range(n-1, firstIndex, -1): if nums[i] &gt; nums[firstIndex]: secondIndex = i break nums[firstIndex], nums[secondIndex] = nums[secondIndex], nums[firstIndex] nums[:]= nums[:firstIndex+1]+nums[firstIndex+1:][::-1] 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[29-两数相除]]></title>
    <url>%2F2020%2F01%2F21%2F29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4%2F</url>
    <content type="text"><![CDATA[给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 返回被除数 dividend 除以除数 divisor 得到的商。 示例示例 1:输入: dividend = 10, divisor = 3输出: 3 示例 2:输入: dividend = 7, divisor = -3输出: -2 说明: 被除数和除数均为 32 位有符号整数，且除数不为 0。假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。 解法 核心思想：用减法代替除法操作，用左移来增大两倍，不断增大被除数来减少执行次数 class Solution: def divide(self, dividend, divisor): sig = not ((dividend&gt;=0) ^ (divisor &gt; 0)) # 判断二者相除是正or负（同或操作） dividend, divisor = abs(dividend), abs(divisor) # 将被除数和除数都变成正数 res = 0 # 用来表示减去了多少个除数，也就是商为多少 while divisor &lt;= dividend: # 当被除数小于除数的时候终止循环 tmp_divisor, count = divisor, 1 # 倍增除数初始化 while tmp_divisor &lt;= dividend: # 当倍增后的除数大于被除数则变成最开始的除数 dividend -= tmp_divisor res += count count &lt;&lt;= 1 # 向左移动一位,扩大两倍 tmp_divisor &lt;&lt;= 1 # 更新除数(将除数扩大两倍) res_value = res if sig else -res # 给结果加上符号 return max(min(res_value, 2147483647), -2147483648) 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15-三数之和]]></title>
    <url>%2F2020%2F01%2F20%2F15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解法 核心思想：固定一个点，利用双指针遍历 关键点在去除不可能的情况： 最小的大于0 总数小于三个 之前判别过的（low从i+1开始） 去除res中的重复答案 利用set()去重class Solution: def threeSum(self, nums: List[int]) -&gt; List[List[int]]: len_nums = len(nums) res = set() nums.sort() for i in range(len_nums-1): if nums[i] &gt; 0: return list(res) low = i+1 high = len_nums-1 while low &lt; high: sumOfThree = nums[i]+nums[low]+nums[high] if sumOfThree == 0: res.add((nums[i], nums[low], nums[high])) if sumOfThree &lt; 0: low += 1 elif sumOfThree &gt;= 0: high -= 1 for l in res: l=list(l) return list(res) 前项和后项相等时跳过class Solution: def threeSum(self, nums): # 从小到大排序 nums.sort() res = [] length = len(nums) # 从左侧开始逐渐选取一个值为定值 for i in range(length): # 避免重复项，如 [-4, -1, -1, 0, 1, 2] 中由于两个 -1 导致的两个 [-1, 0, 1] if i &gt; 0 and nums[i] == nums[i-1]: continue # 减少无关计算，定值大于 0 后，后面的都大于 0，没必要进行计算了 if nums[i] &gt; 0: break # 左指针随着定值的移动而移动 l = i + 1 r = length - 1 # 获取右侧剩余的值中的与前面定值相加为 0 的两个值 while l &lt; r: # 先求和，减少因 if 判断导致的重复计算和增加内存空间 s = nums[i] + nums[l] + nums[r] # 满足条件，添加 if s == 0: res.append([nums[i], nums[l], nums[r]]) # 避免重复项 while (l &lt; r) and (nums[l+1] == nums[l]): l += 1 while (l &lt; r) and (nums[r-1] == nums[r]): r -= 1 # 满足后现指针均需移动，避免重复和无效计算 l += 1 r -= 1 # 小于 0，左指针右移 elif s &lt; 0: l += 1 # 大于 0，右指针左移 else: r -= 1 return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[28-实现strStr]]></title>
    <url>%2F2020%2F01%2F20%2F28-%E5%AE%9E%E7%8E%B0strStr%2F</url>
    <content type="text"><![CDATA[实现 strStr() 函数。给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例示例 1:输入: haystack = &quot;hello&quot;, needle = &quot;ll&quot;输出: 2 示例 2:输入: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 解法暴力匹配 核心思想：双指针ij分别用于对两个字符串的遍历，指针k用于记录遍历到母串的哪一位置 class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: i,j,k=0,0,0 len_needle=len(needle) len_haystack=len(haystack) while i&lt;len_haystack and j&lt;len_needle: if haystack[i]==needle[j]: i,j=i+1,j+1 else: i,j=k+1,0 k+=1 return k if j &gt;= len_needle else - 1 调用字符串的库函数# python一行实现功能class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: return haystack.find(needle) # 或者使用index()class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: try: res = haystack.index(needle) return res except ValueError: return -1 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>双指针</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[27-移除元素]]></title>
    <url>%2F2020%2F01%2F20%2F27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例示例 1:给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。 示例 2:给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意:这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 解法 核心思想：采用双指针，一个用来遍历，一个确定新的表尾位置。 class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: i, j = 0, 0 len_nums = len(nums) # 这句写在判断里会每次都遍历一遍 while j &lt; len_nums: if nums[j] != val: nums[i] = nums[j] i += 1 j += 1 nums = nums[:i] return i 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[26-删除排序数组中的重复项]]></title>
    <url>%2F2020%2F01%2F20%2F26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例示例 1:给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 解法 核心思想：采用双指针，一个记录当前遍历的位置，另一个用来记录无重复的元素个数 # 双指针解法class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: i,j=0,1 while(j&lt;len(nums)): if nums[i]!=nums[j]: nums[i+1]=nums[j] i+=1 j+=1 # nums=nums[:i+1] return i+1 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24-两两交换链表中的结点]]></title>
    <url>%2F2020%2F01%2F20%2F24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 解法非递归 设立新的头结点H的好处是：使得交换前两个结点时的操作和后面的完全一致，不用分开处理。 指针pre和p：分别指向要交换的两个结点，每次向后移动两个结点 指针rear：指向已经排好顺序的部分的尾端，初始指向头结点 结束条件：p指向位置为空 # 非递归解法# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: if head==None or head.next==None: return head # 创建一个不含任何信息的头结点，并添加到原链表的前面 H = ListNode(None) H.next = head rear =H #指向已完成交换部分的尾结点，初始为头结点H pre,p = head,head.next #分别指向要交换的两个结点 while p: # 重新调整结点位置 pre.next = p.next p.next = pre rear.next = p # 更新指针 rear = pre pre = pre.next p = pre.next if pre else None return H.next 递归法# 递归解法class Solution: def swapPairs(self, head: ListNode) -&gt; ListNode: # 结点数为0或1时 if head == None or head.next == None: return head # 每次处理两个结点，head和N N = head.next # head处理后变为后面的结点， # 需要和后面递归的首元素连接起来 head.next = self.swapPairs(N.next) # 原来后面的元素放到前面 N.next = head # 最后返回的是N（后面的变到了前面） return N 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23-合并K个排序链表]]></title>
    <url>%2F2020%2F01%2F19%2F23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[合并 k 个排序链表，返回合并后的排序链表。 示例输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 解法暴力法 核心思想：将所有结点的数据域val加入列表中，在对其排序，生成结点加入新链表 class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: new_List = ListNode(None) p = new_List nodes = [] # 将每个结点的值都加入列表中 for l in lists: while l != None: nodes.append(l.val) l = l.next # 对列表进行排序，依次生成结点加入新链表 for node in sorted(nodes): p.next=ListNode(node) p=p.next return new_List.next 优先级队列 核心思想：利用以数据域为优先级的队列，将每个未访问过得最前面的结点加入队列。这样出队的一定是当前数据域最小的结点，将其加入新链表中，并该节点的后继结点加入队列（如果存在的话）。 # 解法2:利用优先级队列from Queue import PriorityQueueclass Solution2: def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode: head = point = ListNode(0) q = PriorityQueue() for l in lists: if l: # 根据结点的数据域val为优先级加入队列 q.put((l.val, l)) # 每次取出最小的数据域的结点， # 再将取出的结点后继加入队列。 while not q.empty(): val, node = q.get() point.next = ListNode(val) point = point.next node = node.next if node: q.put((node.val, node)) return head.next 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>链表</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22-括号生成]]></title>
    <url>%2F2020%2F01%2F18%2F22-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 示例输入： n = 3输出：[ &quot;((()))&quot;, &quot;(()())&quot;,&quot;(())()&quot;, &quot;()(())&quot;,&quot;()()()&quot;] 解法解法-动态规划 核心思想：分治算法/动态规划 在求N个括号的排列组合时，把第N种情况（也就是N个括号排列组合）视为单独拿一个括号E出来，剩下的N-1个括号分为两部分，P个括号和Q个括号，P+Q=N-1，然后这两部分分别处于括号E内和括号E的右边，各自进行括号的排列组合。 class Solution: def generateParenthesis(self, n: int) -&gt; List[str]: if n == 0: return [''] res = [] for i in range(n): for left in self.generateParenthesis(i): for right in self.generateParenthesis(n - 1 - i): # 先拿出一对括号 # 剩下的括号要么在这一组新增的括号内部， # 要么在这一组新增括号的外部（右侧）。 res.append('(&#123;&#125;)&#123;&#125;'.format(left, right)) return res 解法-回溯算法 核心思想：类似深度优先，第一个结果，会是 ((())) ,最后一个结果是 ()()() 。 # 回溯法class Solution: def generateParenthesis(self, N: int) -&gt; List[str]: ans = [] def backtrack(S = '', left = 0, right = 0): if len(S) == 2 * N: ans.append(S) return if left &lt; N: backtrack(S+'(', left+1, right) if right &lt; left: backtrack(S+')', left, right+1) backtrack() return ans 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21-合并两个有序链表]]></title>
    <url>%2F2020%2F01%2F18%2F21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解法 核心思想：每次将较小的接到新表的尾端 非递归# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Noneclass Solution: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: l3 = ListNode(None) #合并后的新的头结点 # 分别创建三个链表的指针 l1_p, l2_p, l3_p = l1, l2, l3 # 两指针所指不完全为空 while l1_p and l2_p: # 将较小的那个结点接到l3的尾端 if l1_p.val &lt; l2_p.val: l3_p.next=l1_p l1_p= l1_p.next else: l3_p.next=l2_p l2_p=l2_p.next l3_p = l3_p.next # 将剩余的部分复制给l_others，均为空则为None l_others = l1_p if l1_p else l2_p l3_p.next = l_others # 返回除了头指针之外的结点 return l3.next 递归解法# 递归解法class Solution2: def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: # 先考虑递归边界问题 if l1 == None: return l2 elif l2==None: return l1 # 最后会返回l1，l2中较小的为头结点 elif l1.val &lt; l2.val: l1.next = self.mergeTwoLists(l1.next, l2) return l1 elif l1.val&gt;=l2.val: l2.next = self.mergeTwoLists(l1,l2.next) return l2 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20-有效的括号]]></title>
    <url>%2F2020%2F01%2F18%2F20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例示例 1:输入: &quot;()&quot;输出: true 示例 2:输入: &quot;()[]&#123;&#125;&quot;输出: true 示例 3:输入: &quot;(]&quot;输出: false 示例 4:输入: &quot;([)]&quot;输出: false 示例 5:输入: &quot;&#123;[]&#125;&quot;输出: true 解法 核心思想：利用栈的先进后出的特性 class Solution: def isValid(self, s: str) -&gt; bool: dic = &#123;'&#123;': '&#125;', '[': ']', '(': ')'&#125; stack_ = [] for c in s: try: # 异常处理 if c in dic: stack_.append(c) elif dic[stack_.pop()] != c: return False # 空栈进行pop()会返回IndexError except IndexError: return False return len(stack_) == 0 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19-删除链表的倒数第N个结点]]></title>
    <url>%2F2020%2F01%2F17%2F19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9%2F</url>
    <content type="text"><![CDATA[给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 解法 核心思想：采用双指针，使他们相差n个位置，则后面的指针到达最后一个元素时，前面的指针刚好指向要删除元素的前一个元素。 class Solution: def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode: # 设置双指针 pre, p = head,head # 只有一个结点的情况 if head.next==None: return None # p先向后移动n个位置 for i in range(n): p=p.next # 此时p为空，说明要删除的为头结点 if not p: return head.next # 删除位置不为首尾结点，同步向后移动，直到p指向最后一结点 while p.next: p=p.next pre=pre.next # 删除结点 pre.next = pre.next.next # 返回头结点 return head 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18-四数之和]]></title>
    <url>%2F2020%2F01%2F17%2F18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意：答案中不可以包含重复的四元组。 示例给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解法 核心思想：采用双指针，每次固定两个数，剩下两个数字采用双指针遍历 class Solution: def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]: if len(nums) &lt; 4: # 不足四个数 return [] if len(nums) == 4: # 正好四个数 return [nums] if sum(nums) == target else [] nums.sort() # 排序 # 最大的四个数和小于target，最小的四个数和大于target if sum(nums[:4]) &gt; target or sum(nums[-4:]) &lt; target: return [] res = [] for i in range(len(nums)-2): for j in range(i+1, len(nums)-1): low = j+1 # 双指针遍历 high = len(nums)-1 while low &lt; high: sum_four = nums[i]+nums[j]+nums[low]+nums[high] cur_list = [nums[i], nums[j], nums[low], nums[high]] if sum_four == target and cur_list not in res: res.append(cur_list) if sum_four &lt;= target: low += 1 elif sum_four &gt; target: high -= 1 return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17-电话号码的字母组合]]></title>
    <url>%2F2020%2F01%2F16%2F17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例输入：&quot;23&quot;输出：[&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;]. 解法 核心思想：回溯算法（可当成深度优先的算法） class Solution: def letterCombinations(self, digits: str) -&gt; List[str]: # 电话号与九宫格字母相对应 phone_dict = &#123;'2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'], '5': ['j', 'k', 'l'], '6': ['m', 'n', 'o'], '7': ['p', 'q', 'r', 's'], '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z']&#125; # 空字符串 if not digits: return [] res = [] # 回溯函数:实现效果是类似深度优先 def dfs(digits_cut, tmp): # 遍历到最后一个字母，返回上一层 if(digits_cut == ""): res.append(tmp) return for c in phone_dict[digits_cut[0]]: # 递归下一位字母 dfs(digits_cut=digits_cut[1:], tmp=tmp + c) # 调用回溯函数 dfs(digits, "") return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16-最接近的三数之和]]></title>
    <url>%2F2020%2F01%2F15%2F16-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例输入：nums = [-1，2，1，-4], target = 1输出：2解释：与target最接近的三个数的和为2. (-1 + 2 + 1 = 2). 解法 核心思想：采用双指针， 若target-sum&gt;0，说明sum太小，low向高移动若target-sum&lt;0，说明sum太大，high向低移动 class Solution: def threeSumClosest(self, nums: List[int], target: int) -&gt; int: # 只有三个数字，直接相加返回 if len(nums) == 3: return sum(nums) # 对nums进行排序 nums.sort() # 初始差值为最大值 d_value = sys.maxsize for i in range(len(nums)): # low=i+1为去除之前判断过得操作 low, high = i+1, len(nums)-1 while(low &lt; high): x = target - nums[low] - nums[high] - nums[i] # 进行差值 if abs(x) &lt; abs(d_value): d_value = x if x &gt; 0: low += 1 elif x &lt; 0: high -= 1 elif x == 0: return target return target - d_value 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14-最长公共前缀]]></title>
    <url>%2F2020%2F01%2F14%2F14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80%2F</url>
    <content type="text"><![CDATA[编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例示例 1:输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2:输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 解法暴力法-双重循环 核心思想：分别对比每个元素的每个相同位置的字母，不同即返回结果 class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: res = "" if len(strs)==0: return res #i的范围：[0,最短的字符串长度] #j的范围：[0,字符串的数量-1] for i in range(len(min(strs, key=len))): for j in range(len(strs)-1): if strs[j][i] != strs[j+1][i]: return res res += strs[0][i] return res 利用特殊函数-zip和set keypoint： 1.*进行解包； 2.zip打包成列表； 3.set列表去重 class Solution: def longestCommonPrefix(self, strs: List[str]) -&gt; str: res = "" # 使用*解包将每一位的字符分别打包成一个列表 for i in zip(*strs): # 去重后列表只剩一个元素 if len(set(i)) == 1: res += i[0] else: break return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13-罗马数字转整数]]></title>
    <url>%2F2020%2F01%2F13%2F13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 |通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 示例示例 1:输入: &quot;III&quot;输出: 3 示例 2:输入: &quot;IV&quot;输出: 4 示例 3:输入: &quot;IX&quot;输出: 9 示例 4:输入: &quot;LVIII&quot;输出: 58解释: L = 50, V= 5, III = 3. 示例 5:输入: &quot;MCMXCIV&quot;输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 解法 核心思想：查找字典，当前value值小于右侧的value值时减去， 否则加上该值 注意点 ：边界情况的处理 class Solution: def romanToInt(self, s: str) -&gt; int: hash_map = &#123;'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000&#125; res = 0 for i in range(len(s)): # 右侧的value大于当前value,减去当前值 if (i &lt; len(s)-1) and (hash_map[s[i]] &lt; hash_map[s[i+1]]): res -= hash_map[s[i]] # 否则，则加上当前值 else: res += hash_map[s[i]] return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12-整数转罗马数字]]></title>
    <url>%2F2020%2F01%2F12%2F12-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 |通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 示例示例 1:输入: 3输出: &quot;III&quot; 示例 2:输入: 4输出: &quot;IV&quot; 示例 3:输入: 9输出: &quot;IX&quot; 示例 4:输入: 58输出: &quot;LVIII&quot;解释: L = 50, V = 5, III = 3. 示例 5:输入: 1994输出: &quot;MCMXCIV&quot;解释: M = 1000, CM = 900, XC = 90, IV = 4. 解法 核心思想：使用贪心算法 class Solution: def intToRoman(self, num: int) -&gt; str: num_dict = &#123;1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 100: 'C', 400: 'CD', 500: 'D', 900: 'CM', 1000: 'M'&#125; res = "" # 贪心算法，将字典逆置，从大的开始除 for key in sorted(num_dict.keys())[::-1]: if(num == 0): break tmp = num//key if(tmp == 0): continue res += num_dict[key] * (tmp) # 更新num值 num -= key*(tmp) return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>字符串</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11-盛最多水的容器]]></title>
    <url>%2F2020%2F01%2F11%2F11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例输入: [1,8,6,2,5,4,8,3,7]输出: 49 解法 核心思想：只有相对短的一边向内收缩才有可能使得面积变大 class Solution: def maxArea(self, height: List[int]) -&gt; int: left, right, res = 0, len(height)-1, 0 while (left &lt; right): # 判断是否需要更新最大面积 if min(height[left], height[right])*(right-left) &gt; res: res = min(height[left], height[right]) * (right - left) # 使得短的一端向内收缩 if height[left] &lt; height[right]: left += 1 else: right -= 1 return res 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10-正则表达式匹配]]></title>
    <url>%2F2020%2F01%2F10%2F10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。 字符 匹配规则 . 匹配任意单个字符 * 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例示例 1:输入: s = &quot;aa&quot; p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2:输入: s = &quot;aa&quot; p = &quot;a*&quot;输出: true解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。 示例 3:输入: s = &quot;ab&quot; p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。 示例 4:输入: s = &quot;aab&quot; p = &quot;c*a*b&quot;输出: true解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5:输入: s = &quot;mississippi&quot; p = &quot;mis*is*p*.&quot;输出: false 解法class Solution: def isMatch(self, text: str, pattern: str) -&gt; bool: # 递归边界： if not pattern: return not text # text 非空并且p[0]==s[0]或者“.” first = bool(text) and pattern[0] in &#123;text[0], '.'&#125; # 处理带星号的问题 if len(pattern) &gt;= 2 and pattern[1] == '*': return self.isMatch(text, pattern[2:]) or first and self.isMatch(text[1:], pattern) else: # 正常递归 return first and self.isMatch(text[1:], pattern[1:]) 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9-回文数]]></title>
    <url>%2F2020%2F01%2F09%2F9-%E5%9B%9E%E6%96%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例示例 1:输入: 121输出: true 示例 2:输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3:输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 解法直接转换成字符串对比即可。 class Solution: def isPalindrome(self, x: int) -&gt; bool: return True if str(x)==str(x)[::-1] else False 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8-字符串转换整数]]></title>
    <url>%2F2020%2F01%2F08%2F8-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31, 2^31 − 1]。如果数值超过这个范围，请返回 INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。 示例示例 1:输入: &quot;42&quot;输出: 42 示例 2:输入: &quot; -42&quot;输出: -42解释: 第一个非空白字符为 &apos;-&apos;, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3:输入: &quot;4193 with words&quot;输出: 4193解释: 转换截止于数字 &apos;3&apos; ，因为它的下一个字符不为数字。 示例 4:输入: &quot;words and 987&quot;输出: 0解释: 第一个非空字符是 &apos;w&apos;, 但它不是数字或正、负号。因此无法执行有效的转换。 示例 5:输入: &quot;-91283472332&quot;输出: -2147483648解释: 数字 &quot;-91283472332&quot; 超过 32 位有符号整数范围。 因此返回 INT_MIN (−231) 。 解法-常规该题解法很容易想到，只是有很多小细节需要注意。 class Solution: def myAtoi(self, s: str) -&gt; int: str_ = s.strip() # 去掉字符串的空白 if len(str_) == 0: # 空字符串 return 0 nums_ls = [str(i) for i in range(10)] symbols_ls = ["-", "+"] # 判断首个字符 if str_[0]not in nums_ls and str_[0] not in symbols_ls: return 0 else: res = str_[0] # 判断后面的字符 for i in str_[1:]: if i in nums_ls: res += i else: break try: # 只有正负号时，返回0 res = int(res) except: return 0 # if res &gt; 2147483647: # return 2147483647 # elif res &lt; -2147483648: # return -2147483648 # else: # return res # 功能同上面注释部分，不过更加优雅 return min(max(res, -2147483648), 2147483647) 解法-正则利用正则表达式，来提取有效字符串。 正则 含义 ^ 匹配字符串开头 [+-] 代表一个+字符或-字符 ? 前面一个字符可有可无 \d 一个数字 + 前面一个字符的一个或多个 * 前面一个字符的零个或多个 class Solution: def myAtoi(self, s: str) -&gt; int: return max(min(int(*re.findall('^[\+\-]?\d+', s.lstrip())), 2**31 - 1), -2**31) 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7-整数反转]]></title>
    <url>%2F2020%2F01%2F07%2F7-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例示例 1:输入: 123输出: 321 示例 2:输入: -123输出: -321 示例 3:输入: 120输出: 21 注意：假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解法 核心思路：int -&gt; abs(int) -&gt; str[::-1] -&gt; int class Solution: def reverse(self, x: int) -&gt; int: y = abs(x) k = int(str(y)[::-1]) if k &gt; 2147483647: return 0 elif x &gt; 0: return k else: return k*(-1) 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6.Z字形变换]]></title>
    <url>%2F2020%2F01%2F06%2F6-Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下： L C I RE T O E S I I GE D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：&quot;LCIRETOESIIGEDHN&quot;。 示例示例 1:输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 3输出: &quot;LCIRETOESIIGEDHN&quot; 示例 2:输入: s = &quot;LEETCODEISHIRING&quot;, numRows = 4输出: &quot;LDREOEIIECIHNTSG&quot; 解释:L D RE O E I IE C I H NT S G 解法 Key Point：巧妙利用flag实现触碰到边界时进行“回弹”的效果 class Solution: def convert(self, s: str, numRows: int) -&gt; str: if numRows&lt;2: # 该算法在小于2时，直接返回即可 return s # 初始化一个长度为numRows的列表 ls = ["" for _ in range(numRows)] flag, i = -1, 0 for string in s: ls[i] += string # i等于0或者numRows-1时，改变方向 if i % (numRows-1) == 0: flag = -flag i += flag return "".join(ls) 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.最长回文子串]]></title>
    <url>%2F2020%2F01%2F05%2F5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例示例 1：输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2：输入: &quot;cbbd&quot;输出: &quot;bb&quot; 解法1-中心扩展我们知道回文串一定是对称的，所以我们可以每次循环选择一个中心，进行左右扩展，判断左右字符是否相等即可。 由于存在奇数的字符串和偶数的字符串，所以我们需要从一个字符开始扩展，或者从两个字符之间开始扩展，所以总共有 n+n-1 个中心。 时间复杂度：O(n²） 空间复杂度：O(1） 代码class Solution: # 中心扩展 def expandAroundCenter(self,s: str,left:int,right:int) -&gt; str: L, R = left, right while L&gt;= 0 and R&lt; len(s) and s[L]==s[R]: L -= 1 R += 1 return s[L+1:R] # 求最长回文子串 def longestPalindrome(self, s: str) -&gt; str: if len(s) &lt;= 1: # 长度小于等于1直接返回原字符串 return s res = s[:1] # 初始化result为字符串首位 for i in range(len(s)): len1 = self.expandAroundCenter(s, i, i) len2 = self.expandAroundCenter(s, i, i + 1) # 迭代res使其成为最长的子串 res = max(len1,len2,res,key=len) return res 2-马拉车算法（Manacher’s Algorithm）Manacher‘s Algorithm是用来查找一个字符串的最长回文子串的线性方法，由一个叫 Manacher 的人在 1975 年发明的，这个方法的最大贡献是在于将时间复杂度提升到了线性。 首先我们解决下奇数和偶数的问题，在每个字符间插入 “#”，并且为了使得扩展的过程中，到边界后自动结束，在两端分别插入 “^” 和 “$”，两个不可能在字符串中出现的字符，这样中心扩展的时候，判断两端字符是否相等的时候，如果到了边界就一定会不相等，从而出了循环。经过处理，字符串的长度永远都是奇数了。 首先我们用一个数组 P 保存从中心扩展的最大个数，而它刚好也是去掉 “#” 的原字符串的总长度。例如下图中下标是 6 的地方，可以看到 P[ 6 ] 等于 5，所以它是从左边扩展 5 个字符，相应的右边也是扩展 5 个字符，也就是 “#c#b#c#b#c#”。而去掉 # 恢复到原来的字符串，变成 “cbcbc”，它的长度刚好也就是 5。 求原字符串下标用 P 的下标 i 减去 P [ i ]，再除以 2，就是原字符串的开头下标了。 例如我们找到 P[ i ] 的最大值为 5，也就是回文串的最大长度是 5，对应的下标是 6，所以原字符串的开头下标是（6 - 5 ）/ 2 = 0。所以我们只需要返回原字符串的第 0 到 第（5 - 1）位就可以了。 求每个 P [ i ]接下来是算法的关键了，它充分利用了回文串的对称性。 我们用 C 表示回文串的中心，用 R 表示回文串的右边半径。所以 R = C + P[ i ]。C 和 R 所对应的回文串是当前循环中 R 最靠右的回文串。 让我们考虑求 P [ i ] 的时候，如下图。 用 i_mirror 表示当前需要求的第 i 个字符关于 C 对应的下标。 我们现在要求 P [ i ]，如果是用中心扩展法，那就向两边扩展比对就行了。但是我们其实可以利用回文串 C 的对称性。i 关于 C 的对称点是 i_mirror，P [ i_mirror ] = 3，所以 P [ i ] 也等于 3。 但是有三种情况将会造成直接赋值为 P [ i_mirror ] 是不正确的，下边一一讨论。 超出了 R 当我们要求 P [ i ] 的时候，P [ mirror ] = 7，而此时 P [ i ] 并不等于 7，为什么呢，因为我们从 i 开始往后数 7 个，等于 22，已经超过了最右的 R，此时不能利用对称性了，但我们一定可以扩展到 R 的，所以 P [ i ] 至少等于 R - i = 20 - 15 = 5，会不会更大呢，我们只需要比较 T [ R+1 ] 和 T [ R+1 ]关于 i 的对称点就行了，就像中心扩展法一样一个个扩展。 P [ i_mirror ] 遇到了原字符串的左边界 此时P [ i_mirror ] = 1，但是 P [ i ] 赋值成 1 是不正确的，出现这种情况的原因是 P [ i_mirror ] 在扩展的时候首先是 “#” == “#”，之后遇到了 “^” 和另一个字符比较，也就是到了边界，才终止循环的。而 P [ i ] 并没有遇到边界，所以我们可以继续通过中心扩展法一步一步向两边扩展就行了。 i 等于了 R此时我们先把 P [ i ] 赋值为 0，然后通过中心扩展法一步一步扩展就行了。 考虑 C 和 R 的更新就这样一步一步的求出每个 P [ i ]，当求出的 P [ i ] 的右边界大于当前的 R 时，我们就需要更新 C 和 R 为当前的回文串了。因为我们必须保证 i 在 R 里面，所以一旦有更右边的 R 就要更新 R。 此时的 P [ i ] 求出来将会是 3，P [ i ] 对应的右边界将是 10 + 3 = 13，所以大于当前的 R，我们需要把 C 更新成 i 的值，也就是 10，R 更新成 13。继续下边的循环。 作者：windliang|链接地址 代码class Solution: # 马拉车算法 def longestPalindrome(self, s: str) -&gt; str: if len(s) &lt; 2: return s # 将一个可能是偶数长/奇数长的字符串，首位以及每个字符间添加# test = '#'+'#'.join(s)+'#' # 当前遍历的中心最大扩散步数，其值等于原始字符串的最长回文子串的长度 max_len = 0 for i in range(len(test)): left = i - 1 right = i + 1 step = 0 while left &gt;= 0 and right &lt; len(test) and test[left] == test[right]: left -= 1 right += 1 step += 1 # 找到合适的起点位置 if step &gt; max_len: max_len = step start = (i - max_len) // 2 return s[start: start + max_len] 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>中心扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4.寻找两个有序数组的中位数]]></title>
    <url>%2F2020%2F01%2F04%2F4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。 示例示例 1:nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2:nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 解法核心方法分别在num1和num2切割，找到满足Lmax1&lt;Rmin2且Lmax2&lt;Rmin的位置。 奇偶问题两个数组合并后的长度，有可能是偶数，也有可能是奇数。如果可以让数组长度总是为偶数，那么就可以用公式覆盖。 通过虚拟加入&quot;#&quot;，让每个数组的长度都变成 2x + 1，所以 n+m -&gt; 2n + 2m + 2，恒为偶数。 转换后，原始的元素可以通过新下标//2得到。 比如9，原来是3位，现在是7位， 7//2=3 而对于割，如果‘#’上等于割在2个元素之间，割在数字上等于把数字划到2个部分，总是有以下成立： LMaxi = (Ci-1)/2 位置上的元素RMini = Ci/2 位置上的元素 点击查看详细 代码class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float: m = len(nums1) n = len(nums2) # 使得num2成为更长的表 if n &lt; m: return self.findMedianSortedArrays(nums2, nums1) start_pos = 0 end_pos = 2 * m while start_pos &lt;= end_pos: c1 = (start_pos + end_pos) // 2 c2 = m + n - c1 # 因为数组从0开始，所以c1+c2=(m+n+1)-1 # 切割nums1 LMax1 = nums1[(c1 - 1) // 2] if c1 &gt; 0 else (-1 * sys.maxsize) RMin1 = nums1[c1 // 2] if c1 &lt; 2 * n else sys.maxsize # 切割nums2 LMax2 = nums2[(c2 - 1) // 2] if c2 &gt; 0 else (-1 * sys.maxsize) RMin2 = nums2[c2 // 2] if c2 &lt; 2 * m else sys.maxsize # 不满足LMax&lt;RMin 则进行调整切割位置 if LMax1 &gt; RMin2: end_pos = c1 - 1 elif LMax2 &gt; RMin1: start_pos = c1 + 1 else: # 找到合适的c1 break # 返回中位数 return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.无重复字符的最长子串]]></title>
    <url>%2F2020%2F01%2F03%2F3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。 示例示例 1:输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2:输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3:输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 解法这道题主要用到思路是：滑动窗口 什么是滑动窗口？ 其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列！ 如何移动？ 我们只要找到那个相同元素的位置，把队列中它左边的元素移出就行了，直到满足题目要求！ 一直维持这样的队列，找出队列出现最长的长度时候，求出解！ class Solution: def lengthOfLongestSubstring(self, s: str) -&gt; int: if not s:return 0 # 如果字符串s为空，返回0 lookup = [] # 初始化窗口 max_len = 0 # 窗口长度 cur_len = 0 # 当前子串长度 for i in range(len(s)): # 遍历字符串s val = s[i] if not val in lookup: # 如果该值不在窗口中 lookup.append(val) # 添加到窗口内 cur_len += 1 # 当前长度+1 else:# 如果该值在窗口中已存在 index = lookup.index(val) # 获取其在窗口中的位置 lookup = lookup[index+1:] # 移除该位置及之前的字符 lookup.append(val) cur_len = len(lookup) # 当前长度更新为窗口长度 if cur_len &gt; max_len: # 看是否需要更新最大长度值 max_len = cur_len return max_len # 返回最大子串长度 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.两数相加]]></title>
    <url>%2F2020%2F01%2F03%2F2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 解法1将链表转换成字符串，方便进行逆置操作；最后再讲字符串转换成链表。 # Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: def ln2str(ln: ListNode):#链表转换为字符串 if ln.next == None: return str(ln.val) else: return str(ln.val) + str(ln2str(ln.next)) def str2ln(str_res: str):#字符串转换成链表 if len(str_res)==1: return ListNode(int(str_res)) else: ln_temp = ListNode(int(str_res[0])) ln_temp.next = str2ln(str_res[1:]) return ln_temp str1 = ln2str(l1)[::-1] #将链表1转换为字符串并逆置 str2 = ln2str(l2)[::-1] #将链表2转换为字符串并逆置 str_res = str(int(str1)+int(str2))[::-1] #相加后转换为字符串，逆置 return str2ln(str_res) #返回转换成的链表 解法2把两个数按位相加，并存到一个新的链表中，使用carry保存是否需要进位。 # 官方解法class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: dummyHead = ListNode(0) # 建立一个头结点 curr, carry = dummyHead, 0 #curr表当前结点；carry表进位 while l1 or l2: # 不全为空 sum = 0 if l1: # l1非空 sum += l1.val l1 = l1.next if l2: # l2非空 sum += l2.val l2 = l2.next sum += carry carry = sum // 10 curr.next = ListNode(sum % 10) curr = curr.next if carry &gt; 0: # 需要进位，使得链表加长 curr.next = ListNode(1) return dummyHead.next; #返回除头结点之后链表 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数学</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.两数之和]]></title>
    <url>%2F2020%2F01%2F02%2F1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%2F</url>
    <content type="text"><![CDATA[给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解法通过哈希来求解，这里通过字典来模拟哈希查询的过程。 class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: hashmap=&#123;&#125; for i,num in enumerate(nums): if hashmap.get(target - num) is not None: # 当前字典中找到对应key return [i,hashmap.get(target - num)] hashmap[num] = i # 未找到则将其加入字典中 来源LeetCode中该题地址，Click here!]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Algorithms</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-树]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[基于C/C++二叉树的构建与操作。 二叉树-递归实现 树的结点typedef int BT_ElemType;//树的结点结构typedef struct BTNode&#123; BT_ElemType data; BTNode *L_child, *R_child;//左右孩子结点的指针&#125; BTNode; 树的创建BTNode *BiTree_Create()&#123; BT_ElemType data; scanf("%d", &amp;data);//手动输入树的结点值 BTNode *T; if (data == 0) //当遇到0时，令树的根节点为NULL，从而结束该分支的递归 &#123; T = NULL;//空分支 return T; &#125; else &#123; T = (BTNode *)malloc(sizeof(BTNode));//创建新的树节点 //先序创建树 T-&gt;data = data;//先给根节点赋值 T-&gt;L_child = BiTree_Create();//创建左子树 T-&gt;R_child = BiTree_Create();//创建右子树 &#125; return T;&#125; 访问结点数据//访问节点数据void BiTree_Vist_Node(BTNode *T)&#123; printf("%d ", T-&gt;data);&#125; 前序遍历//前序遍历void BiTree_Preorder_Traversal(BTNode *T)&#123; if (T) &#123; BiTree_Vist_Node(T); BiTree_Preorder_Traversal(T-&gt;L_child); BiTree_Preorder_Traversal(T-&gt;R_child); &#125;&#125; 中序遍历//中序遍历void BiTree_Inorder_Traversal(BTNode *T)&#123; if (T) &#123; BiTree_Inorder_Traversal(T-&gt;L_child); BiTree_Vist_Node(T); BiTree_Inorder_Traversal(T-&gt;R_child); &#125;&#125; 后序遍历//后序遍历void BiTree_Postorder_Traversal(BTNode *T)&#123; if (T) &#123; BiTree_Postorder_Traversal(T-&gt;L_child); BiTree_Postorder_Traversal(T-&gt;R_child); BiTree_Vist_Node(T); &#125;&#125; 双序遍历//二叉树的双序遍历void BiTree_DblOrder_Traverse(BTNode *T)&#123; if(T) &#123; BiTree_Vist_Node(T); BiTree_DblOrder_Traverse(T-&gt;L_child); BiTree_Vist_Node(T); BiTree_DblOrder_Traverse(T-&gt;R_child); &#125;&#125; 树的复制//二叉树的复制void BiTree_Copy(BTNode *T, BTNode *NewT)&#123; if (T == NULL) &#123; NewT = NULL; &#125; else &#123; NewT = (BTNode *)malloc(sizeof(BTNode)); NewT-&gt;data = T-&gt;data; BiTree_Copy(T-&gt;L_child, NewT-&gt;L_child); BiTree_Copy(T-&gt;R_child, NewT-&gt;R_child); &#125;&#125; 树的深度//树的深度int BiTree_Depth(BTNode *T)&#123; if (T == NULL) return 0; else &#123; int m = BiTree_Depth(T-&gt;L_child); int n = BiTree_Depth(T-&gt;R_child); if (m &gt; n) return (m + 1); else return (n + 1); &#125;&#125; 结点个数//统计二叉树中结点的个数int BiTree_Node_Count(BTNode *T)&#123; if (T == NULL) return 0; else return BiTree_Node_Count(T-&gt;L_child) + BiTree_Node_Count(T-&gt;R_child) + 1;&#125; ···### 二叉树-非递归实现 结点结构//树的结点结构typedef struct BTNode&#123; BT_ElemType data; BTNode *L_child, *R_child; int visitCount;//用于非递归的后序遍历&#125; BTNode; 先序遍历//先序遍历-使用栈(Stack)void Preorder_Traversal(BTNode *T)&#123; stack &lt;BTNode *&gt; TreeStack;//声明一个树的栈名为TreeStack BTNode *p = T; //辅助结点指针 while (p || !TreeStack.empty())//p不指向NULL或者栈内非空 &#123; if (p)//p不指向NULL &#123; printf("%d ", p-&gt;data);//访问结点值 TreeStack.push(p);//将p压入栈中,后进先出 p = p-&gt;L_child;//p指向他的左孩子 &#125; else//p指向NULL &#123; p = TreeStack.top();//取得栈顶指针 TreeStack.pop();//开始出栈,即访问左节点为空 p = p-&gt;R_child;//开始访问出战的左节点为空的父节点的右结点 &#125; &#125;&#125; 中序遍历// 中序遍历 void Inorder_Traverse(BTNode* T) &#123; stack &lt;BTNode*&gt; TreeStack; BTNode* p = T; while (p || !TreeStack.empty())//p不指向NULL或者栈非空 &#123; if (p)//p不指向NULL &#123; TreeStack.push(p);//压进栈内 p = p-&gt;L_child;//访问他的左孩子 &#125; else//p指向NULL &#123; p = TreeStack.top();//取得栈顶指针 printf("%d ", p-&gt;data);//访问根节点 TreeStack.pop();//根结点的左孩子开始出栈 p = p-&gt;R_child;//访问目前根节点的右孩子 &#125; &#125;&#125; 后序遍历// 后序遍历void Postorder_Traversal(BTNode *T)&#123; stack&lt;BTNode *&gt; TreeStack; BTNode *p = T; while (p || !TreeStack.empty()) &#123; if (p) //不指向NULL &#123; p-&gt;visitCount = 1; //访问根节点一次 TreeStack.push(p); //压入栈中 p = p-&gt;L_child; //访问左结点 &#125; else //指向NULL &#123; p = TreeStack.top(); if (p-&gt;visitCount == 2) &#123; TreeStack.pop(); //出栈 printf("%d ", p-&gt;data); //读出栈顶的值 p = NULL;//指向空 &#125; else //只有访问过一次 &#123; p-&gt;visitCount++; //访问次数+1 p = p-&gt;R_child; //访问右孩子 &#125; &#125; &#125;&#125; 层序遍历// 层序遍历void Levelorder_Traversal(BTNode *T)&#123; if (!T) &#123; return; &#125; queue&lt;BTNode *&gt; TreeQueue; //调用队列 TreeQueue.push(T);//树的根节点入队 BTNode *p = T; while (!TreeQueue.empty())//队列非空 &#123; p = TreeQueue.front();//指向队头 TreeQueue.pop();//出队 printf("%d ", p-&gt;data);//取值 if (p-&gt;L_child)//存在左结点,入队 &#123; TreeQueue.push(p-&gt;L_child); &#125; if (p-&gt;R_child)//存在右结点,入队 &#123; TreeQueue.push(p-&gt;R_child); &#125; &#125;&#125; ···### 调用栈与队列 使用命名空间using namespace std; //使用命名空间调用队列堆栈 引入头文件#include &lt;queue&gt;#include &lt;stack&gt; 调用stack&lt;BTNode *&gt; TreeStack; //声明一个元素为树结点指针的栈，名为TreeStack 基本操作xx.empty() //为空则返回真xx.pop() //删除元素xx.push() //增加元素 ···### 测试源码 递归/非递归实现源码，请点击这里获取 随时补充]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-队]]></title>
    <url>%2F2018%2F09%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%2F</url>
    <content type="text"><![CDATA[基于C/C++顺序队列和链式队列的构建与操作。 顺序队列 队的结构#define MaxSize 10typedef int ElemType;//顺序队列结构typedef struct SeqQueue&#123; ElemType data[MaxSize]; int front, rear; // 队列头和队列尾&#125;SeqQueue; 队的操作初始化空队//初始化空队列SeqQueue *SeqQueue_Init()&#123; SeqQueue *Q = (SeqQueue *)malloc(sizeof(SeqQueue));//分配内存 Q-&gt;rear = Q-&gt;front = 0;//初始化对手与队尾 return Q;&#125; 是否空队//是否空队bool SeqQueue_Is_Empty(SeqQueue *Q)&#123; if (Q-&gt;front == Q-&gt;rear)//队首与队尾相同时为空队 return true; return false;&#125; 入队bool SeqQueue_Push(SeqQueue *Q, ElemType x)&#123; if ((Q-&gt;rear + 1) % MaxSize == Q-&gt;front) //判断是否队满 &#123; printf("The Queue has been full.\n"); return false; &#125; Q-&gt;data[Q-&gt;rear] = x; printf("Elem %d has been in the Queue.\n", Q-&gt;data[Q-&gt;rear]); Q-&gt;rear = (Q-&gt;rear + 1) % MaxSize; return true;&#125; 出队//出队bool SeqQueue_Pop(SeqQueue *Q)&#123; if (SeqQueue_Is_Empty(Q)) //如果空队 return false; printf("Elem %d has been out of the Queue.\n", Q-&gt;data[Q-&gt;front]); Q-&gt;data[Q-&gt;front] = NULL; //清空队首元素，队首上移 Q-&gt;front = (Q-&gt;front + 1) % MaxSize; //循环队列操作 return true;&#125; 遍历打印//循环打印void SeqQueue_Print(SeqQueue *Q)&#123; for (int i = Q-&gt;front; (i + 1) % MaxSize != Q-&gt;rear; i++)//取余判断是否循环一遍 &#123; printf("%d ", Q-&gt;data[i]); &#125; printf("\n");&#125; ···### 链式队列 链式队列结构typedef int ElemType;//结点结构typedef struct QNode&#123; ElemType data;//数据域 QNode *next;//指针域&#125; QNode;//链式队列结构typedef struct LinkedQueue&#123; QNode *front, *rear; // 队列头和队列尾&#125;LinkedQueue; 链式队列操作空队初始化//初始化空队列LinkedQueue* LinkedQueue_Init()&#123; LinkedQueue *Q = (LinkedQueue*)malloc(sizeof(LinkedQueue)); Q-&gt;front = Q-&gt;rear = (QNode *)malloc(sizeof(QNode));//分配空间给两个指针域结点 Q-&gt;rear-&gt;next = Q-&gt;front-&gt;next = NULL; //初始de后继指针均指向NULL return Q;&#125; 入队//入队bool LinkedQueue_Push(LinkedQueue *Q, ElemType x)&#123; //链式队列不用考虑满队 QNode *r = (QNode*)malloc(sizeof(QNode));//新结点 r-&gt;data = x; //插入元素 r-&gt;next = NULL; //后继结点为空 Q-&gt;rear-&gt;next = r; //Q的原队尾结点指向s Q-&gt;rear = r; //更新队尾指针 printf("Elem %d has been in the Queue.\n", x); return true;&#125; 出队//出队,需要注意头节点的问题bool LinkedQueue_Pop(LinkedQueue *Q)&#123; if (LinkedQueue_Is_Empty(Q)) //如果空队 return false; QNode *s=Q-&gt;front-&gt;next;//辅助结点,指向头结点的下一个 printf("Elem %d has been out of the Queue.\n",s-&gt;data);//跳过头节点 Q-&gt;front-&gt;next = s-&gt;next; // Q-&gt;front = Q-&gt;front-&gt;next; //队首后移动 free(s);//释放原来的头结点后继 return true;&#125; 是否非空//是否空队bool LinkedQueue_Is_Empty(LinkedQueue *Q)&#123; if (Q-&gt;front==Q-&gt;rear) return true; return false;&#125; 遍历打印//循环打印void LinkedQueue_Print(LinkedQueue *Q)&#123; while(Q-&gt;front-&gt;next) &#123; printf("%d ", Q-&gt;front-&gt;next-&gt;data); Q-&gt;front = Q-&gt;front-&gt;next; &#125; printf("\n");&#125; ···### 测试源码 顺序队列源码，请点击这里获取链式队列源码，请点击这里获取 随时补充]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-栈]]></title>
    <url>%2F2018%2F08%2F31%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%2F</url>
    <content type="text"><![CDATA[基于C/C++顺序栈和链栈的构建与操作。 顺序栈 栈的结构#define MaxSize 50typedef int ElemType;//顺序栈结构typedef struct&#123; ElemType data[MaxSize]; int top; //栈的栈顶&#125; SeqStack; 栈的操作进栈//进栈bool SeqStack_Push(SeqStack *S, ElemType x)&#123; if (S-&gt;top &gt;= MaxSize - 1)//若栈满，拒绝入栈 return false; S-&gt;data[++S-&gt;top] = x; //先移动指针。再赋值 return true;&#125; 出栈//出栈,返回出栈元素值bool SeqStack_Pop(SeqStack *S)&#123; if (S-&gt;top == -1) //若空栈，返回 return false; ElemType x = S-&gt;data[S-&gt;top--];//取得出栈元素后，top指针下移 S-&gt;data[S-&gt;top + 1] = NULL;//将要删除的元素删除 printf("ELm %d has been out\n", x); return true;&#125; 自动建栈//自动建栈SeqStack *Create_SeqStack()&#123; SeqStack *S; //定义栈 S = (SeqStack *)malloc(sizeof(SeqStack)); S-&gt;top = -1; //初始化栈顶指针 for (int i = 0; i &lt; 10; i++) &#123; SeqStack_Push(S, i); &#125; return S;&#125; 遍历打印// 从栈顶遍历顺序栈元素void Print_SeqStack_FromTop(SeqStack *S)&#123; if (S-&gt;top == -1) printf("NULL"); for (int x = S-&gt;top; x &gt; -1; x--) &#123; printf("%d ", S-&gt;data[x]); &#125; printf("\n");&#125; ···### 链栈 栈的结构typedef int ElemType;// 链式栈的结点typedef struct SNode&#123; ElemType data; struct SNode *next;&#125; SNode;//链式栈的结构typedef struct LinkedStack&#123; SNode *top; //栈顶指针 int count; //链式栈的结点数&#125; LinkedStack; 栈的操作进栈// 进栈bool LinkedStack_Push(LinkedStack *S, ElemType x)&#123; SNode *p = (SNode*)malloc(sizeof(SNode));//申请新结点内存 p-&gt;data = x;//赋值 p-&gt;next = S-&gt;top;//p得后继指针指向原来的栈顶 S-&gt;top = p;//将栈顶指针移动到新结点 S-&gt;count++;//增加结点数 return true;&#125; 出栈// 出栈bool LinkedStack_Pop(LinkedStack *S)&#123; if (!S-&gt;top)//判定是否为空 return false; ElemType x = S-&gt;top-&gt;data;//得到出栈元素 SNode *p = S-&gt;top;//辅助指针指向栈顶 S-&gt;top = S-&gt;top-&gt;next;//移动栈顶指针到原栈顶指针的后继 free(p);//释放掉原栈顶 S-&gt;count--;//结点数-1 printf("Elem %d has been out of stack\n",x); return true;&#125; 自动建栈//自动建栈LinkedStack *Create_LinkedStack()&#123; LinkedStack *S; S = (LinkedStack*)malloc(sizeof(SNode));//申请内存 S-&gt;count = 0;//初始化结点数 S-&gt;top = NULL;//初始化栈顶指针 for (int x = 0; x &lt; 10; x++) &#123; LinkedStack_Push(S, x);//进栈操作 &#125; return S;&#125; 遍历打印//遍历打印void Print_LinkedStack_FromTop(LinkedStack *S)&#123; SNode *p = S-&gt;top; while (p)//当栈顶指针不为空 &#123; printf("%d ", p-&gt;data); p = p-&gt;next; &#125; printf("\n");&#125; ···### 测试源码 链式栈源码，请点击这里获取顺序栈源码，请点击这里获取 随时补充]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构-表]]></title>
    <url>%2F2018%2F08%2F29%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[基于C/C++顺序表和链表的构建与操作。 顺序表 静态表结构//静态顺序表结构typedef struct SeqList_Static&#123; ElemType data[MaxSize]; int length;&#125;SeqList_Static; 静态表操作初始化//顺序表初始化SeqList_Static *SeqList_Static_Init()&#123; // 一次性开辟存储空间 SeqList_Static *L = (SeqList_Static *)malloc(sizeof(SeqList_Static)); L-&gt;data[0] = NULL;//初始化为空，长度为0 L-&gt;length = 0; //初始化时，顺序插入0-9 for (int i = 0; i &lt; 10; i++) &#123; L-&gt;data[i] = i; L-&gt;length++; &#125; return L;&#125; 顺序打印//静态链表的打印void SeqList_Static_Print(SeqList_Static *L)&#123; for (int i = 0; i &lt; L-&gt;length; i++) &#123; printf("%d ", L-&gt;data[i]); &#125;&#125; 元素插入// 静态链表——插入元素bool SeqList_Static_Insert(SeqList_Static *L, int i, ElemType x)&#123; //判断插入位置的合法性 if (i &gt; L-&gt;length or i &lt;= 0) return false; // 要插入位置的后面结点循环右移一位 for (int j = L-&gt;length; j &gt;= i; j--) &#123; L-&gt;data[j] = L-&gt;data[j - 1]; &#125; L-&gt;data[i-1] = x;//插入元素 L-&gt;length++; printf("\n插入之后的链表为:\n"); SeqList_Static_Print(L); return true;&#125; 元素删除// 静态链表——删除元素bool SeqList_Static_Delete(SeqList_Static *L, int i)&#123; //判断要删除位置的合法性 if (i &gt; L-&gt;length or i &lt;= 0) return false; // 要删除位置的后面结点循环左移一位 for (; i &lt; L-&gt;length; i++) &#123; L-&gt;data[i-1] = L-&gt;data[i]; &#125; L-&gt;length--; printf("\n删除之后的链表为:\n"); SeqList_Static_Print(L); return true;&#125; 动态表结构#define MaxSize 100 //静态链表的最大长度#define InitSize 10 //预定义顺序表初始长度#define ListIncrement 10 //预定义顺序表扩充增量typedef int ElemType; //元素类型//动态顺序表结构typedef struct SeqList&#123; ElemType *data; int length,capacity;//长度，动态的最大容量&#125; SeqList; 动态表操作初始化// 动态表初始化SeqList *SeqList_Init()&#123; SeqList *L = (SeqList *)malloc(sizeof(SeqList)); L-&gt;data = (ElemType *)malloc(sizeof(ElemType) * InitSize);//不加会出错 不懂为什么 L-&gt;length = 0; L-&gt;capacity = InitSize; //动态的空间最大量 L-&gt;data[0] = NULL; //初始化时，顺序插入0-9 for (int i = 0; i &lt; 10; i++) &#123; L-&gt;data[i] = i; L-&gt;length++; &#125; return L;&#125; 查找元素//按值查找int SeqList_Locate(SeqList L,ElemType e)&#123; for(int i=1;i&lt;=L.length;i++) if(L.data[i-1]==e)return i; //返回第i个元素(下标为i-1值为e)的位号i return 0; //返回0表明查找失败&#125; 插入元素//插入元素bool ListInsert_Seq(SeqList *L, int i, ElemType e)&#123; if (i &lt; 1 || i &gt; L-&gt;length + 1) return false; //i的位置不合法 if (L-&gt;length &gt;= L-&gt;capacity) &#123; //当前长度已达到最大容量，扩充分配存储空间 ElemType *newbase = (ElemType *)realloc(L-&gt;data, sizeof(ElemType) * (InitSize + ListIncrement)); //顺序表扩充 if (!newbase) return false; //存储分配失败 L-&gt;data = newbase; //新基址 L-&gt;capacity += ListIncrement; //增加存储容量 &#125; for (int j = L-&gt;length; j &gt;= i; j--) //第i个元素以及其后的元素右移1个位置 L-&gt;data[j] = L-&gt;data[j - 1]; L-&gt;data[i - 1] = e; //腾出一个空位置插入新元素 L-&gt;length++; //表当前长度+1 return true;&#125; 删除元素//删除操作bool ListDelete_Seq(SeqList &amp;L,int i,ElemType&amp; e)&#123;//删除第i个位置（1&lt;=i&lt;=L.length）元素 if(i&lt;1||i&gt;L.length)return false; //i的位置不合法 e=L.data[i-1]; //将被删除的元素用引用变量e返回 for(int j=i;j&lt;L.length;j++) //第i个位置之后元素前移 L.data[j-1]=L.data[j]; L.length--; //表长度-1 return true;&#125; ···### 单链表 结点结构//结点元素typedef int ElemType;// 创建单链表结点结构typedef struct LNode&#123; ElemType data;//数据域 struct LNode *next;//指针域，用于指向下一个结点&#125; LNode, *LinkedList; 单链表创建头插法以顺序插入0-9为例创建带有头结点的单链表： //头插法创建单链表LinkedList Create_LinkedList_H()&#123; LNode *L;//创建头结点 L = (LNode*)malloc(sizeof(LNode));//开辟头结点存储空间 L-&gt;next = NULL;//默认将头结点指向空 LNode *s; //创建辅助结点 for (int x = 0; x &lt; 10; x++)//0-9循环入队 &#123; s = (LNode *)malloc(sizeof(LNode));//开辟新的结点空间 s-&gt;data = x; //1.为新的结点赋值 s-&gt;next = L-&gt;next; //2.将新结点的后继指针指向头节点原来的后继，即插入到头结点后面 L-&gt;next = s; //3.最后修改头结点的后继指针指向新节点 &#125; return L;//返回生成的链表&#125; 尾插法// 尾插法创建单链表LinkedList Create_LinkedList_R()&#123; LNode *L;//创建头结点 L = (LNode*)malloc(sizeof(LNode));//开辟结点空间 LNode *s; //辅助节点指针 LNode *r = L; //相当于尾指针，当前初始指向头结点 for (ElemType x = 0; x &lt; 10; x++) &#123; s = (LNode *)malloc(sizeof(LNode));//开辟新节点空间 s-&gt;data = x; //将新结点赋值 r-&gt;next = s; //将新结点接到当前尾指针的后端 r = s; //将尾指针移到最后的结点 &#125; s-&gt;next = NULL;//将最后得结点后继指针指向空 return L;//返回新的结点&#125; 单链表操作遍历打印// 遍历打印带头结点的单链表void Print_LinkedList(LNode *L)&#123; LNode *p = L-&gt;next;//跳过头结点 for (; p; p = p-&gt;next)//循环遍历链表 &#123; printf("%d ", p-&gt;data); &#125;&#125; 查找元素//按照序号查找元素LinkedList GetElem_By_Number(LinkedList L, int i)&#123; if (i == 1) //查找第一个元素，则直接返回头结点的后继结点 return L-&gt;next; if (i &lt; = 0)//非法查找 return NULL; int j = 1; LNode *p = L-&gt;next;//跳过头结点 while (p &amp;&amp; j &lt; i)//当p非空且未到循环次数 &#123; j++; p = p-&gt;next;//跳到下一个结点 &#125; return p;//返回p的指针位置&#125; // 按照值来查找元素LinkedList GetElem_By_Value(LinkedList L, ElemType x)&#123; if (L == NULL || x == NULL)//其一为空 return NULL; LNode *p = L-&gt;next;//跳过头结点 while (p-&gt;data != x) &#123; p = p-&gt;next; &#125; return p;//返回指针&#125; 插入结点// 在第i个结点处插入新结点LinkedList Insert_LinkedList(LinkedList &amp;L, int i, ElemType x)&#123; LNode *p = GetElem_By_Number(L, i - 1);//得到要插入元素的前一个结点 LNode *s = (LNode *)malloc(sizeof(LNode));//开辟存储空间 s-&gt;data = x;//赋值 s-&gt;next = p-&gt;next;//将新节点的后继指向要插入位置的后一个结点 p-&gt;next = s;//将要插入位置的前一个元素的后继指向新节点 return L;//返回新链表&#125; 删除结点// 删除第i个结点LinkedList Delete_LinkedList(LinkedList &amp;L, int i)&#123; LNode *p = GetElem_By_Number(L, i - 1);//p指向删除元素的前一个结点 LNode *q = p-&gt;next; //q指向要删除的结点 p-&gt;next = q-&gt;next; //前一个直接跳过要删除元素指向要删除元素的后继 free(q); //释放掉q的空间 return L;&#125; ···### 双链表 结点结构//定义双链表结点结构typedef struct DLNode&#123; ElemType data; struct DLNode *prior, *next;//双指针&#125;DLNode; 双链表操作头插法创建单链表//头插法建立双链表DLNode *Create_Double_LinkedList_H()&#123; DLNode *L; //头结点L L = (DLNode *)malloc(sizeof(DLNode)); //为头结点分配内存 L-&gt;next = L; //初始化指针 L-&gt;prior = L; L-&gt;data = NULL; DLNode *s; //新结点 for (int i = 0; i &lt; 10; i++) &#123; s = (DLNode *)malloc(sizeof(DLNode)); s-&gt;data = i; L-&gt;next-&gt;prior = s; s-&gt;prior = L; s-&gt;next = L-&gt;next; L-&gt;next = s; &#125; return L;&#125; 尾插法创建双链表//尾插法建立双链表DLNode *Create_Double_LinkedList_R()&#123; DLNode *L = (DLNode *)malloc(sizeof(DLNode)); L-&gt;prior = L-&gt;next = L; DLNode *s; for (int i = 0; i &lt; 10; i++) &#123; DLNode *r = L-&gt;prior; //定义为尾指针 s = (DLNode *)malloc(sizeof(DLNode)); s-&gt;data = i;//赋值 r-&gt;next = s;//原尾指针后继指向新结点 s-&gt;prior = r;//新结点前驱指向原尾结点 s-&gt;next = L;//新结点的后继为头结点 L-&gt;prior = s; //头结点的前驱为新结点 &#125; return L;&#125; 打印双链表// 打印双循环链表void Print_Double_LinkedList(DLNode *L)&#123; DLNode *p = L-&gt;next; //p跳过头结点，指向第一个结点 while (p != L) &#123; printf("%d ", p-&gt;data); p = p-&gt;next; &#125; printf("\n");&#125; ···### 测试源码 链表源码，请点击这里获取 顺序表源码，请点击这里获取 随时补充]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linked List</tag>
        <tag>Sequence List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python下划线]]></title>
    <url>%2F2018%2F04%2F21%2FPython%E4%B8%8B%E5%88%92%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[Python中单下划线和双下划线的各种含义和命名约定，名称修饰的工作原理，以及它如何影响你自己的Python类。 前言单下划线和双下划线在Python变量和方法名称中都各有其含义。有一些含义仅仅是依照约定，被视作是对程序员的提示 - 而有一些含义是由Python解释器严格执行的。 在本文中，我们将讨论以下五种下划线模式和命名约定，以及它们如何影响Python程序的行为： 单前导下划线：_var 单末尾下划线：var_ 双前导下划线：__var 双前导和末尾下划线：__var__ 单下划线：_ 1. 单前导下划线 _var当涉及到变量和方法名称时，单个下划线前缀有一个约定俗成的含义。 它是对程序员的一个提示 - 意味着Python开发人员一致认为它应该是什么意思，但程序的行为不受影响。 下划线前缀的含义是告知其他程序员：以单个下划线开头的变量或方法仅供内部使用。 该约定在PEP 8中有定义。 这不是Python强制规定的。 Python不像Java那样在“私有”和“公共”变量之间有很强的区别。 这就像有人提出了一个小小的下划线警告标志，说： “嘿，这不是真的要成为类的公共接口的一部分。不去管它就好。“ 看看下面的例子： 如果你实例化此类，并尝试访问在__init__构造函数中定义的foo和_bar属性，会发生什么情况？ 让我们来看看： 你会看到_bar中的单个下划线并没有阻止我们“进入”类并访问该变量的值。 这是因为Python中的单个下划线前缀仅仅是一个约定 - 至少相对于变量和方法名而言。 但是，前导下划线的确会影响从模块中导入名称的方式。假设你在一个名为my_module的模块中有以下代码： 现在，如果使用通配符从模块中导入所有名称，则Python不会导入带有前导下划线的名称（除非模块定义了覆盖此行为的__all__列表）： 顺便说一下，应该避免通配符导入，因为它们使名称空间中存在哪些名称不清楚。 为了清楚起见，坚持常规导入更好。 与通配符导入不同，常规导入不受前导单个下划线命名约定的影响： 我知道这一点可能有点令人困惑。 如果你遵循PEP 8推荐，避免通配符导入，那么你真正需要记住的只有这个： 单个下划线是一个Python命名约定，表示这个名称是供内部使用的。 它通常不由Python解释器强制执行，仅仅作为一种对程序员的提示。 2. 单末尾下划线 var_有时候，一个变量的最合适的名称已经被一个关键字所占用。 因此，像class或def这样的名称不能用作Python中的变量名称。 在这种情况下，你可以附加一个下划线来解决命名冲突：总之，单个末尾下划线（后缀）是一个约定，用来避免与Python关键字产生命名冲突。 PEP 8解释了这个约定。 3. 双前导下划线 __var到目前为止，我们所涉及的所有命名模式的含义，来自于已达成共识的约定。 而对于以双下划线开头的Python类的属性（包括变量和方法），情况就有点不同了。 双下划线前缀会导致Python解释器重写属性名称，以避免子类中的命名冲突。 这也叫做名称修饰（name mangling） - 解释器更改变量的名称，以便在类被扩展的时候不容易产生冲突。 我知道这听起来很抽象。 因此，我组合了一个小小的代码示例来予以说明： 让我们用内置的dir()函数来看看这个对象的属性： 以上是这个对象属性的列表。 让我们来看看这个列表，并寻找我们的原始变量名称foo，_bar和__baz - 我保证你会注意到一些有趣的变化。 self.foo变量在属性列表中显示为未修改为foo。 self._bar的行为方式相同 - 它以_bar的形式显示在类上。 就像我之前说过的，在这种情况下，前导下划线仅仅是一个约定。 给程序员一个提示而已。 然而，对于self.__baz而言，情况看起来有点不同。 当你在该列表中搜索__baz时，你会看不到有这个名字的变量。 __baz出什么情况了？ 如果你仔细观察，你会看到此对象上有一个名为_Test__baz的属性。 这就是Python解释器所做的名称修饰。 它这样做是为了防止变量在子类中被重写。 让我们创建另一个扩展Test类的类，并尝试重写构造函数中添加的现有属性： 等一下，当我们尝试查看t2 .__ baz的值时，为什么我们会得到AttributeError？ 名称修饰被再次触发了！ 事实证明，这个对象甚至没有__baz属性： 正如你可以看到__baz变成_ExtendedTest__baz以防止意外修改： 但原来的_Test__baz还在： 双下划线名称修饰对程序员是完全透明的。 下面的例子证实了这一点： 名称修饰是否也适用于方法名称？ 是的，也适用。名称修饰会影响在一个类的上下文中，以两个下划线字符（”dunders”）开头的所有名称： 这是另一个也许令人惊讶的运用名称修饰的例子： 在这个例子中，我声明了一个名为_MangledGlobal__mangled的全局变量。然后我在名为MangledGlobal的类的上下文中访问变量。由于名称修饰，我能够在类的test()方法内，以__mangled来引用_MangledGlobal__mangled全局变量。 Python解释器自动将名称__mangled扩展为_MangledGlobal__mangled，因为它以两个下划线字符开头。这表明名称修饰不是专门与类属性关联的。它适用于在类上下文中使用的两个下划线字符开头的任何名称。 4. 双前导和双末尾下划线 __var__也许令人惊讶的是，如果一个名字同时以双下划线开始和结束，则不会应用名称修饰。 由双下划线前缀和后缀包围的变量不会被Python解释器修改： 但是，Python保留了有双前导和双末尾下划线的名称，用于特殊用途。 这样的例子有，__init__对象构造函数，或__call__ — 它使得一个对象可以被调用。 这些dunder方法通常被称为神奇方法 , 但Python开发者们都不喜欢这种方法。 最好避免在自己的程序中使用以双下划线（dunders）开头和结尾的名称，以避免与将来Python语言的变化产生冲突。 5. 单下划线 _按照习惯，有时候单个独立下划线是用作一个名字，来表示某个变量是临时的或无关紧要的。 例如，在下面的循环中，我们不需要访问正在运行的索引，我们可以使用“_”来表示它只是一个临时值： 你也可以在拆分(unpacking)表达式中将单个下划线用作“不关心的”变量，以忽略特定的值。 同样，这个含义只是“依照约定”，并不会在Python解释器中触发特殊的行为。 单个下划线仅仅是一个有效的变量名称，会有这个用途而已。 在下面的代码示例中，我将汽车元组拆分为单独的变量，但我只对颜色和里程值感兴趣。 但是，为了使拆分表达式成功运行，我需要将包含在元组中的所有值分配给变量。 在这种情况下，“_”作为占位符变量可以派上用场： 除了用作临时变量之外，“_”是大多数Python REPL中的一个特殊变量，它表示由解释器评估的最近一个表达式的结果。 这样就很方便了，比如你可以在一个解释器会话中访问先前计算的结果，或者，你是在动态构建多个对象并与它们交互，无需事先给这些对象分配名字： 总结以下是一个简短的小结，即“速查表”，罗列了我在本文中谈到的五种Python下划线模式的含义： 英文原文：https://dbader.org/blog/meaning-of-underscores-in-python 单前导下划线]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>下划线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[selenium遇到click失效问题解决]]></title>
    <url>%2F2018%2F04%2F11%2Fselenium%E9%81%87%E5%88%B0click%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[在使用selenium webdriver进行爬取淘宝信息，爬取一页结束后，进行翻页操作失败，仔细检查源码，发现在底端输入页码后模拟点击并未生效，本篇记录一下解决问题的办法。 问题描述相关代码# 使用谷歌浏览器browser = webdriver.Chrome(executable_path=chromedriver, chrome_options=options)# 定义一个等待，方便后面调用wait = WebDriverWait(browser, 10) # 函数功能：跳转到指定页数def jump_to_page(page): # 输入页码 input_page = wait.until( EC.presence_of_element_located((By.CSS_SELECTOR, "#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; input")) ) input_page.clear() input_page.send_keys(page) # 等待提交按钮可点击 submit_page = wait.until( EC.element_to_be_clickable((By.CLASS_NAME, "btn J_Submit")) ) submit_page.click() 在这里发现submit_page.click()并未生效。在网页中的这个地方： 页码可以正常插入，但并未发生跳转，即click方法未生效。 解决办法方法一：先点父元素即先点击想要点击的父元素，再点击子元素。browser.find_element_by_css_selector('#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form').click()browser.find_element_by_css_selector('"#mainsrp-pager &gt; div &gt; div &gt; div &gt; div.form &gt; span.btn.J_Submit').click() 淘宝真的强无敌，该方法并未起作用，是时候放大招了。 方法二：JS大法好即直接用js直接去点击，简单粗暴，但有效。js = 'document.getElementsByClassName("btn J_Submit")[0].click();'browser.execute_script(js)]]></content>
      <categories>
        <category>Spider Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Spider</tag>
        <tag>Selenium</tag>
        <tag>web driver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：ViewSets与Routers]]></title>
    <url>%2F2018%2F04%2F08%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9AViewSets%E4%B8%8ERouters%2F</url>
    <content type="text"><![CDATA[在这一篇文章中，要介绍的是另一种基于类的视图的写法，它的抽象程度更高，也可以说是代码量又减少了。 使用ViewSets重构视图先介绍一下这个ViewSets。ViewSets，翻译过来可以说是视图集，也就是几个视图的集合。 拿本项目为例子，我们之前查看所有用户列表就要写一个视图类UserList，并在urls.py中为其设置一个模式然后as_view使用它，然后要看单个用户的详情页就要再写一个UserDetail视图类并再在添加一个url模式。同时注意到这两个视图类都是继承的generics.XXXAPIView。而使用ViewSets我们就可以把UserList和UserDetail合并成UserViewSet视图类，并且继承的类改为viewsets.ReadOnlyModelViewSet，这样就是一个视图集了。 还是有点懵逼？没事，下面看看代码。编辑snippets/view.py，导入viewsets并使用UserViewSet来替换掉UserList和UserDetail： from rest_framework import viewsetsclass UserViewSet(viewsets.ReadOnlyModelViewSet): """ viewset自动提供了list和detail动作 """ queryset = User.objects.all() serializer_class = UserSerializer 这里面的queryset和serializer_class的值还是和原来一样。因为关于User的API都是只读的，所以我们继承了一个ReadOnlyModelViewSet类，这样就把原先的两个视图类集合起来了。原本类里面的： queryset = User.objects.all()serializer_class = UserSerializer 这部分属于重复代码，所以通过视图集来实现视图类我们的代码量确实减少了，更加简洁。 ViewSet类与View类其实几乎是相同的,但提供的是read或update这些操作,而不是get或put 等HTTP动作。同时，ViewSet为我们提供了默认的URL结构, 使得我们能更专注于API本身。 上面这段话呢，是官方文档里面说的，想就这样看看就算了来理解也行，不过如果我们看一下源码也许能理解的更好。因为我用的是PyCharm，所以查看源码很方便，按住CTRL键然后鼠标点击一下就会自动跳转了，首先查看一下ReadOnlyModelViewSet，发现它是这样的： class ReadOnlyModelViewSet(mixins.RetrieveModelMixin, mixins.ListModelMixin, GenericViewSet): &quot;&quot;&quot; A viewset that provides default `list()` and `retrieve()` actions. &quot;&quot;&quot; pass 发现原来有用到之前说的mixins，所以刚才才说ViewSet类与View类其实几乎是相同的。但是这里多了一个GenericViewSet类是新的内容，继续CTRL点击查看其代码，发现它内部只是一个pass然后就没有其他的操作了，但是可以继续查看其父类ViewSetMixin的源码来了解ViewSets，然后就可以看到这个ViewSetMixin其实重写了as_view方法： @classonlymethod def as_view(cls, actions=None, **initkwargs): &quot;&quot;&quot; Because of the way class based views create a closure around the instantiated view, we need to totally reimplement `.as_view`, and slightly modify the view function that is created and returned. &quot;&quot;&quot; ... 我们平时使用视图类的时候，编写urls.py时，就一个XXX.as_view()，现在使用ViewSets，需要传入参数，大概像下面这样的： UserViewSet.as_view(&#123;'get': 'list'&#125;) 之后url就配置好了，也就是上面说的ViewSet为我们提供了默认的URL结构。当然了，这个还不是完整的url模式，稍后补全。 刚才把User的两个视图类合并成视图集了，那么Snippet的几个视图类操作上也是差不多的。用视图集SnippetViewSet代替SnippetList, SnippetDetail 和 SnippetHighlight这三个视图类： from rest_framework.decorators import detail_routeclass SnippetViewSet(viewsets.ModelViewSet): """ viewset自动提供了`list`, `create`, `retrieve`, `update` 和 `destroy` 动作. 同时我们手动增加一个额外的'highlight'动作用于查看高亮的代码段 """ queryset = Snippet.objects.all() serializer_class = SnippetSerializer permission_classes = (permissions.IsAuthenticatedOrReadOnly, IsOwnerOrReadOnly,) @detail_route(renderer_classes=[renderers.StaticHTMLRenderer]) def highlight(self, request, *args, **kwargs): snippet = self.get_object() return Response(snippet.highlighted) def perform_create(self, serializer): serializer.save(owner=self.request.user) 因为查看highlight不像其他动作那样，django-rest-framework并没有替我们封装好，所以我们需要自己添加这个额外的动作，要记得在方法前面加上装饰器@detail_route，这个装饰器就是用来创建自定义的动作，当然我们的自定义动作不可以是create/update/delete这些标准的，否则会有冲突。 还有一点，用@detail_route装饰器定义的动作默认是GET请求，需要其他的请求方式可以传入methods参数给这个装饰器。同样的，默认情况下，自定义操作的URL取决于方法名称本身。如果要更改url应该构造的方式，可以将url_path作为decorator的关键字参数。 最后还要注意继承的类是ModelViewSet和刚才的也有点不同，为什么换成这个，也可以看看源码能略知一二： class ModelViewSet(mixins.CreateModelMixin, mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, mixins.ListModelMixin, GenericViewSet): ... 将ViewSets明确的绑定到URL根据上面所说的，每个视图集的url模式都需要我们在as_view中传入参数，把snippets/urls.py的代码换成下面的： from django.conf.urls import url,includefrom snippets.views import SnippetViewSet, UserViewSet, api_rootfrom rest_framework import renderersfrom rest_framework.urlpatterns import format_suffix_patternssnippet_list = SnippetViewSet.as_view(&#123; 'get': 'list', 'post': 'create'&#125;)snippet_detail = SnippetViewSet.as_view(&#123; 'get': 'retrieve', 'put': 'update', 'patch': 'partial_update', 'delete': 'destroy'&#125;)snippet_highlight = SnippetViewSet.as_view(&#123; 'get': 'highlight'&#125;, renderer_classes=[renderers.StaticHTMLRenderer])user_list = UserViewSet.as_view(&#123; 'get': 'list'&#125;)user_detail = UserViewSet.as_view(&#123; 'get': 'retrieve'&#125;)urlpatterns = format_suffix_patterns([ url(r'^$', api_root), url(r'^snippets/$', snippet_list, name='snippet-list'), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/$', snippet_detail, name='snippet-detail'), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlight/$', snippet_highlight, name='snippet-highlight'), url(r'^users/$', user_list, name='user-list'), url(r'^users/(?P&lt;pk&gt;[0-9]+)/$', user_detail, name='user-detail')]) OK，到了这里对视图的改造已经完成了，可以启动服务器测试一下，我们的项目功能还是和之前的一样的。 使用Routers不过看到urls.py的代码，我们可能会发现一个问题，就是我们的视图类代码简洁了变少了，但是urls.py的代码量好像多了啊，要绑定那么多动作，这样算起来好像也没多大提升？ 确实是这样。但是我们这可是在用python开发啊，当然是能短则短了，没错，django-rest-framework的作者也是这么想的，所以我们又有现成的轮子可以使用了。这个轮子就是本文的另一个主角——Routers。用起来也是简单粗暴，重写urls.py： from django.conf.urls import url, includefrom snippets import viewsfrom rest_framework.routers import DefaultRouter# Create a router and register our viewsets with it.router = DefaultRouter()router.register(r'snippets', views.SnippetViewSet)router.register(r'users', views.UserViewSet)# The API URLs are now determined automatically by the router.# Additionally, we include the login URLs for the browsable API.urlpatterns = [ url(r'^', include(router.urls)),] 这样就搞定了，代码少了很多，连原来用来设置后缀的下面这行代码都不需要了。 urlpatterns = format_suffix_patterns(urlpatterns) 而且这个DefaultRouter 类还会自动帮我们创建API根视图，也就是说view.py中的api_root方法也可以删除掉了。 额…这个Routers帮我们做的事情真是有点多啊。。不过这也就是我为什么在文章的前言里面说使用ViewSets会比原本的视图更抽象的原因。 拿过来用是会了，但是这里面发生了什么我们完全不知道啊，比如说API后缀去哪了？上面我们写的： snippet_list = SnippetViewSet.as_view(&#123; 'get': 'list', 'post': 'create'&#125;) 这些绑定全都自动生成了？这些确实都是DefaultRouter 帮我们做好了，怎么做的，我们还是可以看一下源码了解一下大概的过程。首先就是register方法，我们绑定了那么多动作它两行就搞定了，查看它的源码，发现它是BaseRouter类下的一个方法： class BaseRouter(object): def __init__(self): self.registry = [] def register(self, prefix, viewset, base_name=None): if base_name is None: base_name = self.get_default_base_name(viewset) self.registry.append((prefix, viewset, base_name)) ... @property def urls(self): if not hasattr(self, '_urls'): self._urls = self.get_urls() return self._urls 改方法根据传进来的参数生成url端点，也就是/snippets和/users，然后存到registry列表中。并且这个类的最后是一个可以当属性用的方法urls，而这个方法里面又调用了get_urls()来生成所有的url模式，当然这个get_urls()被子类SimpleRouter和子子类DefaultRouter重写了。SimpleRouter中的get_urls()实现了生成是5个url模式，也就是原本的： url(r'^snippets/$',snippet_list,name='snippet-list'),url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/$', snippet_detail, name='snippet-detail'),url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlight/$', snippet_highlight, name='snippet-highlight'),url(r'^users/$', user_list, name='user-list'),url(r'^users/(?P&lt;pk&gt;[0-9]+)/$', user_detail, name='user-detail') 而DefaultRouter中的get_urls()中则生成了api_root的url模式，同时还为这些url模式加了格式后缀，所以我们自己不会用到format_suffix_patterns这个东西。 当然了，并不一定要使用ViewSets的视图代替View，两者各有好处ViewSets节省了很多代码并且url模式也不用我们自己设置了，但是也会带来一些不确定性，自动化的效果有时候可能和你预想的不太一样，所以想要选择哪种方法看你自己喜欢。 声明本篇文章来自ziv的博客，仅作整理学习分享。点击这里访问原文。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：超链接]]></title>
    <url>%2F2018%2F04%2F08%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E8%B6%85%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[在不同的资源信息之间使用超链接进行跳转，及之前提到的显示时代码段高亮的实现。 在上篇中，加入了用户模型，以及相关的认证和权限的功能。但是我们在使用的时候，会发现在访问http://127.0.0.1:8000/users/时看到的用户列表，不能够直接点击某个链接然后查看其详情，也就是不能跳转到http://127.0.0.1:8000/users/2这样的链接，查看Snippet列表的时候也是如此。而且User和Snippet也没相关的链接进行相互之间的跳转。这些就很影响用户体验了，每次都需要重新输入URL才可以访问别的内容。这就是这篇文章主要解决的问题。 另外，上一篇文章说的能使代码段高亮的HTML代码，也会在本文中看到其使用。 为API创建根URL根URL也就是访问根路径，就是http://127.0.0.1:8000/，要让这个页面能显示并访问所有的模型，也就是本项目的snippets和users。所以在views.py中肯定要多增加一个内容作为根URL（也就是首页）的视图，在这里我们采用基于函数的视图，编辑snippets/views.py并添加下面的内容： from rest_framework.decorators import api_viewfrom rest_framework.response import Responsefrom rest_framework.reverse import reverse@api_view(['GET'])def api_root(request, format=None): return Response(&#123; 'users': reverse('user-list', request=request, format=format), 'snippets': reverse('snippet-list', request=request, format=format) &#125;) 关于装饰器在之前的文章已经讲解过了，这里的新知识是reverse，这是rest_framework的reverse而不是Django自带的那个，但是使用习惯类似，它会根据参数返回一个超链接，看到’user-list’和’snippet-list’基本就和Django自带的reverse一样的道理，就是根据路由匹配模式的命名来生成超链接，所以等下需要编辑snippets/urls.py设置一下name参数。 然后Response的参数是一个字典，这个其实也和Django开发一样，这个字典的键和值会传到前端模板然后经过模板引擎渲染，只不过这里的前端模板django-rest-framework已经帮我们做好了，只需把值传递过去就OK啦。 创建跳转至查看高亮代码段的URL现在我们的API还不能查看高亮代码段，所以需要添加一个链接进行跳转。 回到上一篇文章里面的snippets/models.py，我们为Snippet模型添加了highlighted字段，并且使用save方法，使得保存数据时生成能使代码段高亮的HTML代码，也就是下面这段代码： def save(self, *args, **kwargs): """ 使用pygments库来生成能使代码高亮的HTML代码 """ lexer = get_lexer_by_name(self.language) linenos = self.linenos and 'table' or False options = self.title and &#123;'title': self.title&#125; or &#123;&#125; formatter = HtmlFormatter(style=self.style, linenos=linenos, full=True, **options) self.highlighted = highlight(self.code, lexer, formatter) super(Snippet, self).save(*args, **kwargs) 所以每次保存数据时都会自动更新生成新的HTML代码。 现在我们要做的就是使用API的时候，每个snippet下面除了id、title、owner等这些本来就有的，还要加一个超链接，点击链接就能查看高亮代码段的页面，所以需要为这个新页面再创建一个视图，编辑snippet/views.py，添加代码： from rest_framework import renderersclass SnippetHighlight(generics.GenericAPIView): queryset = Snippet.objects.all() renderer_classes = (renderers.StaticHTMLRenderer,) def get(self, request, *args, **kwargs): snippet = self.get_object() return Response(snippet.highlighted) 这个代码高亮是为了在浏览器上使用API时查看的，所以返回json格式的数据就没有什么意思了，所以这里限定为只用HTML方式呈现。 REST framework为我们提供了两种方式来呈现HTML，一种是使用已有的模板（我们平时开发Django更常用的那种方式），另一种就是使用已经构建好的HTML代码。在这里我们会使用第二种方法，因为刚才已经说了每次保存数据时都会自动更新生成新的HTML代码，而这个由pygments生成的代码就保存在Snippet下的highlighted，所以有浏览器渲染并呈现highlighted下的HTML代码就行了。因此有： renderer_classes = (renderers.StaticHTMLRenderer,) 另外我们还注意到这里使用了get方法，其他的视图类不用这个方法因为他们返回的是整个实例对象，而我们的高亮代码段页面只需要这个实例对象的一个属性，也就是snippet.highlighted。REST framework提供的通用视图类并没有提供直接返回一个实例的某个属性的方法，所以这里需要我们自己写一个get方法来指定返回的属性。 完成了根视图以及高亮代码段视图的设计，要调用到它们的话，接下来自然要为其设计URL了。编辑snippets/urls.py，添加下面两个url模式： url(r'^$', views.api_root),url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlight/$', views.SnippetHighlight.as_view()), 用超链接关联API到目前，User和Snippet在浏览时还不能相互之间进行跳转，比如我们访问一个用户的详情页时，单个User下的snippets会显示此用户创建的所有snippet，但是只显示了id值，可读性不好并且不能跳转，光看到个数字其实意义不大。我们希望实现的是把这些id值换成相应的snippet的超链接，同时希望在查看用户列表的时候每个用户下面有个超链接能直接进入该用户详情页；同样的，在每个snippet下有个URL指向其创建者的详情页面。 说了那么多，我们想要的就是用超链接来关联API，用来代替之前简单粗暴的使用外键以及id值来表示。 由此，在序列化器中引出一个新的HyperlinkedModelSerializer类来代替之前的ModelSerializer类。 这个新的类有以下的不同点： 默认不包含id值 通过HyperlinkedIdentityField这个字段会为序列化器生成一个url属性 关联API使用的是HyperlinkedRelatedField而不是PrimaryKeyRelatedField（超链接代替外键） 这么一看，这个新的HyperlinkedModelSerializer类好像可以实现上面我们所说的那些功能，确实是这样的。编辑snippet/serializers.py，改进序列化器： class SnippetSerializer(serializers.HyperlinkedModelSerializer): owner = serializers.ReadOnlyField(source='owner.username') highlight = serializers.HyperlinkedIdentityField(view_name='snippet-highlighted', format='html') class Meta: model = Snippet fields = ('url', 'id', 'highlight', 'owner', 'title', 'code', 'linenos', 'language', 'style')class UserSerializer(serializers.HyperlinkedModelSerializer): snippets = serializers.HyperlinkedRelatedField(many=True, view_name='snippet-detail', read_only=True) class Meta: model = User fields = ('url', 'id', 'username', 'snippets') 可以看到两个Meta类都多了一个’url’，这就是HyperlinkedRelatedField生成的，并且看到参数中又有一个命名空间，乍一看好像有点像reverse生成URL的套路啊？ 额…内部的实现真的是有用到reverse，通过查看源码就能追踪到那里，首先进入HyperlinkedRelatedField源码，发现里面只有一个__init__构造方法，那就继续进入它的父类HyperlinkedRelatedField的源码，发现里面有这么一个函数： def get_url(self, obj, view_name, request, format): """ Given an object, return the URL that hyperlinks to the object. May raise a `NoReverseMatch` if the `view_name` and `lookup_field` attributes are not configured to correctly match the URL conf. """ # Unsaved objects will not yet have a valid URL. if hasattr(obj, 'pk') and obj.pk in (None, ''): return None lookup_value = getattr(obj, self.lookup_field) kwargs = &#123;self.lookup_url_kwarg: lookup_value&#125; return self.reverse(view_name, kwargs=kwargs, request=request, format=format) 发现其实这个方法最后用的还是reverse方法，并且将生成的url作为返回的数据。所以继续往下看这个类的代码，会发现还有个to_representation方法里面有这么几行代码： try: url = self.get_url(value, self.view_name, request, format)except NoReverseMatch: ...if url is None: return Nonereturn Hyperlink(url, value) 这个过程下来我们大概能知道HyperlinkedIdentityField也能帮我们生成相应url，并且是一个超链接的形式。 另外注意到我们想要让代码高亮API只用HTML呈现，所以还设置了format=’html’参数限定了后缀。 为各个URL模式命名上面的程序为了生成url又是reverse又是HyperlinkedIdentityField的，其中的参数都用到了命名，所以我们想要生成正确的url就要给各个URL模式根据上面的参数正确命名。 编辑 snippets/urls.py，添加命名： from django.conf.urls import urlfrom snippets import viewsfrom rest_framework.urlpatterns import format_suffix_patternsurlpatterns = [ url(r'^snippets/$', views.SnippetList.as_view(),name='snippet-list'), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/$', views.SnippetDetail.as_view(),name='snippet-detail'), url(r'^users/$',views.UserList.as_view(),name='user-list'), url(r'^users/(?P&lt;pk&gt;[0-9]+)/$',views.UserDetail.as_view(),name='user-detail'), url(r'^$',views.api_root), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/highlighted/$',views.SnippetHighlight.as_view(),name='snippet-highlighted'),]urlpatterns = format_suffix_patterns(urlpatterns) 添加分页如果我们创建的用户和代码段都很多的话，再查看列表是全部显示在一页有时候可能有点难看，所以这里需要添加一个分页设置，很简单，只需要在项目的settings.py中添加一个配置字典： REST_FRAMEWORK = &#123; 'PAGE_SIZE': 10&#125; 这样就可以实现分页了 OK，现在我们的项目通过使用各种超链接来关联，API之间已经可以方便的进行花式跳转了。 实际效果首先是API根页面： 里面的链接都是可以点击的，下面是单个Snippet详情页： 最后是代码高亮页面，其实就是highlighted中的HTML代码被浏览器渲染后的样子： 想要这个页面的源码的话除了在浏览器右键打开，还可以直接SnippetSerializer下面的Meta类中，直接为field再加一个’highlighted’，然后浏览的时候就会发现Snippet详情页多了个highlighted键，它的值就是很长很长的一坨HTML代码，这代码生成的页面其实就是上面那个图的样子。 OK，关于添加超链接提高模型间的关联性的介绍就先到这了。下一篇文章会介绍视图集和路由相关的内容。 声明本篇文章来自ziv的博客，仅作整理学习分享。点击这里访问原文。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：权限控制]]></title>
    <url>%2F2018%2F04%2F07%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[现在我们的API还有一个很明显的缺陷，那就是没有认证和权限功能，任何资源都会任何用户被随意更改，所以我们要添加这一功能。 需求分析我们要改进程序，实现以下功能： snippet与其创建者相互关联 只有经过身份验证（登录）的用户才可以创建snippets 只有创建该snippet的用户才可以对其进行更改或者删除 未经验证的用户只具有访问（只读）的功能 修改snippet模型首先，我们想让snippets都和它们的创建用户关联起来，所以我们自然的要在Snippet模型添加一个owner字段来表示。另外，我们还添加一个highlighted字段用来实现代码高亮，修改snippets/models.py的Snippet：owner = models.ForeignKey('auth.User', related_name='snippets', on_delete=models.CASCADE)highlighted = models.TextField() 想要实现代码高亮，当然不是上面一行代码就搞定了，它现在还只是一个普通的字段而已。我们要做的是在保存的时候，也就是当执行save()时, 我们使用pygments生成高亮后的HTML，还是在model.py,首先导入相关的库: from pygments.lexers import get_lexer_by_namefrom pygments.formatters.html import HtmlFormatterfrom pygments import highlight 然后在Snippet类中添加save()方法： def save(self, *args, **kwargs): """ 使用pygments库来生成能使代码高亮的HTML代码 """ lexer = get_lexer_by_name(self.language) linenos = self.linenos and 'table' or False options = self.title and &#123;'title': self.title&#125; or &#123;&#125; formatter = HtmlFormatter(style=self.style, linenos=linenos, full=True, **options) self.highlighted = highlight(self.code, lexer, formatter) super(Snippet, self).save(*args, **kwargs) 在保存数据的时候就会执行上面这个方法，整个方法的功能如注释所示，在这一篇文章中还不会具体的展示这个功能，在接下来的文章中会展示。 修改了模型当然需要同步一下数据库了，在这里我们和官方文档一样把数据库删了在重新生成，首先把工程目录下的db.sqlite3以及snippets下的migrations文件夹删除，然后再执行迁移步骤： python manage.py makemigrations snippetspython manage.py migrate 同时，由于我们想要实现的是访问各个snippet时显示相应的创建者，所以这里需要创建几个不同的账户稍后才可以显示。 python manage.py createsuperuser 为用户模型添加端点原理和之前的SnippetSerializer基本一样，在snippets/serializers.py中添加一个User序列化器： from django.contrib.auth.models import Userclass UserSerializer(serializers.ModelSerializer): snippets = serializers.PrimaryKeyRelatedField(many=True, queryset=Snippet.objects.all()) class Meta: model = User fields = ('id', 'username', 'snippets') 注意到里面的： snippets = serializers.PrimaryKeyRelatedField(many=True, queryset=Snippet.objects.all()) 因为snippets在User模型中是一个反向关系，在使用ModelSerializer类时默认情况是不会包括这个关系，就是说通过Snippet的owner能查询到User，而User这边查询不到一个用户创建的snippet，所以我们需要手动为用户序列添加这个字段。 弄好了User的序列化器，接着就要让其能够显示出来，所以要添加相关的视图类，编辑view.py: from django.contrib.auth.models import Userfrom snippets.serializers import UserSerializerclass UserList(generics.ListAPIView): queryset = User.objects.all() serializer_class = UserSerializerclass UserDetail(generics.RetrieveAPIView): queryset = User.objects.all() serializer_class = UserSerializer 写好了视图函数，想要通过URL访问到它们，肯定是配置一下路由分发啦，编辑snippets/urls.py添加下面的匹配模式： url(r'^users/$', views.UserList.as_view()),url(r'^users/(?P&lt;pk&gt;[0-9]+)/$', views.UserDetail.as_view() 关联Snippets和Users到了这里，如果像之前那样创建代码段的话，我们还不能把Snippets和Users关联起来。因为在使用的时候User的数据是通过request传入的，而不是以序列化的数据传递过来。 而我们刚才添加了一个owner作为外键，这个时候就要看到它的用处了，编辑view.py,为SnippetList视图类添加一个方法： class SnippetList(generics.ListCreateAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer permission_classes = (permissions.IsAuthenticatedOrReadOnly,) def perform_create(self, serializer): serializer.save(owner=self.request.user) 这个perform_create() 可以让用户在通过POST请求创建一个新的Snippet时，在保存新的Snippet数据的时候会把request中的user赋值给Snippet的owner。等下具体使用的时候就可以轻松的理解了。 更新serializer上一步已经把两者关联起来了，owner会在创建新的Snippet的时候拥有User的各个属性，那么在API中要让owner显示id还是用户名，为了提高可读性，答案当然是显示用户名了，所以我们在SnippetSerializer 下面增加一个字段： owner = serializers.ReadOnlyField(source='owner.username') 这里的source参数就指定了哪个属性用于填充字段，为了在使用的时候显示owner，但是还要把它添加进Meta类里面，所以整个SnippetSerializer如下： class SnippetSerializer(serializers.ModelSerializer): # 这里可以使用也 CharField(read_only=True) 来替换 owner = serializers.ReadOnlyField(source='owner.username') class Meta: model = Snippet fields = ('id', 'title', 'code', 'linenos', 'language', 'style','owner') 添加权限现在Snippet和User已经关联起来并且是可浏览的。接下来我们要实现的及时权限的问题了。也就是我们一开始说的几点中的： 只有经过身份验证（登录）的用户才可以创建snippet 只有创建该snippet的用户才可以对其进行更改或者删除 未经验证的用户只具有访问（只读）的功能 首先在views.py导入一个库： from rest_framework import permissions 接着为SnippetList 和 SnippetDetail添加权限判断，在这两个视图类中都加入： permission_classes = (permissions.IsAuthenticatedOrReadOnly, ) 这里要特别注意，有一个坑，就是那个逗号一定要加上去，不然就会报错。这行代码的作用就是判断当前用户是否为该Snippet的创建者，而其他用户只有只读属性，就是只能查看。 为可浏览的API添加登录功能刚才添加了权限判断，如果没有登录用户，那就相当于游客啦，什么功能都没有只能看，所以在浏览器浏览API的时候就需要登录 功能。在这里，强大的django-rest-framework又为我们做了很多事情，想要在添加登录按钮和页面，只需要修改一个rest_tutorial/urls.py，添加一个URL匹配： urlpatterns += [ url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework')),] 这里的r&#39;^api-auth/&#39;你可以设置成任意你喜欢的，但是命名空间一定要相同，就是namespace=&#39;rest_framework。 好了，现在打开浏览器，就可以看到在我们的API页面的右上角有一个登录的按钮，点击之后就可以使用之前创建的用户登录了。 这个时候访问单个用户的详情，就可以看到该用户创建的所有Snippet的id值（需要先创建好几个Snippet，可以按照本系列第一篇文章中在shell模式中的方法来创建）。比如访问： http://127.0.0.1:8000/users/ 添加对象权限接着我们要实现的是让所有的Snippet可以被所有人访问到，但是每个Snippet只有其创建者才可以对其进行更改、删除等操作。 因此，我们需要设置一下自定义权限，使每个Snippet只允许其创建者编辑它。在snippets目录下新建一个permissions.py： from rest_framework import permissionsclass IsOwnerOrReadOnly(permissions.BasePermission): """ 使每个Snippet只允许其创建者编辑它 """ def has_object_permission(self, request, view, obj): # 任何用户或者游客都可以访问任何Snippet，所以当请求动作在安全范围内， # 也就是GET，HEAD，OPTIONS请求时，都会被允许 if request.method in permissions.SAFE_METHODS: return True # 而当请求不是上面的安全模式的话，那就需要判断一下当前的用户 # 如果Snippet所有者和当前的用户一致，那就允许，否则返回错误信息 return obj.owner == request.user 代码的逻辑已在注释中，简单说就是提供判断功能，然后我们要把它运用起来，在view.py中的SnippetDetail 修改一下： class SnippetDetail(generics.RetrieveUpdateDestroyAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer permission_classes = (permissions.IsAuthenticatedOrReadOnly, IsOwnerOrReadOnly,) 注意要导入IsOwnerOrReadOnly类： from snippets.permissions import IsOwnerOrReadOnly 现在用浏览器打开单个Snippet详情页，如果你当前登录的用户是这个Snippet的创建者，那你会发现多了DELETE和PUT两个操作，比如访问http://127.0.0.1:8000/snippets/2/，效果如下： 使用API授权由于现在我们还没使用authentication 类，所以项目目前还是使用默认的SessionAuthentication 和 BasicAuthentication. 在使用浏览器访问API的时候，浏览器会帮我们保存会话信息，所以当权限满足时就可以对一个Snippet进行删除或者更改，或者是创建一个新的Snippet。 当如果是通过命令行来操作API，我们就必须在每次发送请求的时候添加授权信息，也就是用户名和密码，没有的话就会报错，比如： http POST http://127.0.0.1:8000/snippets/ code=&quot;print 123&quot;&#123; &quot;detail&quot;: &quot;Authentication credentials were not provided.&quot;&#125; 正确的操作如下： http -a username:password POST http://127.0.0.1:8000/snippets/ code=&quot;print 789&quot;&#123; &quot;id&quot;: 1, &quot;owner&quot;: &quot;username1&quot;, &quot;title&quot;: &quot;&quot;, &quot;code&quot;: &quot;print 789&quot;, &quot;linenos&quot;: false, &quot;language&quot;: &quot;python&quot;, &quot;style&quot;: &quot;friendly&quot;&#125; 我们可以看出owner就是提交过来的用户名，这就是上面代码的功能体现： def perform_create(self, serializer): serializer.save(owner=self.request.user) 通过实际使用更能理解程序，owner会在一个用户创建Snippet时得到该用户的信息就是这么来的。 声明本篇文章来自ziv的博客，仅作整理学习分享。点击这里访问原文。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：类视图]]></title>
    <url>%2F2018%2F04%2F06%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E7%B1%BB%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，主要讲的是请求和响应，项目里面views.py中的视图函数都是基于函数的，并且我们介绍了@api_view这个很有用的装饰器。同时，我们还介绍了APIView这个类，但是还没使用它。在这篇文章中，我们要做的是把基于方法的视图改为基于类的视图，将会了解到APIView。 改为基于类的视图重构一下snippets/view.py： from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom django.http import Http404from rest_framework.views import APIViewfrom rest_framework.response import Responsefrom rest_framework import statusclass SnippetList(APIView): """ 列出所有已经存在的snippet或者创建一个新的snippet """ def get(self, request, format=None): snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return Response(serializer.data) def post(self, request, format=None): serializer = SnippetSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 到这里应该很容易理解，和原来的相比，可以发现基于类的视图把各种不同的HTTP请求分离开变成单个的方法，而不是if...elif...这样的结构，所以这样处理起来很更加的高效。 同样的，把另一个视图函数也进行修改： class SnippetDetail(APIView): """ 检索查看、更新或者删除一个snippet """ def get_object(self, pk): try: return Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: raise Http404 def get(self, request, pk, format=None): snippet = self.get_object(pk) serializer = SnippetSerializer(snippet) return Response(serializer.data) def put(self, request, pk, format=None): snippet = self.get_object(pk) serializer = SnippetSerializer(snippet, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) def delete(self, request, pk, format=None): snippet = self.get_object(pk) snippet.delete() return Response(status=status.HTTP_204_NO_CONTENT) 修改路由改为基于类的视图之后，当然也要修改一下路由了，对snippets/urls.py稍加修改： from django.conf.urls import urlfrom rest_framework.urlpatterns import format_suffix_patternsfrom snippets import viewsurlpatterns = [ url(r'^snippets/$', views.SnippetList.as_view()), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/$', views.SnippetDetail.as_view()),]urlpatterns = format_suffix_patterns(urlpatterns) 使用mixins类使用基于类的视图的好处除了上面所说的把各种HTTP请求分离开，还有什么好处吗？答案是肯定的——使用基于类的视图的最大优势之一是它可以轻松地构成可重复使用的行为。 可重复使用的行为？简单说，就是让我们少写一点功能类似的代码，由此就要介绍一下mixins类了，它帮我们封装了很多操作，简化代码，使用也很简单，编辑snippets/view.py函数： from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom rest_framework import mixinsfrom rest_framework import genericsclass SnippetList(mixins.ListModelMixin, mixins.CreateModelMixin, generics.GenericAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer def get(self, request, *args, **kwargs): return self.list(request, *args, **kwargs) def post(self, request, *args, **kwargs): return self.create(request, *args, **kwargs) 新的视图类中继承了 generic.GenericAPIView、mixins.ListModelMixin和mixins.CreatteModelMixin，类的作用看字面意思就能懂啦，mixins类为我们提供了list()和create()方法，当然，使用这两个函数需要先设置queryset和serializer_class，这点我们查看一下mixins的源码就可以看出来了，比如list方法： class ListModelMixin(object): """ List a queryset. """ def list(self, request, *args, **kwargs): queryset = self.filter_queryset(self.get_queryset()) page = self.paginate_queryset(queryset) if page is not None: serializer = self.get_serializer(page, many=True) return self.get_paginated_response(serializer.data) serializer = self.get_serializer(queryset, many=True) return Response(serializer.data) 这里的代码会分别通过get_queryset()和get_serializer()得到查询集和序列化器，其他封装好的方法也是如此。 知道了这个，再修改一下另一个视图类就很容易了： class SnippetDetail(mixins.RetrieveModelMixin, mixins.UpdateModelMixin, mixins.DestroyModelMixin, generics.GenericAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer def get(self, request, *args, **kwargs): return self.retrieve(request, *args, **kwargs) def put(self, request, *args, **kwargs): return self.update(request, *args, **kwargs) def delete(self, request, *args, **kwargs): return self.destroy(request, *args, **kwargs) 使用generics视图类到这里，视图代码已经简化了许多了，但是我要告诉你的是，还可以进一步简化。进一步简化就是连mixins类都不用了，只使用generics就可以了，代码如下 from snippets.models import Snippetfrom snippets.serializers import SnippetSerializerfrom rest_framework import genericsclass SnippetList(generics.ListCreateAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializerclass SnippetDetail(generics.RetrieveUpdateDestroyAPIView): queryset = Snippet.objects.all() serializer_class = SnippetSerializer 好了，现在的代码就显得非常简洁了，但是短小却精悍，依然可以实现原本的功能。 测试Api测试方法和上篇雷同，可跳过。http http://127.0.0.1:8000/snippets/ 通过设置Accept头部信息来控制返回的格式 http http://127.0.0.1:8000/snippets/ Accept:application/json # JSONhttp http://127.0.0.1:8000/snippets/ Accept:text/html # HTML 效果如下（返回的是页面的HTML代码，只展示了一部分）： 直接加格式后缀 http http://127.0.0.1:8000/snippets.json # JSON suffixhttp http://127.0.0.1:8000/snippets.api # Browsable API suffix 浏览器查看Api 我们可以直接在浏览器输入 http://127.0.0.1:8000/snippets.api 进行查看，会得到一个美观的页面： 增加数据我们可以控制 Content-Type 头部信息来提交POST请求： http --form POST http://127.0.0.1:8000/snippets/ code=&quot;print 123&quot;http --json POST http://127.0.0.1:8000/snippets/ code=&quot;print 456&quot; 它会自动在原有的数据后面添加你提交过去的数据，效果如下： 修改数据我们通过PUT来实现修改功能，在我们之前定义的函数views.snippet_detail中： url(r'^snippets/(?P&lt;pk&gt;[0-9]+)$', views.snippet_detail), 所以通过 url snippets/[id]就可以访问到我们要的数据，就可以对其进行修改。 http --json PUT http://127.0.0.1:8000/snippets/1.json code="sss" 删除数据同之前的修改一样，我们使用DELETE，通过 url snippets/[id]访问数据，提交删除。 http DELETE http://127.0.0.1:8000/snippets/8.json 这样我们就成功的删除了一条数据。 声明本篇文章来自ziv的博客，仅作整理学习分享。点击这里访问原文。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：序列化]]></title>
    <url>%2F2018%2F04%2F06%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[利用Django框架实现Restful-Api的序列化，即当其他人访问这个URL时返回json格式的数据。 搭建环境首先当然是在虚拟环境中使用了，这里我们使用Django-REST-Framework的库，需要用到的包： pip install djangopip install djangorestframeworkpip install pygments # 用来实现代码高亮 创建工程首先创建一个名为tutorial的工程，然后在这个工程中创建一个snippets的APP： django-admin.py startproject tutorialcd tutorialpython manage.py startapp snippets 创建完成之后在tutorial/settings.py中修改一下INSTALLED_APPS，添加两个APP： INSTALLED_APPS = ( ... 'rest_framework', 'snippets.apps.SnippetsConfig', # 如果Django&lt;1.9，那么使用snippets代替) 创建模型类创建一个Snippet模型类，用于储存代码段，编写snippets/models.py： from django.db import modelsfrom pygments.lexers import get_all_lexersfrom pygments.styles import get_all_stylesLEXERS = [item for item in get_all_lexers() if item[1]]LANGUAGE_CHOICES = sorted([(item[1][0], item[0]) for item in LEXERS]) # 得到所有的编程语言STYLE_CHOICES = sorted((item, item) for item in get_all_styles()) # 得到所有的配色风格class Snippet(models.Model): created = models.DateTimeField(auto_now_add=True) title = models.CharField(max_length=100, blank=True, default='') code = models.TextField() linenos = models.BooleanField(default=False) language = models.CharField(choices=LANGUAGE_CHOICES, default='python', max_length=100) style = models.CharField(choices=STYLE_CHOICES, default='friendly', max_length=100) class Meta: ordering = ('created',) 除了注释的那里，其他的代码都很常规，和我们平时Django开发时是一样的。然后就为这个模型创建并迁移数据（这里只是为了展示，所以使用的数据库是Django自带的那个sqlite）： python manage.py makemigrations snippetspython manage.py migrate 创建序列化类首先解释一下序列化：在这里可以先简单的理解为serializer，把模型实例转化为json格式然后响应出去，这样便于客户端调用时解析使用。 例如一个PostModel，里面有两个字段分别为title和author，序列化之后就是{&#39;title&#39;:&#39;RESTful API&#39;,&#39;author&#39;:&#39;liu&#39;}这样的json格式，这样明显就更适合各种客户端的使用人员解析使用。 那么反序列化其实道理差不多，反序列化之后的数据格式更便于后台使用，等下会有例子加深理解。 解释完序列化，那么接下来就该敲代码了，在snippets下面创建一个serializers.py，代码如下： from rest_framework import serializersfrom snippets.models import Snippet, LANGUAGE_CHOICES, STYLE_CHOICESclass SnippetSerializer(serializers.Serializer): id = serializers.IntegerField(read_only=True) title = serializers.CharField(required=False, allow_blank=True, max_length=100) # 利用字段标志控制序列化器渲染到HTML页面时的的显示模板 code = serializers.CharField(style=&#123;'base_template': 'textarea.html'&#125;) linenos = serializers.BooleanField(required=False) language = serializers.ChoiceField(choices=LANGUAGE_CHOICES, default='python') style = serializers.ChoiceField(choices=STYLE_CHOICES, default='friendly') # 给定经过验证的数据，创建并返回一个新的 Snippet 实例 def create(self, validated_data): return Snippet.objects.create(**validated_data) # 给定经过验证的数据，更新并返回一个已经存在的 Snippet 实例 def update(self, instance, validated_data): instance.title = validated_data.get('title', instance.title) instance.code = validated_data.get('code', instance.code) instance.linenos = validated_data.get('linenos', instance.linenos) instance.language = validated_data.get('language', instance.language) instance.style = validated_data.get('style', instance.style) instance.save() return instance create和update方法定义在调用serializer.save()时如何创建或修改完整的实例。 关于下面这行代码： code = serializers.CharField(style=&#123;'base_template':'textarea.html'&#125;) 暂时需要知道的就是它的功能是控制序列化器渲染到HTML页面时的的显示模板，至于为什么要这样做，是因为这对于控制如何显示可浏览的API特别有用，这将在后面的文章中看到。 使用序列化器首先进入shell模式： python manage.py shell 接下来的操作就和学习Django的orm时那样，创建并保存Snippet模型实例： &gt;&gt;&gt; from snippets.models import Snippet&gt;&gt;&gt; from snippets.serializers import SnippetSerializer&gt;&gt;&gt; from rest_framework.renderers import JSONRenderer&gt;&gt;&gt; from rest_framework.parsers import JSONParser&gt;&gt;&gt; snippet = Snippet(code='foo = "bar"\n')&gt;&gt;&gt; snippet.save()&gt;&gt;&gt; snippet = Snippet(code='print "hello, world"\n')&gt;&gt;&gt; snippet.save() 这个时候查看数据库就会发现相关的表中已经多了两行数据，就是我们刚才创建的数据： image 也可以继续在shell中查看： &gt;&gt;&gt; serializer = SnippetSerializer(snippet)&gt;&gt;&gt; serializer.data&#123;'code': 'print "hello, world"\n', 'title': '', 'linenos': False, 'style': 'friendly', 'language': 'python', 'id': 2&#125; 将数据渲染成json格式： &gt;&gt;&gt; content = JSONRenderer().render(serializer.data)&gt;&gt;&gt; contentb'&#123;"id":2,"title":"","code":"print \\"hello, world\\"\\n","linenos":false,"language":"python","style":"friendly"&#125;' 这里已经出现了json格式，也就是说这个json格式的数据就是要展示在某个URL上，大概可以感觉到，等下我们在访问某个URL时，会返回上面这堆数据供你使用，这其实就完成了一个序列化的过程，也可以看出客户端的功能雏形。 序列化是为了返回json格式的数据给客户端查看和使用数据，那么当客户端需要修改、增加或者删除数据时，就要把过程反过来了，也就是反序列化，把客户端提交的json格式的数据反序列化。 下面的代码把json数据流解析成Python自带的数据格式，便于我们后台Django的操作： &gt;&gt;&gt; from django.utils.six import BytesIO&gt;&gt;&gt; stream = BytesIO(content)&gt;&gt;&gt; data = JSONParser().parse(stream) 检查并保存数据： &gt;&gt;&gt; serializer = SnippetSerializer(data=data)&gt;&gt;&gt; serializer.is_valid()True&gt;&gt;&gt; serializer.validated_dataOrderedDict([('title', ''), ('code', 'print "hello, world"'), ('linenos', False), ('language', 'python'), ('style', 'friendly')])&gt;&gt;&gt; serializer.save()&lt;Snippet: Snippet object&gt; 这个时候查看数据库又多了一条数据： 使用 ModelSerializers在上面的SnippetSerializer类中，我们继承的是serializers.Serializer类，可以看到SnippetSerializer类中有很多代码其实是和models.py中的Snippet模型类似一样的，所以这里我们可以改进一下。就像在Django中提供了Form类和ModelForm类一样，django-rest-framework为我们提供了Serializer类和ModelSerializer类。利用它可以让我们的代码简洁很多，修改serializers.py： class SnippetSerializer(serializers.ModelSerializer): class Meta: model = Snippet fields = ('id', 'title', 'code', 'linenos', 'language', 'style') 我们可以通过在shell中的打印来检查序列化器实例中的所有字段： &gt;&gt;&gt; from snippets.serializers import SnippetSerializer&gt;&gt;&gt; serializer = SnippetSerializer()&gt;&gt;&gt; print(repr(serializer)) 打印后出现的效果如下（language非常长，只截取了一部分）： 在我们新的SnippetSerializer类中，可以发现和之前的对比代码少了很多，这里体现了ModelSerializer 类的快捷： 自动确定字段 create和update方法的简单默认实现 编写Django视图接下来要做的就是使用我们的新的Serializer类编写一些API视图。编辑snippets/views.py： 点击查看 from django.http import HttpResponse, JsonResponsefrom django.views.decorators.csrf import csrf_exemptfrom rest_framework.renderers import JSONRendererfrom rest_framework.parsers import JSONParserfrom snippets.models import Snippetfrom snippets.serializers import SnippetSerializer# Create your views here.@csrf_exemptdef snippet_list(request): """ 列出所有已经存在的snippet或者创建一个新的snippet """ if request.method == 'GET': snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return JsonResponse(serializer.data, safe=False) elif request.method == 'POST': data = JSONParser().parse(request) serializer = SnippetSerializer(data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data, status=201) return JsonResponse(serializer.errors, status=400)@csrf_exemptdef snippet_detail(request, pk): """ 检索查看、更新或者删除一个代码段 """ try: snippet = Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: return HttpResponse(status=404) if request.method == 'GET': serializer = SnippetSerializer(snippet) return JsonResponse(serializer.data) elif request.method == 'PUT': data = JSONParser().parse(request) serializer = SnippetSerializer(snippet, data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data) return JsonResponse(serializer.errors, status=400) elif request.method == 'DELETE': snippet.delete() return HttpResponse(status=204) 上面的代码都比较好理解，定义了不同http动作时后台不同的操作，在这里也体现了restful API的理念。 需要注意的是记得添加@csrf_exempt修饰器。 设计Django的urls为了让视图函数被调用，那当然需要设计一下url了，这里的处理和平时Django开发时是一样的。首先创建snippets/urls.py： from django.conf.urls import urlfrom snippets import viewsurlpatterns = [ url(r'^snippets/$', views.snippet_list), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)/$', views.snippet_detail),] 接着就是tutorial/urls.py，代码如下： from django.conf.urls import url, includeurlpatterns = [ url(r'^', include('snippets.urls')),] 对API进行测试完成了上面那些工作后，就可以开始测试了，退出shell模式并启动服务器，根据我们刚才设计的url发送请求，需要先安装httpie模块： pip install httpie 然后在命令行窗口访问，效果如下： 或者也可以直接在浏览输入网址访问。 到这里，也就实现了一个功能，当其他人访问这个URL时返回json格式的数据给他使用。 声明本篇文章来自ziv的博客，仅作整理学习分享。 点击这里访问原文]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django编写Restful-Api：请求与响应]]></title>
    <url>%2F2018%2F04%2F06%2FDjango%E7%BC%96%E5%86%99Restful-Api%EF%BC%9A%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[之前已经实现了访问指定URL就返回了指定的数据，这也体现了RESTful-API的一个理念，每一个URL代表着一个资源。当然RESTful API的另一个特性就是，发送不同的请求动作，会返还不同的响应。 Request对象平时我们在写Django的视图函数的时候，都会带上一个request参数，这样就能处理平时搭建网站时，浏览器访问网页时发出的常规的HttpRequest。但是现在我们导入了django-rest-framework，它能够对request进行拓展，并且提供更灵活的请求解析。这个特性体现在哪呢？请看下面这个例子： request.POST # 只能处理表单数据.只能处理POST请求request.data # 能处理各种数据。 可以处理'POST', 'PUT' 和 'PATCH'模式的请求 这个例子里面的注释已经说得很清楚，拓展后的request使用request.data就可以处理各种各样的请求了，而原本的request在处理时需要指定请求模式。 Response对象和request对象一样，django-rest-framewor也对其进行了很实用的拓展，在我上一篇文章的snippets/views.py中，我们导入了JsonResponse用于返回json格式的响应，在视图函数中是这样的： @csrf_exemptdef snippet_list(request): """ 列出所有已经存在的snippet或者创建一个新的snippet """ if request.method == 'GET': snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return JsonResponse(serializer.data, safe=False) elif request.method == 'POST': data = JSONParser().parse(request) serializer = SnippetSerializer(data=data) if serializer.is_valid(): serializer.save() return JsonResponse(serializer.data, status=201) return JsonResponse(serializer.errors, status=400) 也就是说，在return的时候就需要指明json格式，这样显得很不实用而且很单一，所以经过拓展后的Reponse对象就很方便了，它会根据客户端的请求头部信息来确定正确的内容类型以返回给客户端。只需如下代码： return Response(data) 状态码我们知道发送http请求时会返回各种各样的状态吗，但是都是简单的数字，比如200、404等，这些纯数字标识符有时候可能不够明确或者客户端在使用的时候不清楚错误信息甚至是没注意看不到，所以django-rest-framework也对此进行了优化，状态码会是HTTP_400_BAD_REQUEST、HTTP_404_NOT_FOUND这种，极大的提高可读性。 装饰API视图REST框架还提供了一个装饰器和一个类来包装视图函数，可以使用它们来写API视图，让程序能处理的情况更多。 @api_view装饰器用在基于视图的方法上。 APIView类用在基于视图的类上。 注意： 这里使用的是基于视图方法，所以使用的是装饰器@api_view，APIview这个类暂时不会提及。 这两个东西提供的一些功能，让我们省去很多工作，比如说确保你在视图中收到Request对象或在你的Response对象中添加上下文，这样就能实现内容通信。 另外装饰器可以在接收到输入错误的request.data时抛出ParseError异常，或者在适当的时候返回405 Method Not Allowed状态码。 改进代码上面说了这么多拓展和优化，接下来就把它们都使用起来，改进一下原本的snippets/views.py，程序如下： from rest_framework import status # 导入HHTP状态from rest_framework.decorators import api_view #导入装饰器from rest_framework.response import Response #导入应答from snippets.models import Snippet # 导入数据库类from snippets.serializers import SnippetSerializer # 导入之前写好的序列化函数@api_view(['GET', 'POST'])def snippet_list(request): """ 列出所有已经存在的snippet或者创建一个新的snippet """ if request.method == 'GET': snippets = Snippet.objects.all() serializer = SnippetSerializer(snippets, many=True) return Response(serializer.data) elif request.method == 'POST': serializer = SnippetSerializer(data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data, status=status.HTTP_201_CREATED) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) 可以看出，经过改进的代码已经把上面所说的几个django-rest-framework带来的特性都应用起来了，我们可以看出程序代码量变少，并且能处理的情况更多了。 比如说，在原本的视图函数snippet_detail中，处理&#39;PUT&#39;请求的时候，需要先解析json格式的数据再进一步处理： data = JSONParser().parse(request)serializer = SnippetSerializer(snippet, data=data) 也就是说需要分成两步实现，而且这里有一个限制就是只能解析json格式的数据流。而改进后的程序只需一行代码： serializer = SnippetSerializer(data=request.data) 直接使用之前说的request.data就可以获取到提交过来的数据了，并且可以处理各种数据和各种请求动作，方便了开发。 还有在return的时候也不需要指定json格式了，由原本的 return JsonResponse(serializer.data, status=201) 改成了 return Response(serializer.data,status=status.HTTP_201_CREATED) 这也意味着返回给客户端的可以是json或者html等格式的内容，返回HTML格式的内容的话，会在浏览器返回经过渲染的、更美观的页面。同时可以看出状态码也改进成了django-rest-framework给我们带来的可读性更高的状态标识码，以上这些措施都很大程度的提高了对客户的友好度。 对于另一个视图函数的修改也是同样的原理，这里就不做同样的讲解了，代码如下： @api_view(['GET', 'PUT', 'DELETE'])def snippet_detail(request, pk): """ Retrieve, update or delete a snippet instance. """ try: snippet = Snippet.objects.get(pk=pk) except Snippet.DoesNotExist: return Response(status=status.HTTP_404_NOT_FOUND) if request.method == 'GET': serializer = SnippetSerializer(snippet) return Response(serializer.data) elif request.method == 'PUT': serializer = SnippetSerializer(snippet, data=request.data) if serializer.is_valid(): serializer.save() return Response(serializer.data) return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST) elif request.method == 'DELETE': snippet.delete() return Response(status=status.HTTP_204_NO_CONTENT) 以上就是对原有的常规的Django视图函数的改进。 总结一下： 处理request提交过来的数据不需要一定是json格式的数据，返回的响应也不需要一定是json数据，也可以是经过渲染的HTML页面。稍后就会示范使用。 URL添加格式后缀既然上面已经说了返回给客户端的Response可是json或者是HTML等格式的内容，那么用户在使用的时候是如何指定返回哪种格式的内容呢，那就是在URL的最后加上后缀。比如http://127.0.0.1:8000/snippets.json，这样就是用户自己指定了返回json格式的Response，而不是我们在后台指定返回固定的格式。 只需对我们的程序稍加改进就可以了，在两个视图函数添加关键词参数format： def snippet_list(request, format=None): ... 以及 def snippet_detail(request, pk, format=None): ... 再修改一下snippets/urls.py，导入format_suffix_patterns（格式后缀模式）： from django.conf.urls import urlfrom rest_framework.urlpatterns import format_suffix_patternsfrom snippets import viewsurlpatterns = [ url(r'^snippets/$', views.snippet_list), url(r'^snippets/(?P&lt;pk&gt;[0-9]+)$', views.snippet_detail),]urlpatterns = format_suffix_patterns(urlpatterns) 测试Api首先当然还是可以像上一篇文章中那样的使用： http http://127.0.0.1:8000/snippets/ 通过设置Accept头部信息来控制返回的格式 http http://127.0.0.1:8000/snippets/ Accept:application/json # JSONhttp http://127.0.0.1:8000/snippets/ Accept:text/html # HTML 效果如下（返回的是页面的HTML代码，只展示了一部分）： 直接加格式后缀 http http://127.0.0.1:8000/snippets.json # JSON suffixhttp http://127.0.0.1:8000/snippets.api # Browsable API suffix 浏览器查看Api 我们可以直接在浏览器输入 http://127.0.0.1:8000/snippets.api 进行查看，会得到一个美观的页面： 实现功能增加数据我们可以控制 Content-Type 头部信息来提交POST请求： http --form POST http://127.0.0.1:8000/snippets/ code=&quot;print 123&quot;http --json POST http://127.0.0.1:8000/snippets/ code=&quot;print 456&quot; 它会自动在原有的数据后面添加你提交过去的数据，效果如下： 修改数据我们通过PUT来实现修改功能，在我们之前定义的函数views.snippet_detail中： url(r'^snippets/(?P&lt;pk&gt;[0-9]+)$', views.snippet_detail), 所以通过 url snippets/[id]就可以访问到我们要的数据，就可以对其进行修改。 http --json PUT http://127.0.0.1:8000/snippets/1.json code="sss" 删除数据同之前的修改一样，我们使用DELETE，通过 url snippets/[id]访问数据，提交删除。 http DELETE http://127.0.0.1:8000/snippets/8.json 这样我们就成功的删除了一条数据。 声明本篇文章来自ziv的博客，仅作整理学习分享。点击这里访问原文]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Restful-Api介绍]]></title>
    <url>%2F2018%2F04%2F04%2FRestful-Api%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[为了方便不同的前端设备与后端进行通信，这导致API构架的流行，甚至出现”API First”的设计思想。RESTful API是目前比较成熟的一套互联网应用程序的API设计理论。 Restful架构 点击这里查看 要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。 资源（Resources）REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 表现层（Representation）“资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 状态转化（State Transfer）访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 综述综合上面的解释，我们总结一下什么是RESTful架构： （1）每一个URI代表一种资源； （2）客户端和服务器之间，传递这种资源的某种表现层； （3）客户端通过HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 协议API与用户的通信协议，总是使用HTTPs协议。 域名应该尽量将API部署在专用域名之下。 https://api.example.com 如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。 https://example.org/api/ 版本（Versioning）应该将API的版本号放入URL。 https://api.example.com/v1/ 另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。 路径（Endpoint）路径又称”终点”（endpoint），表示API的具体网址。 在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。 例子有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。 https://api.example.com/v1/zooshttps://api.example.com/v1/animalshttps://api.example.com/v1/employees HTTP动词对于资源的具体操作类型，由HTTP动词表示。 常用的HTTP动词有下面五个（括号里是对应的SQL命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 还有两个不常用的HTTP动词。 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。 例子 例子 描述 GET /zoos 列出所有动物园 POST /zoos 新建一个动物园 GET /zoos/ID 获取某个指定动物园的信息 PUT /zoos/ID 更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID 更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID 删除某个动物园 GET /zoos/ID/animals 列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID 删除某个指定动物园的指定动物 过滤信息（Filtering）如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。 下面是一些常见的参数。 ?limit=10：指定返回记录的数量?offset=10：指定返回记录的开始位置。?page=2&amp;per_page=100：指定第几页，以及每页的记录数。?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 状态码（Status Codes）服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。 状态码的完全列表参见这里。 错误处理（Error handling）如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。 &#123; error: "Invalid API key"&#125; 返回结果针对不同操作，服务器向用户返回的结果应该符合以下规范。 GET /collection 返回资源对象的列表（数组）GET /collection/resource 返回单个资源对象POST /collection 返回新生成的资源对象PUT /collection/resource 返回完整的资源对象PATCH /collection/resource 返回完整的资源对象DELETE /collection/resource 返回一个空文档 Hypermedia APIRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。 比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。 &#123;"link": &#123; "rel": "collection https://www.example.com/zoos", "href": "https://api.example.com/zoos", "title": "List of zoos", "type": "application/vnd.yourformat+json"&#125;&#125; 上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。 Hypermedia API的设计被称为HATEOAS。Github的API就是这种设计，访问api.github.com会得到一个所有可用API的网址列表。 &#123; "current_user_url": "https://api.github.com/user", "authorizations_url": "https://api.github.com/authorizations", // ...&#125; 从上面可以看到，如果想获取当前用户的信息，应该去访问api.github.com/user，然后就得到了下面结果。 &#123; "message": "Requires authentication", "documentation_url": "https://developer.github.com/v3"&#125; 上面代码表示，服务器给出了提示信息，以及文档的网址。 其他（1）API的身份认证应该使用OAuth 2.0框架。 （2）服务器返回的数据格式，应该尽量使用JSON，避免使用XML。 声明本文来自阮一峰先生，仅作整理学习使用。 访问原文请点击这里。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Restful-Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax的介绍与实现方法]]></title>
    <url>%2F2018%2F04%2F02%2FAjax%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[AJAX翻译成中文就是“异步+Javascript+XML”。即使用Javascript语言与服务器进行异步交互，传输的数据为XML（当然，传输的数据不只是XML）。 Ajax特点1.异步传输同步与异步的区别 同步交互：客户端发出一个请求后，需要等待服务器响应结束后，才能发出第二个请求； 异步交互：客户端发出一个请求后，无需等待服务器响应结束，就可以发出第二个请求。 2.局部刷新并不是重新加载全部页面，仅仅加载需要加载的那一部分。这一特点给用户的感受是在不知不觉中完成请求和响应过程。 应用场景举例1.在百度搜索栏输入内容，会自动弹出联想输入内容提示： 2.注册账号的时候，输入已存在的用户名会给与提示： Ajax的优缺点优点 AJAX使用Javascript技术向服务器发送异步请求； AJAX无须刷新整个页面； 因为服务器响应内容不再是整个页面，而是页面中的局部，所以AJAX性能高； 缺点 AJAX并不适合所有场景，很多时候还是要使用同步交互； AJAX虽然提高了用户体验，但无形中向服务器发送的请求次数增多了，导致服务器压力增大； 因为AJAX是在浏览器中使用Javascript技术完成的，所以还需要处理浏览器兼容性问题； Ajax代码实现基于js的ajaxAJAX核心（XMLHttpRequest）其实AJAX就是在Javascript中多添加了一个对象：XMLHttpRequest对象。所有的异步交互都是使用XMLHttpServlet对象完成的。也就是说，我们只需要学习一个Javascript的新对象即可。 var xmlHttp = new XMLHttpRequest()；//（大多数浏览器都支持DOM2规范） 注意：各个浏览器对XMLHttpRequest的支持也是不同的！为了处理浏览器兼容问题，给出下面方法来创建XMLHttpRequest对象： function createXMLHttpRequest() &#123; var xmlHttp; // 适用于大多数浏览器，以及IE7和IE更高版本 try&#123; xmlHttp = new XMLHttpRequest(); &#125; catch (e) &#123; // 适用于IE6 try &#123; xmlHttp = new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e) &#123; // 适用于IE5.5，以及IE更早版本 try&#123; xmlHttp = new ActiveXObject("Microsoft.XMLHTTP"); &#125; catch (e)&#123;&#125; &#125; &#125; return xmlHttp; &#125; 实现流程步骤1: 打开与服务器的连接（open方法）当得到XMLHttpRequest对象后，就可以调用该对象的open()方法打开与服务器的连接了。open()方法的参数如下： open(method, url, async)： method：请求方式，通常为GET或POST；url：请求的服务器地址，例如：/ajaxdemo1/AServlet，若为GET请求，还可以在URL后追加参数；async：这个参数可以不给，默认值为true，表示异步请求； var xmlHttp = createXMLHttpRequest();xmlHttp.open(&quot;GET&quot;, &quot;/ajax_get/&quot;, true); 步骤2: 发送请求当使用open打开连接后，就可以调用XMLHttpRequest对象的send()方法发送请求了。send()方法的参数为POST请求参数，即对应HTTP协议的请求体内容，若是GET请求，需要在URL后连接参数。 注意：若没有参数，需要给出null为参数！若不给出null为参数，可能会导致FireFox浏览器不能正常发送请求！ xmlHttp.send(null); 步骤3: 接收服务器响应当请求发送出去后，服务器端就开始执行了，但服务器端的响应还没有接收到。接下来我们来接收服务器的响应。 XMLHttpRequest对象有一个onreadystatechange事件，它会在XMLHttpRequest对象的状态发生变化时被调用。下面介绍一下XMLHttpRequest对象的5种状态： 0：初始化未完成状态，只是创建了XMLHttpRequest对象，还未调用open()方法；1：请求已开始，open()方法已调用，但还没调用send()方法；2：请求发送完成状态，send()方法已调用；3：开始读取服务器响应；4：读取服务器响应结束。 onreadystatechange事件会在状态为1、2、3、4时引发。 下面代码会被执行四次！对应XMLHttpRequest的四种状态！ xmlHttp.onreadystatechange = function() &#123; alert('hello'); &#125;; 但通常我们只关心最后一种状态，即读取服务器响应结束时，客户端才会做出改变。我们可以通过XMLHttpRequest对象的readyState属性来得到XMLHttpRequest对象的状态。 xmlHttp.onreadystatechange = function() &#123; if(xmlHttp.readyState == 4) &#123; alert(&apos;hello&apos;); &#125; &#125;; 其实我们还要关心服务器响应的状态码是否为200，其服务器响应为404，或500，那么就表示请求失败了。我们可以通过XMLHttpRequest对象的status属性得到服务器的状态码。 最后，我们还需要获取到服务器响应的内容，可以通过XMLHttpRequest对象的responseText得到服务器响应内容。 xmlHttp.onreadystatechange = function() &#123; if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; alert(xmlHttp.responseText); &#125; &#125;; if 发送POST请求需要设置请求头：xmlHttp.setRequestHeader(“Content-Type”, “application/x-www-form-urlencoded”)； 注意 :form表单会默认这个键值对不设定，Web服务器会忽略请求体的内容。 在发送时可以指定请求体了：xmlHttp.send(“username=yuan&amp;password=123”) 测试代码 点击查看代码 &lt;h1&gt;AJAX&lt;/h1&gt;&lt;button onclick="send()"&gt;测试&lt;/button&gt;&lt;div id="div1"&gt;&lt;/div&gt;&lt;script&gt; function createXMLHttpRequest() &#123; try &#123; return new XMLHttpRequest();//大多数浏览器 &#125; catch (e) &#123; try &#123; return new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e) &#123; return new ActiveXObject("Microsoft.XMLHTTP"); &#125; &#125; &#125; function send() &#123; var xmlHttp = createXMLHttpRequest(); xmlHttp.onreadystatechange = function() &#123; if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; var div = document.getElementById("div1"); div.innerText = xmlHttp.responseText; div.textContent = xmlHttp.responseText; &#125; &#125;; xmlHttp.open("POST", "/ajax_post/", true); //post: xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); xmlHttp.send(null); //post: xmlHttp.send("b=B"); &#125;&lt;/script&gt; #--------------------------------views.py from django.views.decorators.csrf import csrf_exemptdef login(request): print('hello ajax') return render(request,'index.html')@csrf_exempt ＃csrf防御def ajax_post(request): print('ok') return HttpResponse('helloyuanhao') 基于jquery的ajax所有方法详情查看菜单中的附录。 点击查看代码 &#123;% load staticfiles %&#125;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="&#123;% static 'JS/jquery-3.1.1.js' %&#125;"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button class="send_Ajax"&gt;send_Ajax&lt;/button&gt;&lt;script&gt; //$.ajax的两种使用方式: //$.ajax(settings); //$.ajax(url,[settings]); $(".send_Ajax").click(function()&#123; $.ajax(&#123; url:"/handle_Ajax/", type:"POST", data:&#123;username:"Yuan",password:123&#125;, success:function(data)&#123; alert(data) &#125;, //=================== error============ error: function (jqXHR, textStatus, err) &#123; // jqXHR: jQuery增强的xhr // textStatus: 请求完成状态 // err: 底层通过throw抛出的异常对象，值与错误类型有关 console.log(arguments); &#125;, //=================== complete============ complete: function (jqXHR, textStatus) &#123; // jqXHR: jQuery增强的xhr // textStatus: 请求完成状态 success | error console.log('statusCode: %d, statusText: %s', jqXHR.status, jqXHR.statusText); console.log('textStatus: %s', textStatus); &#125;, //=================== statusCode============ statusCode: &#123; '403': function (jqXHR, textStatus, err) &#123; console.log(arguments); //注意：后端模拟errror方式：HttpResponse.status_code=500 &#125;, '400': function () &#123; &#125; &#125; &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; $.ajax方法这里仅介绍重点的几个参数，详细的参数，可以点开隐藏的参数表。点击查看参数表 参数表 名称 值/描述 async 布尔值，表示请求是否异步处理。默认是 true。 beforeSend(xhr) 发送请求前运行的函数。 cache 布尔值，表示浏览器是否缓存被请求页面。默认是 true。 complete(xhr,status) 请求完成时运行的函数（在请求成功或失败之后均调用，即在 success 和 error 函数之后）。 contentType 发送数据到服务器时所使用的内容类型。默认是：”application/x-www-form-urlencoded”。 context 为所有 AJAX 相关的回调函数规定 “this” 值。 data 规定要发送到服务器的数据。 dataFilter(data,type) 用于处理 XMLHttpRequest 原始响应数据的函数。 dataType 预期的服务器响应的数据类型。 error(xhr,status,error) 如果请求失败要运行的函数。 global 布尔值，规定是否为请求触发全局 AJAX 事件处理程序。默认是 true。 ifModified 布尔值，规定是否仅在最后一次请求以来响应发生改变时才请求成功。默认是 false。 jsonp 在一个 jsonp 中重写回调函数的字符串。 jsonpCallback 在一个 jsonp 中规定回调函数的名称。 password 规定在 HTTP 访问认证请求中使用的密码。 processData 布尔值，规定通过请求发送的数据是否转换为查询字符串。默认是 true。 scriptCharset 规定请求的字符集。 success(result,status,xhr) 当请求成功时运行的函数。 timeout 设置本地的请求超时时间（以毫秒计）。 traditional 布尔值，规定是否使用参数序列化的传统样式。 type 规定请求的类型（GET 或 POST）。 url 规定发送请求的 URL。默认是当前页面。 username 规定在 HTTP 访问认证请求中使用的用户名。 xhr 用于创建 XMLHttpRequest 对象的函数。 请求参数 data当前ajax请求要携带的数据，是一个json的object对象，ajax方法就会默认地把它编码成某种格式(urlencoded:?a=1&amp;b=2)发送给服务端；此外，ajax默认以get方式发送请求。 function testData() &#123; $.ajax(&quot;/test&quot;,&#123; //此时的data是一个json形式的对象 data:&#123; a:1, b:2 &#125; &#125;); //?a=1&amp;b=2 processData声明当前的data数据是否进行转码或预处理，默认为true，即预处理；if为false，那么对data：{a:1,b:2}会调用json对象的toString()方法，即{a:1,b:2}.toString() ,最后得到一个［object，Object］形式的结果。 contentType默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。用来指明当前请求的数据编码格式；urlencoded:?a=1&amp;b=2；如果想以其他方式提交数据，比如contentType:”application/json”，即向服务器发送一个json字符串： $.ajax(&quot;/ajax_get&quot;,&#123; data:JSON.stringify(&#123; a:22, b:33 &#125;), contentType:&quot;application/json&quot;, type:&quot;POST&quot;, &#125;); //&#123;a: 22, b: 33&#125; 注意：contentType:”application/json”一旦设定，data必须是json字符串，不能是json对象 traditional一般是我们的data数据有数组时会用到 ：data:{a:22,b:33,c:[&quot;x&quot;,&quot;y&quot;]},traditional为false会对数据进行深层次迭代； 响应参数 dataType预期服务器返回的数据类型,服务器端返回的数据会根据这个值解析后，传递给回调函数。默认不需要显性指定这个属性，ajax会根据服务器返回的content Type来进行转换；比如我们的服务器响应的content Type为json格式，这时ajax方法就会对响应的内容进行一个json格式的转换，if转换成功，我们在success的回调函数里就会得到一个json格式的对象；转换失败就会触发error这个回调函数。如果我们明确地指定目标类型，就可以使用data Type。 -dataType的可用值html｜xml｜json｜text｜script dataType实例 点击查看代码 from django.shortcuts import render,HttpResponsefrom django.views.decorators.csrf import csrf_exempt# Create your views here.import jsondef login(request): return render(request,'Ajax.html')def ajax_get(request): l=['alex','little alex'] dic=&#123;"name":"alex","pwd":123&#125; #return HttpResponse(l) #元素直接转成字符串alexlittle alex #return HttpResponse(dic) #字典的键直接转成字符串namepwd return HttpResponse(json.dumps(l)) return HttpResponse(json.dumps(dic))# 传到前端的是json字符串,要想使用,需要JSON.parse(data)//--------------------------------------------------- function testData() &#123; $.ajax('ajax_get', &#123; success: function (data) &#123; console.log(data); console.log(typeof(data)); //console.log(data.name); //JSON.parse(data); //console.log(data.name); &#125;, //dataType:"json", &#125; )&#125; 注解:Response Headers的content Type为text/html,所以返回的是String;但如果我们想要一个json对象,设定dataType:&quot;json&quot;即可,相当于告诉ajax方法把服务器返回的数据转成json对象发送到前端.结果为object。当然，return HttpResponse(json.dumps(a),content_type=&quot;application/json&quot;)这样就不需要设定dataType:&quot;json&quot;了。content_type=&quot;application/json&quot;和content_type=&quot;json&quot;是一样的！ 实例-用户名是否已被注册功能介绍在注册表单中，当用户填写了用户名后，把光标移开后，会自动向服务器发送异步请求。服务器返回true或false，返回true表示这个用户名已经被注册过，返回false表示没有注册过。 客户端得到服务器返回的结果后，确定是否在用户名文本框后显示“用户名已被注册”的错误信息！ 案例分析页面中给出注册表单；在username表单字段中添加onblur事件，调用send()方法；send()方法获取username表单字段的内容，向服务器发送异步请求，参数为username；django 的视图函数：获取username参数，判断是否为“yuan”，如果是响应true，否则响应false 参考代码 点击展开代码 &lt;script type=&quot;text/javascript&quot;&gt; function createXMLHttpRequest() &#123; try &#123; return new XMLHttpRequest(); &#125; catch (e) &#123; try &#123; return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); &#125; catch (e) &#123; return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125; &#125; &#125; function send() &#123; var xmlHttp = createXMLHttpRequest(); xmlHttp.onreadystatechange = function() &#123; if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; if(xmlHttp.responseText == &quot;true&quot;) &#123; document.getElementById(&quot;error&quot;).innerText = &quot;用户名已被注册！&quot;; document.getElementById(&quot;error&quot;).textContent = &quot;用户名已被注册！&quot;; &#125; else &#123; document.getElementById(&quot;error&quot;).innerText = &quot;&quot;; document.getElementById(&quot;error&quot;).textContent = &quot;&quot;; &#125; &#125; &#125;; xmlHttp.open(&quot;POST&quot;, &quot;/ajax_check/&quot;, true, &quot;json&quot;); xmlHttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); var username = document.getElementById(&quot;username&quot;).value; xmlHttp.send(&quot;username=&quot; + username); &#125;&lt;/script&gt;//--------------------------------------------------index.html&lt;h1&gt;注册&lt;/h1&gt;&lt;form action=&quot;&quot; method=&quot;post&quot;&gt;用户名：&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; onblur=&quot;send()&quot;/&gt;&lt;span id=&quot;error&quot;&gt;&lt;/span&gt;&lt;br/&gt;密 码：&lt;input type=&quot;text&quot; name=&quot;password&quot;/&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;&lt;/form&gt;//--------------------------------------------------views.pyfrom django.views.decorators.csrf import csrf_exemptdef login(request): print(&apos;hello ajax&apos;) return render(request,&apos;index.html&apos;) # return HttpResponse(&apos;helloyuanhao&apos;)@csrf_exemptdef ajax_check(request): print(&apos;ok&apos;) username=request.POST.get(&apos;username&apos;,None) if username==&apos;yuan&apos;: return HttpResponse(&apos;true&apos;) return HttpResponse(&apos;false&apos;) 附录jquery的ajax所有方法 方法 描述 $.ajax() 执行异步 AJAX 请求 $.ajaxPrefilter() 在每个请求发送之前且被 $.ajax() 处理之前，处理自定义 Ajax 选项或修改已存在选项 $.ajaxSetup() 为将来的 AJAX 请求设置默认值 $.ajaxTransport() 创建处理 Ajax 数据实际传送的对象 $.get() 使用 AJAX 的 HTTP GET 请求从服务器加载数据 $.getJSON() 使用 HTTP GET 请求从服务器加载 JSON 编码的数据 $.getScript() 使用 AJAX 的 HTTP GET 请求从服务器加载并执行 JavaScript $.param() 创建数组或对象的序列化表示形式（可用于 AJAX 请求的 URL 查询字符串） $.post() 使用 AJAX 的 HTTP POST 请求从服务器加载数据 ajaxComplete() 规定 AJAX 请求完成时运行的函数 ajaxError() 规定 AJAX 请求失败时运行的函数 ajaxSend() 规定 AJAX 请求发送之前运行的函数 ajaxStart() 规定第一个 AJAX 请求开始时运行的函数 ajaxStop() 规定所有的 AJAX 请求完成时运行的函数 ajaxSuccess() 规定 AJAX 请求成功完成时运行的函数 load() 从服务器加载数据，并把返回的数据放置到指定的元素中 serialize() 编码表单元素集为字符串以便提交 serializeArray() 编码表单元素集为names和values的数组]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis初识及使用]]></title>
    <url>%2F2018%2F03%2F30%2FRedis%E5%88%9D%E8%AF%86%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Redis是目前最火爆的内存数据库之一，通过在内存中读写数据，大大提高了读写速度，可以说Redis是实现网站高并发不可或缺的一部分。 Redis简介Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、 list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。与Memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave同步。 Redis的出现，很大程度补偿了Memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便,Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。 Redis操作导入import redis 连接方式redis模块提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类 r = redis.Redis(host='192.168.0.110', port=6379,db=0)r.set('name', 'zhangsan') #添加print (r.get('name')) #获取 连接池redis模块使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数 Redis，这样就可以实现多个Redis实例共享一个连接池。pool = redis.ConnectionPool(host='192.168.0.110', port=6379)r = redis.Redis(connection_pool=pool)r.set('name', 'zhangsan') #添加print (r.get('name')) #获取 发布和订阅首先定义一个RedisHelper类，连接Redis，定义频道为monitor，定义发布(publish)及订阅(subscribe)方法。 定义类class RedisHelper(object): def __init__(self): self.__conn = redis.Redis(host='192.168.0.110',port=6379)#连接Redis self.channel = 'monitor' #定义名称 def publish(self,msg):#定义发布方法 self.__conn.publish(self.channel,msg) return True def subscribe(self):#定义订阅方法 pub = self.__conn.pubsub() pub.subscribe(self.channel) pub.parse_response() return pub 发布者#发布from RedisHelper import RedisHelper obj = RedisHelper()obj.publish('hello')#发布 订阅者#订阅from RedisHelper import RedisHelper obj = RedisHelper()redis_sub = obj.subscribe()#调用订阅方法 while True: msg= redis_sub.parse_response() print (msg)]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据库</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django中Admin的使用]]></title>
    <url>%2F2018%2F03%2F29%2FDjango%E4%B8%ADAdmin%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[admin是django强大功能之一，它能从数据库中读取数据，呈现在页面中，进行管理。 创建超级用户在你所在的django项目路径下，输入代码： python manage.py createsupersuer 接下来，按照提示填写用户名，邮箱(可以为空)，密码，确认密码，这样我们就成功的创建好了一个超级用户。 之后，我们运行我们的项目： python mannage.py runserver 4000 这时在你的浏览器输入localhost:4000/admin/,就会弹出这样的界面。在里面输入你的账号密码，就可以进入django的管理界面：我们发现django已经给我们写好了用户组和用户的数据库，在这个页面可以用来添加用户和用户组。 注册数据库到admin使用register方法首先，在admin.py下导入所有的数据库 from blog.models import * 接下来，将想要显示在admin中的数据库注册到admin admin.site.register(UserInfo1)admin.site.register(UserType1) 使用register装饰器在你自定义的子类上面添加装饰器，表明这里的自定义内容时对应你的哪张表的。@admin.register(UserInfo1)class MyAdmin(admin.ModelAdmin): pass 刷新我们的网页，就可以看到我们自己建的数据库了 添加其他功能修改表单显示默认这里显示的都是UserInfo1，根本看不出，更不谈管理，那么我们如何修改这里显示的内容呢 很简单，在我们在models中创建表格的时候，自定义一个__str__函数，就可以自定义显示字段。 def __str__(self): return self.username 修改表单显示多个字段这需要我们在admin中创建一个admin.ModelAdmin的子类，然后在注册表单的时候，将这个参数加上就可以了。 class MyAdmin(admin.ModelAdmin): list_display = ("username", "age", "user_type")admin.site.register(UserInfo1, MyAdmin) 刷新页面，发现我们想要的已经显示出来了 添加搜索功能数据量不大的时候，找想要的很方便，但数据量增大的时候，查找功能就必不可少了。添加方法，和上面一样在子类里面添加 search_fields = ("username","user_type") 右侧的参数，则是添加查找内容的范围。 添加筛选功能list_filter = ('username', ) 其他需求修改语言为中文在settings里面将LANGUAGE_CODE字段的值改为zh-hans LANGUAGE_CODE = 'zh-hans' 用户权限控制定制加载的列表, 根据不同的人显示不同的内容列表。 例如：如果是超级管理员就列出所有的，如果不是，就仅列出访问者自己相关的。 class MyModelAdmin(admin.ModelAdmin): def get_queryset(self, request): qs = super(MyModelAdmin, self).get_queryset(request) if request.user.is_superuser: return qs else: return qs.filter(author=request.user) ——— 未完待续 ———]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调用CMD方法]]></title>
    <url>%2F2018%2F03%2F28%2F%E8%B0%83%E7%94%A8CMD%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python调用cmd的各种实现方法及优点与缺点。 使用os.system(“cmd”)这是最简单的一种方法，特点是执行的时候程序会打出cmd在linux上执行的信息。使用前需要import os。 os.system("ls") 使用Popen模块产生新的process现在大部分人都喜欢使用Popen。Popen方法不会打印出cmd在linux上执行的信息。的确，Popen非常强大，支持多种参数和模式。使用前需要from subprocess import Popen, PIPE。 Popen函数缺陷它是一个阻塞的方法。如果运行cmd时产生的内容非常多，函数非常容易阻塞住。 解决办法：是不使用wait()方法，但是也不能获得执行的返回值了。 语法subprocess.Popen(args, bufsize=0, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=False, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0) 点击这里，查看具体参数 参数 描述 args 可以是字符串或者序列类型（如：list，元组），用于指定进程的可执行文件及其参数。如果是序列类型，第一个元素通常是可执行文件的路径。我们也可以显式的使用executeable参数来指定可执行文件的路径。 bufsize 指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲(全缓冲) stdin, stdout, stderr 分别表示程序的标准输入、输出、错误句柄。他们可以是PIPE，文件描述符或文件对象，也可以设置为None，表示从父进程继承。 preexec_fn 只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用。 Close_sfs 在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。我们不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。 shell 设为true，程序将通过shell来执行。 cwd 用于设置子进程的当前目录 env 是字典类型，用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。 Universal_newlines 不同操作系统下，文本的换行符是不一样的。如：windows下用’/r/n’表示换，而Linux下用’/n’。如果将此参数设置为True，Python统一把这些换行符当作’/n’来处理。startupinfo与createionflags只在windows下用效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 startupinfo，createionflags 只在windows下有效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等。 subprocess.PIPE在创建Popen对象时，subprocess.PIPE可以初始化stdin, stdout或stderr参数，表示与子进程通信的标准流。 subprocess.STDOUT创建Popen对象时，用于初始化stderr参数，表示将错误通过标准输出流输出。 Popen的方法Popen.poll()用于检查子进程是否已经结束。设置并返回returncode属性。 Popen.wait()等待子进程结束。设置并返回returncode属性。 Popen.communicate(input=None) 与子进程进行交互。向stdin发送数据，或从stdout和stderr中读取数据。可选参数input指定发送到子进程的参数。 Communicate()返回一个元组：(stdoutdata, stderrdata)。注意：如果希望通过进程的stdin向其发送数据，在创建Popen对象的时候，参数stdin必须被设置为PIPE。同样，如 果希望从stdout和stderr获取数据，必须将stdout和stderr设置为PIPE。 Popen.send_signal(signal)向子进程发送信号。 Popen.terminate()停止(stop)子进程。在windows平台下，该方法将调用Windows API TerminateProcess（）来结束子进程。 Popen.kill()杀死子进程。 Popen.stdin()如果在创建Popen对象是，参数stdin被设置为PIPE，Popen.stdin将返回一个文件对象用于策子进程发送指令。否则返回None。 Popen.stdout()如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。 Popen.stderr ()如果在创建Popen对象是，参数stdout被设置为PIPE，Popen.stdout将返回一个文件对象用于策子进程发送指令。否则返回 None。 Popen.pid()获取子进程的进程ID。 Popen.returncode ()获取进程的返回值。如果进程还没有结束，返回None。 p = Popen("cp -rf a/* b/", shell=True, stdout=PIPE, stderr=PIPE) p.wait() if p.returncode != 0: print ("Error.") return -1 END 使用commands.getstatusoutput方法这个方法也不会打印出cmd在linux上执行的信息。这个方法唯一的优点是，它不是一个阻塞的方法。即没有Popen函数阻塞的问题。使用前需要import commands。 import commandsstatus, output = commands.getstatusoutput("ls") 还有只获得output和status的方法： commands.getoutput("ls") commands.getstatus("ls")]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORM的F与Q查找]]></title>
    <url>%2F2018%2F03%2F28%2FORM%E4%B8%ADF%E4%B8%8EQ%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[有时候靠单一的关键字参数查询已经很难满足查询要求，此时就需要ORM的F和Q查询。 导入from django.db.models import Ffrom django.db.models import Q F查询 F查询——专门取对象中某列值的操作，不可使用__双下划线 # 对于book表中每本书的价格都在原价格的基础上增加20元models.Book.objects.update(price=F("price")+20) 取到Book书中price一列值，并对每个值进行＋20的操作 Q查询 Q查询——对对象的复杂查询 filter() 等方法中的关键字参数查询都是相当于进行“AND” 操作的。 如果你需要执行更复杂的查询（例如OR语句），你可以使用Q对象。 关键字封装#1 Q对象可以对关键字参数进行封装，从而更好地应用多个查询q1=models.Book.objects.filter(Q(title__startswith='P')).all()print(q1)#[&lt;Book: Python&gt;, &lt;Book: Perl&gt;] 使用操作符# 可以组合使用&amp;,|操作符，当一个操作符是用于两个Q的对象,它产生一个新的Q对象。Q(title__startswith='P') | Q(title__startswith='J')# Q对象可以用~操作符放在前面表示否定，也可允许否定与不否定形式的组合Q(title__startswith='P') | ~Q(pub_date__year=2015) 可使用Q对象的方法 filter() exclude() get() 注意事项Q对象可以与关键字参数查询一起使用，不过一定要把Q对象放在关键字参数查询的前面。 # 正确：Book.objects.get( Q(pub_date=date(2015, 5, 2)) | Q(pub_date=date(2005, 5, 6)), title__startswith='P')# 错误：Book.objects.get( question__startswith='P', Q(pub_date=date(2015, 5, 2)) | Q(pub_date=date(2005, 5, 6)))]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORM分组与聚合查询]]></title>
    <url>%2F2018%2F03%2F27%2FORM%E5%88%86%E7%BB%84%E4%B8%8E%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[详解ORM的分组查询和聚合查询。 导入from django.db.models import Avg,Min,Sum,Max 方法 描述 Avg 平均值 Min 最小值 Sum 求和 Max 最大值 聚合查询aggregate(*args,**kwargs) 通过对QuerySet进行计算，返回一个聚合值的字典。aggregate()中每一个参数都指定一个包含在字典中的返回值。即在查询集上生成聚合。 比如，你想要计算所有在售书的平均价钱。首先拿到所有的书的QuerySet对象，使用aggregate()函数直接拿到平均值。&gt;&gt;&gt; Book.objects.all().aggregate(Avg('price'))&#123;'price__avg': 34.35&#125; aggregate()子句的参数描述了我们想要计算的聚合值，在这个例子中，是Book模型中price字段的平均值。 aggregate()是QuerySet 的一个终止子句，意思是说，它返回一个包含一些键值对的字典。键的名称是聚合值的标识符，值是计算出来的聚合值。键的名称是按照字段和聚合函数的名称自动生成出来的。 当然我们也可以自己定义键名： &gt;&gt;&gt; Book.objects.aggregate(average_price=Avg('price'))&#123;'average_price': 34.35&#125; 并且从上面的语法看，这个方法是可以接受多个方法参数的，也就是说，我们可以同时使用最大值，最小值，总和等方法作为参数： &gt;&gt;&gt; Book.objects.aggregate(Avg('price'), Max('price'), Min('price'))&#123;'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')&#125; 分类查询语法annotate(*args,**kwargs): 可以通过计算查询结果中每一个对象所关联的对象集合，从而得出总计值(也可以是平均值或总和)，即为查询集的每一项生成聚合。 假设我们现在的需求是按照作者的名字分组： &gt;&gt;&gt; Book.objects.values('authors__name').annotate(Max('price'))&lt;QuerySet [&#123;'authors__name': 'x1', 'price__max': Decimal('100.00')&#125;,&#123;'authors__name': 'x2', 'price__max': Decimal('100.00')&#125;,&#123;'authors__name': 'x3', 'price__max': Decimal('100.00')&#125;]&gt; 总结 聚合是aggreate()，通过QuerySet 进行计算。做求值运算的时候使用。 分组是annotate()，括号里是条件，遇到每什么什么的时候就要分组。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八种常用排序算法]]></title>
    <url>%2F2018%2F03%2F26%2F%E5%85%AB%E7%A7%8D%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基于python实现了冒泡排序、希尔排序、插入排序、快速排序、直接选择排序、堆排序、归并排序、基数排序。 冒泡排序描述重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 代码实现# 冒泡排序def bubble_sort(lists): count = len(lists) for i in range(0, count): for j in range(i + 1, count): if lists[i] &gt; lists[j]: lists[i], lists[j] = lists[j], lists[i] return lists 插入排序描述插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。 代码实现# 插入排序def insert_sort(lists): count = len(lists) for i in range(1, count): key = lists[i] j = i - 1 while j &gt;= 0: if lists[j] &gt; key: lists[j + 1] = lists[j] lists[j] = key j -= 1 return lists 希尔排序描述希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。 希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 # 希尔排序def shell_sort(lists): count = len(lists) step = 2 group = count / step while group &gt; 0: for i in range(0, group): j = i + group while j &lt; count: k = j - group key = lists[j] while k &gt;= 0: if lists[k] &gt; key: lists[k + group] = lists[k] lists[k] = key k -= group j += group group /= step return lists 快速排序描述通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 代码实现# 快速排序def quick_sort(lists, left, right): if left &gt;= right: return lists key = lists[left] low = left high = right while left &lt; right: while left &lt; right and lists[right] &gt;= key: right -= 1 lists[left] = lists[right] while left &lt; right and lists[left] &lt;= key: left += 1 lists[right] = lists[left] lists[right] = key quick_sort(lists, low, left - 1) quick_sort(lists, left + 1, high) return lists 直接选择排序描述基本思想：第1趟，在待排序记录r1 ~ r[n]中选出最小的记录，将它与r1交换；第2趟，在待排序记录r2 ~ r[n]中选出最小的记录，将它与r2交换；以此类推，第i趟在待排序记录r[i] ~ r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。 代码实现def select_sort(lists): # 选择排序 count = len(lists) for i in range(0, count): min = i for j in range(i + 1, count): if lists[min] &gt; lists[j]: min = j lists[min], lists[i] = lists[i], lists[min] return lists 堆排序描述堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。在数组的非降序排序中，需要使用的就是大根堆，因为根据大根堆的要求可知，最大的值一定在堆顶。 代码实现def adjust_heap(lists, i, size): lchild = 2 * i + 1 rchild = 2 * i + 2 max = i if i &lt; size / 2: if lchild &lt; size and lists[lchild] &gt; lists[max]: max = lchild if rchild &lt; size and lists[rchild] &gt; lists[max]: max = rchild if max != i: lists[max], lists[i] = lists[i], lists[max] adjust_heap(lists, max, size)def build_heap(lists, size): for i in range(0, (size/2))[::-1]: adjust_heap(lists, i, size)def heap_sort(lists): size = len(lists) build_heap(lists, size) for i in range(0, size)[::-1]: lists[0], lists[i] = lists[i], lists[0] adjust_heap(lists, 0, i) 归并排序描述归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。 代码实现def merge(left, right): i, j = 0, 0 result = [] while i &lt; len(left) and j &lt; len(right): if left[i] &lt;= right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result += left[i:] result += right[j:] return resultdef merge_sort(lists): # 归并排序 if len(lists) &lt;= 1: return lists num = len(lists) / 2 left = merge_sort(lists[:num]) right = merge_sort(lists[num:]) return merge(left, right) 基数排序描述基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。 代码实现import mathdef radix_sort(lists, radix=10): k = int(math.ceil(math.log(max(lists), radix))) bucket = [[] for i in range(radix)] for i in range(1, k+1): for j in lists: bucket[j/(radix**(i-1)) % (radix**i)].append(j) del lists[:] for z in bucket: lists += z del z[:] return lists 声明本文来自十三号线上的蝼蚁，仅作整理学习，后续会添加每一种排序的详解。 访问原文请点击这里。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django数据库操作]]></title>
    <url>%2F2018%2F03%2F25%2FDjango%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[在这里介绍了ORM的概念和优缺点，和基于ORM的数据库操作之增删改查。以及一对一操作，一对多操作，多对多操作。 ORM的概念 点击查看详细介绍 ORM：Object Relational Mapping(对象关系映射) 让我们从O/R开始。字母O起源于”对象”(Object),而R则来自于”关系”(Relational)。几乎所有的程序里面，都存在对象和关系数据库。在业务逻辑层和用户界面层中，我们是面向对象的。当对象信息发生变化的时候，我们需要把对象的信息保存在关系数据库中。 当你开发一个应用程序的时候(不使用O/R Mapping),你可能会写不少数据访问层的代码，用来从数据库保存，删除，读取对象信息，等等。你在DAL中写了很多的方法来读取对象数据，改变状态对象等等任务。而这些代码写起来总是重复的。 ORM解决的主要问题是对象关系的映射。域模型和关系模型分别是建立在概念模型的基础上的。域模型是面向对象的，而关系模型是面向关系的。一般情况下，一个持久化类和一个表对应，类的每个实例对应表中的一条记录，类的每个属性对应表的每个字段。 ORM技术特点 提高了开发效率。由于ORM可以自动对Entity对象与数据库中的Table进行字段与属性的映射，所以我们实际可能已经不需要一个专用的、庞大的数据访问层。 ORM提供了对数据库的映射，不用sql直接编码，能够像操作对象一样从数据库获取数据。 ORM的缺点ORM的缺点是会牺牲程序的执行效率和会固定思维模式。从系统结构上来看,采用ORM的系统一般都是多层系统，系统的层次多了，效率就会降低。ORM是一种完全的面向对象的做法，而面向对象的做法也会对性能产生一定的影响。 但ORM是一种工具，工具确实能解决一些重复，简单的劳动。这是不可否认的。 在models里面创建一张表，下面的都是基于这张表的操作。 class UserInfo(models.Model): username = models.CharField(max_length=64) sex = models.CharField(max_length=64) mail = models.CharField(max_length=64) 导入from blog import models ORM之增(create,save)这里推荐使用第三种方式# 增 # 第一种方式 models.UserInfo.objects.create(username=&apos;zsy1&apos;, sex=&apos;girl&apos;, mail=&apos;love.com&apos;) # 第二种方式 obj = models.UserInfo(username=&apos;zsy2&apos;, sex=&apos;girl&apos;, mail=&apos;love.com&apos;) obj.save() # 第三种方式 user1 = &#123;&apos;username&apos;: &apos;zsy3&apos;, &apos;sex&apos;: &apos;girl&apos;, &apos;mail&apos;: &apos;love.com&apos;&#125; models.UserInfo.objects.create(**user1) return HttpResponse(&quot;已增加&quot;) ORM之删# 删 # 删除所有 models.UserInfo.objects.all().delete() # 删除id=11的项 models.UserInfo.objects.filter(id=11).delete() return HttpResponse(&quot;已删除&quot;) ORM之改推荐使用update# 改 # 方式1 update() models.UserInfo.objects.all().update(mail=8888) models.UserInfo.objects.filter(id=12).update(mail=888888) # 方式2 obj.save() user2 = models.UserInfo.objects.get(id=12) user2.sex = &apos;woman&apos; user2.save() return HttpResponse(&quot;已修改&quot;) ORM之查# 查 # 查询所有，为QuerySet类型，可理解成列表 result = models.UserInfo.objects.all() # 条件查询：filter 相当于where查询条件，里面的&quot;，&quot;会组成and条件 result = models.UserInfo.objects.filter(username=&quot;zsy2&quot;) # 查看Query执行过程： print(result.query) # 循环打印，点号取属性值 for row in result: # 打印查询到数据。 print(row.id, row.username, row.sex) return HttpResponse(&quot;已查找&quot;) 上面的一对一翻篇了，接下来我们学习下一对多和多对多，而我们又可以把一对多，多对多，分为正向和反向查找两种方式。这里我们创建了两张表，在models中： class UserType1(models.Model): caption = models.CharField(max_length=32) class UserInfo1(models.Model): username = models.CharField(max_length=32) age = models.IntegerField() user_type = models.ForeignKey(&apos;UserType&apos;)#外键 之后再命令行执行：python manage.py makemigrationspython manage.py migrate 这样我们就创建了两张空表： 正查与反查这里ForeignKey在 UserInfo表中正向查找：如果从UserInfo表开始向其他的表进行查询，这个就是正向查询。反向查询：如果从UserType表去查询其他的表这个就是反向操作。 ORM之一对多增加数据这里对user_type赋值，有两种方法：第一种方式：再次查询数据库，不推荐 user_type = models.UserInfo1.objects.filter(id=1).first() 第二种方式：通过 外键字段_id user_tyoe_id = 1 所以我们使用第二种创建数据： dic = &#123;'username': 'mosson', 'age': 18, 'user_type_id': 1&#125;models.UserInfo1.objects.create(**dic)return HttpResponse('OK') 查询数据获取到的数据类型本质上都是 queryset类型，类似于列表，内部有3种表现形式（对象，字典，列表） # &lt;QuerySet [&lt;表名: 表 object&gt;, &lt;表名: 表 object&gt;]&gt;modle.UserInfo1.objects.all() 注意：这里使用双下划线跨表取键值 # &lt;QuerySet [&#123;&apos;xx&apos;: &apos;xx&apos;, &apos;xx&apos;: x&#125;, &#123;&apos;xx&apos;: &apos;x&apos;, &apos;xx&apos;: x&#125;]&gt;modle.UserInfo1.objects.values(&apos;当前表键名&apos;，&apos;跨表__键名&apos;) # &lt;QuerySet [(&apos;xx&apos;, x), (&apos;xx&apos;, x)]&gt;modle.UserInfo1.objects.values_list(&apos;当前表键名&apos;，&apos;跨表__键名&apos;) 正向查询例子通过UserInfo1查询：ret = models.UserInfo1.objects.filter(user_type__caption=&apos;COO&apos;)print(ret)for item in ret: print(item,item.username,item.age,item.user_type.caption)return HttpResponse(&quot;OK&quot;) 反向查询通过UserType1查询：方法一：ret = models.UserType.objects.filter(caption=&apos;COO&apos;).values(&apos;userinfo__username&apos;) for item in ret: print(item,type(item)) ret = models.UserType.objects.filter(caption=&apos;COO&apos;).first() for item in ret.userinfo_set.all(): print(item.username) 总结 正向查找： filter（跨表的时候，应该是对象__跨表的字段） 获取这个值的时候，拿到了一行数据的时候 line.对象.跨表的字段 反向查找： filter（关联这个表的表明） 自动创建和表明相同的对象，通过这个对象__跨表的字段 line.自动创建和表明相同的对象_set.方法 ORM之多对多首先需要说明的是： 多对多和一对多没有任何关系 创建 方式一：自定义关系表 class HostToApp(models.Model): hobj = models.ForeignKey(to=&apos;Host&apos;,to_field=&apos;nid&apos;) aobj = models.ForeignKey(to=&apos;Application&apos;,to_field=&apos;id&apos;) 方式二：自动创建关系表表中添加 ManyToManyField class Application(models.Model): name = models.CharField(max_length=32) d = models.ManyToManyField(&quot;Host&quot;) ——— 未完待续 ———]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
        <tag>ORM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django数据库配置]]></title>
    <url>%2F2018%2F03%2F24%2FDjango%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[关于Django配置数据库的过程和配置python3配置mysql中需要注意的事情。 数据库选择django默认支持sqlite，mysql, oracle,postgresql数据库。 sqlitedjango默认使用sqlite的数据库，默认自带sqlite的数据库驱动引擎名称：django.db.backends.sqlite3 mysql引擎名称：django.db.backends.mysql mysql驱动程序 MySQLdb(mysql python) mysqlclient MySQL PyMySQL(纯python的mysql驱动程序) 数据库的设置sqlite设置在django的项目中会默认使用sqlite数据库，在settings里有如下设置： DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.sqlite3', 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), &#125;&#125; mysql设置如果我们想要更改数据库为mysql，需要在settings中修改如下： DATABASES = &#123; &apos;default&apos;: &#123; &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;, &apos;NAME&apos;: &apos;mydatabase&apos;, &apos;USER&apos;: &apos;mydatabaseuser&apos;, &apos;PASSWORD&apos;: &apos;mypassword&apos;, &apos;HOST&apos;: &apos;127.0.0.1&apos;, &apos;PORT&apos;: &apos;3306&apos;, &#125; &#125; 配置表 参数 描述 NAME 指定的数据库名，如果是sqlite的话，就需要填数据库文件的绝对位置 USER 数据库登录的用户名，mysql一般都是root PASSWORD 登录数据库的密码，必须是USER用户所对应的密码 HOST 由于一般的数据库都是C/S结构的，所以得指定数据库服务器的位置，我们一般数据库服务器和客户端都是在一台主机上面，所以一般默认都填127.0.0.1 PORT 数据库服务器端口，mysql默认为3306,注意类型为str. HOST和PORT都可以不填，使用默认的配置，但是如果你有更改默认配置的话，就需要填入更改后的 遇到的坑设置完后，再启动我们的Django项目前，我们需要激活我们的mysql。 然后，启动项目，会报错： no module named MySQLdb 这是因为django默认你导入的驱动是MySQLdb，可是MySQLdb对于py3有很大问题，所以我们需要的驱动是PyMySQL.所以，我们只需要找到项目名文件下的init,在里面写入： import pymysqlpymysql.install_as_MySQLdb() 对了，还有个坑要说下，windows安装mysql需要visual c++ redistributable packages for visual studio 2013组件，否则mysql server是装不上的。vc++ 2013 redistributable 官方下载地址需要注意的是：x86和x64组件都需要安装！ 如果已经你电脑以前安装过，但还是不能安装，下载完成后，双击运行点击修复。]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django模板语言]]></title>
    <url>%2F2018%2F03%2F22%2FDjango%E6%A8%A1%E6%9D%BF%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[Django模板是一个string文本，它用来分离一个文档的展现和数据。模板定义了placeholder和表示多种逻辑的tags来规定文档如何展现，通常模板用来输出HTML，但是Django模板也能生成其它基于文本的形式。 ◇◆◇◆◇### 变量 变量的引用&#123;&#123; 变量名 &#125;&#125; Template和Context对象点击这里，查看例子 &gt;&gt;&gt; python manage.py shell (进入该django项目的环境)&gt;&gt;&gt; from django.template import Context, Template&gt;&gt;&gt; t = Template(&apos;My name is &#123;&#123; name &#125;&#125;.&apos;)&gt;&gt;&gt; c = Context(&#123;&apos;name&apos;: &apos;Stephane&apos;&#125;)&gt;&gt;&gt; t.render(c)&apos;My name is Stephane.&apos;# 同一模板，多个上下文，一旦有了模板对象，你就可以通过它渲染多个context，无论何时我们都可以# 像这样使用同一模板源渲染多个context，只进行 一次模板创建然后多次调用render()方法渲染会# 更为高效：# Lowfor name in (&apos;John&apos;, &apos;Julie&apos;, &apos;Pat&apos;): t = Template(&apos;Hello, &#123;&#123; name &#125;&#125;&apos;) print t.render(Context(&#123;&apos;name&apos;: name&#125;))# Goodt = Template(&apos;Hello, &#123;&#123; name &#125;&#125;&apos;)for name in (&apos;John&apos;, &apos;Julie&apos;, &apos;Pat&apos;): print t.render(Context(&#123;&apos;name&apos;: name&#125;)) 变量的查找我们通过 context 传递的简单参数值主要是字符串，然而，模板系统能够非常简洁地处理更加复杂的数据结构，例如list、dictionary和自定义的对象。在 Django 模板中遍历复杂数据结构的关键是句点字符 .点击这里，查看例子 # 首先，句点可用于访问列表索引，例如：&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; t = Template('Item 2 is &#123;&#123; items.2 &#125;&#125;.')&gt;&gt;&gt; c = Context(&#123;'items': ['apples', 'bananas', 'carrots']&#125;)&gt;&gt;&gt; t.render(c)'Item 2 is carrots.'#假设你要向模板传递一个 Python 字典。 要通过字典键访问该字典的值，可使用一个句点：&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; person = &#123;'name': 'Sally', 'age': '43'&#125;&gt;&gt;&gt; t = Template('&#123;&#123; person.name &#125;&#125; is &#123;&#123; person.age &#125;&#125; years old.')&gt;&gt;&gt; c = Context(&#123;'person': person&#125;)&gt;&gt;&gt; t.render(c)'Sally is 43 years old.'#同样，也可以通过句点来访问对象的属性。 比方说， Python 的 datetime.date 对象有#year 、 month 和 day 几个属性，你同样可以在模板中使用句点来访问这些属性：&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; import datetime&gt;&gt;&gt; d = datetime.date(1993, 5, 2)&gt;&gt;&gt; d.year&gt;&gt;&gt; d.month&gt;&gt;&gt; d.day&gt;&gt;&gt; t = Template('The month is &#123;&#123; date.month &#125;&#125; and the year is &#123;&#123; date.year &#125;&#125;.')&gt;&gt;&gt; c = Context(&#123;'date': d&#125;)&gt;&gt;&gt; t.render(c)'The month is 5 and the year is 1993.'# 这个例子使用了一个自定义的类，演示了通过实例变量加一点(dots)来访问它的属性，这个方法适# 用于任意的对象。&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; class Person(object):... def __init__(self, first_name, last_name):... self.first_name, self.last_name = first_name, last_name&gt;&gt;&gt; t = Template('Hello, &#123;&#123; person.first_name &#125;&#125; &#123;&#123; person.last_name &#125;&#125;.')&gt;&gt;&gt; c = Context(&#123;'person': Person('John', 'Smith')&#125;)&gt;&gt;&gt; t.render(c)'Hello, John Smith.'# 点语法也可以用来引用对象的方法。 例如，每个 Python 字符串都有 upper() 和 isdigit()# 方法，你在模板中可以使用同样的句点语法来调用它们：&gt;&gt;&gt; from django.template import Template, Context&gt;&gt;&gt; t = Template('&#123;&#123; var &#125;&#125; -- &#123;&#123; var.upper &#125;&#125; -- &#123;&#123; var.isdigit &#125;&#125;')&gt;&gt;&gt; t.render(Context(&#123;'var': 'hello'&#125;))'hello -- HELLO -- False'&gt;&gt;&gt; t.render(Context(&#123;'var': '123'&#125;))'123 -- 123 -- True'# 注意这里调用方法时并* 没有* 使用圆括号 而且也无法给该方法传递参数；你只能调用不需参数的 标签if/else 标签&#123;% if condition1 %&#125; ... display 1&#123;% elif condiiton2 %&#125; ... display 2&#123;% else %&#125; ... display 3&#123;% endif %&#125; if 标签接受 and ， or 或者 not 关键字来对多个变量做判断 ，或者对变量取反（ not ).注意： if 标签不允许在同一个标签中同时使用 and 和 or ，因为逻辑上可能模糊的，这样的代码是不合法的： &#123;% if athlete_list and coach_list or cheerleader_list %&#125; 系统不支持用圆括号来组合比较操作。 如果你确实需要用到圆括号来组合表达你的逻辑式，考虑将它移到模板之外处理，然后以模板变量的形式传入结果吧。 或者，仅仅用嵌套的if标签替换. for 标签 for 允许我们在一个序列上迭代，循环语法是 for X in Y ，Y是要迭代的序列而X是在每一个特定的循环中使用的变量名称。每一次循环中，模板系统会渲染在 for 和 endfor 之间的所有内容。 &lt;ul&gt;&#123;% for athlete in athlete_list %&#125; &lt;li&gt;&#123;&#123; athlete.name &#125;&#125;&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 反向迭代给标签增加一个 reversed 使得该列表被反向迭代：&#123;% for athlete in athlete_list reversed %&#125; empty分句for 标签支持一个可选的empty 分句，通过它我们可以定义当列表为空时的输出内容。 &#123;% for athlete in athlete_list %&#125; &lt;p&gt;&#123;&#123; athlete.name &#125;&#125;&lt;/p&gt;&#123;% empty %&#125; &lt;p&gt;There are no athletes. Only computer programmers.&lt;/p&gt;&#123;% endfor %&#125; 退出循环Django不支持退出循环操作。 如果我们想退出循环，可以改变正在迭代的变量，让其仅仅包含需要迭代的项目。 同理，Django也不支持continue语句，我们无法让当前迭代操作跳回到循环头部。 forloop变量在每个for循环里有一个称为forloop 的模板变量。这个变量有一些提示循环进度信息的属性。forloop 变量仅仅能够在循环中使用。 在模板解析器碰到endfor标签后，forloop就不可访问了。 forloop.counter 总是一个表示当前循环的执行次数的整数计数器。 这个计数器是从1开始的，所以在第一次循环时forloop.counter 将会被设置为1。&#123;% for item in todo_list %&#125; &lt;p&gt;&#123;&#123; forloop.counter &#125;&#125;: &#123;&#123; item &#125;&#125;&lt;/p&gt;&#123;% endfor %&#125; forloop.counter0 类似于forloop.counter ，但是它是从0计数的。 第一次执行循环时这个变量会被设置为0。 forloop.revcounter 是表示循环中剩余项的整型变量。 在循环初次执行时forloop.revcounter 将被设置为序列中项的总数。 最后一次循环执行中，这个变量将被置1。 forloop.revcounter0 类似于forloop.revcounter ，但它以0做为结束索引。在第一次执行循环时，该变量会被置为序列的项的个数减1。 forloop.first 是一个布尔值，如果该迭代是第一次执行，那么它被置为True. forloop.last 是一个布尔值；在最后一次执行循环时被置为True。 一个常见的用法是在一系列的链接之间放置管道符|，另一个常见的用途是为列表的每个单词的加上逗号。 &#123;% for link in links %&#125;&#123;&#123; link &#125;&#125;&#123;% if not forloop.last %&#125; | &#123;% endif %&#125;&#123;% endfor %&#125; 上面的模板可能会产生如下的结果： Link1 | Link2 | Link3 | Link4 ifequal/ifnotequal 标签ifequal 标签比较两个值，当他们相等时，显示在 ifequal 和 endifequal 之中所有的值。 下面的例子比较两个模板变量 user 和 currentuser : &#123;% ifequal user currentuser %&#125; &lt;h1&gt;Welcome!&lt;/h1&gt;&#123;% else %&#125; &lt;h1&gt;Sorry&lt;/h1&gt;&#123;% endifequal %&#125; 只有模板变量，字符串，整数和小数可以作为 ifequal 标签的参数。其他任何类型，例如Python的字典类型、列表类型、布尔类型，不能用在ifequal 中 注释标签单行注释&#123;# 这是一个注释 #&#125; 用这种语法的注释不能跨越多行。 这个限制是为了提高模板解析的性能。 多行注释&#123;% comment %&#125;This is amulti-line comment.&#123;% endcomment %&#125; URL标签url的用法也很简单，只要在urlpatterns里使用它，附加一个name，如： url(r&apos;^article$&apos;,&apos;news_index&apos; ，name=&quot;news_index&quot;), Templates里 这样使用&#123;%url &apos;name&apos;%&#125; 地址链接就能使用了。 name是全局的，你整个urlpatterns里只能一个唯一的name，这个道理应该好理解，就像网站的地址也是唯一性的。 csrf_token标签用于生成csrf_token的标签，用于防治跨站攻击验证。注意如果你在view的index里用的是render_to_response方法，不会生效。其实，这里是会生成一个input标签，和其他表单标签一起提交给后台的 引用路由配置的地址这里的参数来自urls.py中的定义的name=xxxx&lt;form action=&quot;&#123;% url &quot;xxxx&quot;%&#125;&quot; &gt; &lt;input type=&quot;text&quot;&gt; &lt;input type=&quot;submit&quot;value=&quot;提交&quot;&gt; &#123;%csrf_token%&#125;&lt;/form&gt; 禁止渲染&#123;% verbatim %&#125; &#123;&#123; hello &#125;&#125;&#123;% endverbatim %&#125; 加载标签&#123;% load xxxx %&#125; 过滤器过滤器通过管道符来实现。 add给value加上一个数值 &#123;&#123; user.age | add:”5” &#125;&#125; capfirst第一个字母大写 &#123;&#123; ‘good’| capfirst &#125;&#125; 返回”Good” center输出指定长度的字符串，把变量居中&#123;&#123; “abcd”| center:”50” &#125;&#125; cut删除指定字符串 &#123;&#123; “You are not a Englishman” | cut:”not” &#125;&#125; dictsort按某字段排序，变量必须是一个dictionary &#123;% for moment in moments | dictsort:”id” %&#125; default如果值不存在，则使用默认值代替 &#123;&#123; value | default:”(N/A)” &#125;&#125; filesizeformat增加数字的可读性，转换结果为13KB,89MB,3Bytes等 &#123;&#123; 1024 | filesizeformat &#125;&#125; 返回 1.0KB floatformat转换为指定精度的小数，默认保留1位小数 &#123;&#123; 3.1415926 | floatformat:3 &#125;&#125; 返回 3.142 四舍五入 get_digit从个位数开始截取指定位置的数字 &#123;&#123; 123456 | get_digit:’1’&#125;&#125; linebreaks用&lt;p&gt;或&lt;br&gt;标签包裹变量 &#123;&#123; “Hi\n\nDavid”|linebreaks &#125;&#125; 返回&lt;p&gt;Hi&lt;/p&gt;&lt;p&gt;David&lt;/p&gt; ljust输出指定长度的字符串，变量左对齐 &#123;&#123;‘ab’|ljust:5&#125;&#125; 返回 ‘ab ’ slice切片操作， 返回列表 &#123;&#123;[3,9,1] | slice:’:2’&#125;&#125; 返回 [3,9]&#123;&#123; &apos;asdikfjhihgie&apos; | slice:&apos;:5&apos; &#125;&#125; 返回 ‘asdik’ slugify在字符串中留下减号和下划线，其它符号删除，空格用减号替换 &#123;&#123; &apos;5-2=3and5 2=3&apos; | slugify &#125;&#125; 返回 5-23and5-23 truncatewords将字符串转换为省略表达方式 &#123;&#123; &apos;This is a pen&apos; | truncatewords:2 &#125;&#125;返回 This is ... truncatewords_html同上，但保留其中的HTML标签 &#123;&#123; &apos;&lt;p&gt;This is a pen&lt;/p&gt;&apos; | truncatewords:2 &#125;&#125;返回 &lt;p&gt;This is ...&lt;/p&gt; yesno将布尔变量转换为字符串yes, no 或maybe &#123;&#123; True | yesno &#125;&#125; yes&#123;&#123; False | yesno &#125;&#125; no &#123;&#123; None | yesno &#125;&#125; maybe 其他过滤器 过滤器 描述 upper 以大写方式输出 addslashes 单引号加上转义号 date 格式化日期 default_if_none 如果值为None, 则使用默认值代替 divisibleby 判断是否可以被数字整除 返回布尔类型 dictsortreversed 按某字段倒序排序，变量必须是dictionary escape 按HTML转义，比如将”&lt;”转换为”&amp;lt” first 返回列表的第1个元素，变量必须是一个列表 length 返回列表中元素的个数或字符串长度 linebreaksbr 用&lt;br/&gt;标签代替换行符 linenumbers 为变量中的每一行加上行号 lower 字符串变小写 length_is 检查列表，字符串长度是否符合指定的值 join 用指定分隔符连接列表 make_list 将字符串转换为列表 pluralize 根据数字确定是否输出英文复数符号 random 返回列表的随机一项 removetags 删除字符串中指定的HTML标记 rjust 输出指定长度的字符串，变量右对齐 stringformat 字符串格式化，语法同python time 返回日期的时间部分 timesince 以“到现在为止过了多长时间”显示时间变量 结果可能为 45days, 3 hours timeuntil 以“从现在开始到时间变量”还有多长时间显示时间变量 title 每个单词首字母大写 urlencode 将字符串中的特殊字符转换为url兼容表达方式 urlize 将变量字符串中的url由纯文本变为链接 wordcount 返回变量字符串中的单词数 ◇◆◇◆◇]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用正则整理]]></title>
    <url>%2F2018%2F03%2F22%2F%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[很多不太懂正则的朋友，在遇到需要用正则校验数据时，往往是在网上去找很久，结果找来的还是不很符合要求。所以我最近把开发中常用的一些正则表达式整理了一下，在这里分享一下。给自己留个底，也给朋友们做个参考。 ◇◆◇◆◇#### 校验数字的表达式 数字^[0-9]*$ n位的数字^\d&#123;n&#125;$ 至少n位的数字^\d&#123;n,&#125;$ m-n位的数字^\d&#123;m,n&#125;$ 零和非零开头的数字^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$ 带1-2位小数的正数或负数^(\-)?\d+(\.\d&#123;1,2&#125;)?$ 正数、负数、和小数^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数^[0-9]+(.[0-9]&#123;2&#125;)?$ 有1~3位小数的正实数^[0-9]+(.[0-9]&#123;1,3&#125;)?$ 非零的正整数^[1-9]\d*$ 或 ^([1-9][0-9]*)&#123;1,3&#125;$ 或 ^\+?[1-9][0-9]*$ 非零的负整数^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$ 非负整数^\d+$ 或 ^[1-9]\d*|0$ 非正整数^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 非正浮点数^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 正浮点数^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ ◇◆◇◆◇#### 校验字符的表达式 汉字^[\u4e00-\u9fa5]&#123;0,&#125;$ 英文和数字^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$ 长度为3-20的所有字符^.&#123;3,20&#125;$ 由26个英文字母组成的字符串^[A-Za-z]+$ 由26个大写英文字母组成的字符串^[A-Z]+$ 由26个小写英文字母组成的字符串^[a-z]+$ 由数字和26个英文字母组成的字符串^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串^\w+$ 或 ^\w&#123;3,20&#125;$ 中文、英文、数字包括下划线^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$ 可以输入含有^%&amp;’,;=?$\”等字符[^%&amp;&apos;,;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+ ◇◆◇◆◇#### 特殊需求的表达式 Email地址^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$ 域名[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.? InternetURL[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$ 手机号码^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$ 电话号码^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$ 国内电话号码(0511-4405222、021-87888822)\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125; 身份证号(15位、18位数字)^\d&#123;15&#125;|\d&#123;18&#125;$ 短身份证号码(数字、字母x结尾)^([0-9])&#123;7,18&#125;(x|X)?$ 或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)^[a-zA-Z]\w&#123;5,17&#125;$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$ 日期格式^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125; 一年的12个月(01～09和1～12)^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)^((0?[1-9])|((1|2)[0-9])|30|31)$ xml文件^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 中文字符的正则表达式[\u4e00-\u9fa5] 双字节字符[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式\n\s*\r (可以用来删除空白行) HTML标记的正则表达式&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始) 中国邮政编码[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字) IP地址\d+\.\d+\.\d+\.\d+ (提取IP地址时有用) IP地址((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) 钱的输入格式 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”： ^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式 ^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号： ^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分： ^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的： ^[0-9]+(.[0-9]&#123;2&#125;)?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样： ^[0-9]+(.[0-9]&#123;1,2&#125;)?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样： ^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须： ^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 声明本篇文章源于一篇zxin博主的博文，仅作整理。 点击这里查看原文]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django路由和视图]]></title>
    <url>%2F2018%2F03%2F21%2FDjango%E8%B7%AF%E7%94%B1%E5%92%8C%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这篇主要介绍了Django中urls.py与views.py的配置，HttpRequest对象和HttpResponse对象属性和方法。 路由系统URL配置(URLconf)就像Django 所支撑网站的目录。它的本质是URL模式以及要为该URL模式调用的视图函数之间的映射表；你就是以这种方式告诉Django，对于不同URL分别调用的代码是什么。 urlpatterns = [ url(正则表达式, views视图函数，参数，别名),] 参数： 一个正则表达式字符串 一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串 可选的要传递给视图函数的默认参数（字典形式） 一个可选的name参数 视图函数views.py中的函数是用来编写与路由系统绑定函数，用于处理hhtp请求。在http请求中两个核心对象： http请求：HttpRequest对象 http响应：HttpResponse对象 def userinfo(request): # 第一次为Get不执行if submit之后method为POST print(request.method) if request.method == "POST": username = request.POST.get("username", None) sex = request.POST.get("sex", None) mail = request.POST.get("mail", None) models.UserInfo.objects.create( username=username, sex = sex, mail = mail ) print(username,sex,mail) 我们这里用到的参数request就是HttpRequest 检测方法：isinstance(request,HttpRequest) HttpRequest对象的属性和方法属性 属性 描述 path 请求页面的全路径，不包括域名 method 请求中使用的HTTP方法的字符串表示。全大写表示。 例子：if req.method == &quot;GET&quot;: do_something()elseif req.method == &quot;POST&quot;: do_something_else() 服务器收到空的POST请求的情况也是可能发生的，也就是说，表单form通过HTTP POST方法提交请求，但是表单中可能没有数据，因此不能使用if req.POST来判断是否使用了HTTP POST 方法；应该使用 if req.method==”POST” 属性 描述 GET 包含所有HTTP GET参数的类字典对象 POST 包含所有HTTP POST参数的类字典对象 COOKIES 包含所有cookies的标准Python字典对象；keys和values都是字符串。 FILES： 包含所有上传文件的类字典对象； FILES中的每一个Key都是&lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;标签中name属性的值，FILES中的每一个value同时也是一个标准的python字典对象，包含下面三个Keys： filename： 上传文件名，用字符串表示 content_type: 上传文件的Content Type content： 上传文件的原始内容 属性 描述 user 一个django.contrib.auth.models.User对象，代表当前登陆的用户。 如果访问用户当前没有登陆，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你可以通过user的is_authenticated()方法来辨别用户是否登陆。if req.user.is_authenticated()只有激活Django中的AuthenticationMiddleware时该属性才可用。 属性 描述 session 唯一可读写的属性，代表当前会话的字典对象；自己有激活Django中的session支持时该属性才可用。 方法 方法 描述 get_full_path() 得到完整路径 比如：http://127.0.0.1:8000/index33/?name=123 req.get_full_path()得到的结果： /index33/?name=123 req.path得到的结果: /index33 HttpResponse对象对于HttpRequest对象来说，是由django自动创建的，但是HttpResponse对象就必须我们自己创建。每个view请求处理方法必须返回一个HttpResponse对象。 HttpResponse类在django.http.HttpResponse 在HttpResponse对象上扩展的常用方法： 方法 描述 页面渲染 render()（推荐）; render_to_response() 页面跳转 redirect(“路径”) locals() 可以直接将函数中所有的变量传给模板]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyinstaller模块]]></title>
    <url>%2F2018%2F03%2F19%2Fpyinstaller%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[写好脚本经常想要进行打包成exe，这篇文章简单的介绍下，如何使用pyinstaller进行打包写好的脚本。 安装pip install pyinstaller 使用安装好的pyinstaler，会在你的python目录的scrip里，嗯，就是你pip的目录，如果你之前配置好了pip到环境变量，那么安装好之后，可以直接在命令提示行里直接执行命令。 pyinstaller -F 路径/xxxx.py 直接进行打包你的脚本，成功之后你生成的可执行文件会在C:\Users\xxx\dist路径下，xxx为你的用户名。 感觉是不是so easy，但其实这个模块还有其他的参数，便于你做一些其他的修改。 参数 参数 描述 -F 制作独立的可执行程序 -D 制作出的档案存放在同一个文件夹下（默认值） -K 包含TCL/TK（对于使用了TK的，最好加上这个选项，否则在未安装TK的电脑上无法运行） -w 制作窗口程序 -c 制作命令行程序（默认） -X 制作使用UPX压缩过的可执行程序（推荐使用这个选项，需要下载UPX包，解压后upx.exe放在Python(非PyInstaller)安装目录下，下载upx308w.zip） -o DIR 指定输出SPEC文件路径（这也决定了最后输出的exe文件路径） –icon=[ICO文件路径] 指定程序图标 -v [指定文件] 指定程序版本信息 -n [指定程序名] 指定程序名称]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eval实现计算器]]></title>
    <url>%2F2018%2F03%2F19%2Feval%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[上次介绍了eval这个函数，也说了可以用来实现计算器，那么这次来实践一下，利用eval来实现一个功能较为完善的计算器，支持加减乘除与指数运算，支持长表达式计算，实现连续计算功能。 明确需求整体上需要的就是这一个强大的函数，就可以实现一个基本功能的计算器。while True: print(str(eval(input("输入表达式:\n"))) 对，基本功能已经实现了，但是这并不是一个功能完备的计算器，我们需要对其做一些功能和安全方向的完善。上篇文章讲了eval函数的危险，那我们首先需要做的就是语法检查，这里就引出了需要的re模块，回顾re模块的请点击这里. 其次，我们还需要进行异常处理。 对了，我们还需要有连续计算的能力。 到这里，需求基本上也就都明确了，明确了需求，我们就按照这三大块，对我们的程序进行完善，看看最终的两行函数，离我们最终的成品还差多远。 语法检查导入模块import re 检查点1–是否含有非法字符如果输入的表达式含有字母和非运算符，那么这个表达式就是不合法的，对这样的表达式我们拒绝它执行，并且给与他友好性的提示，提示输入正确的表达式，并返回-1并表示表达式非法。 def CharErrorCheck(str_in): if re.findall(r'[&amp;a-zA-Z&lt;&gt;,?~!@#$%";:]', str_in): # 正则表达式校验输入字符串的合法性 print('错误：表达式包含非法字符，请重新输入\n') return 1 else: return -1 检查点2–括号是否平衡确保括号成对出现，如不符合，给与友好型提示。返回-1表示表达式不合法。def BracketUnbalanceCheck(str_in): num = 0 for i in str_in: if i == '(': num += 1 elif i == ')': num -= 1 if num != 0: # 括号不平衡 print("错误：输入的括号不平衡，请重新输入\n") return 1 else: # 括号平衡 return -1 进行语法检查后，就要开始计算了，那么这里首先就要加上继续计算的功能，就是上一次计算结束后的结果进行保留，可以继续使用上一次的结果作为输入。 继续计算功能其实。要添加这个功能不难，仅仅需要一个标志位来判断是不是继续上一次的计算。这时候就可能有人要问了，怎么判断是不是想要继续计算呢？ 很简单，如果继续计算的话，那么他新输入的第一个字符就是运算符，如果不是运算符，那么就是开启了一个新的运算式。 判断是否为继续计算如果判定为继续计算，那么返回&#39;continue&#39;，否则返回 &#39;new&#39;def InputExpression(): global exprs while not (CharErrorCheck(exprs) == -1 and BracketUnbalanceCheck(exprs) == -1): # 直到得到一个合法的表达式 exprs = input("继续输入表达式:\n") m = re.match(r'^[\^/\*+\-\\]\w*', exprs) # 匹配输入字符串的第一个字符是否是运算符，判断继续运算还是开始新计算 if m: return 'continue' else: return 'new' 开始计算与异常处理根据全局变量flag，适当修改计算式。如果含有几次方的计算,将^修改为**使用eval函数进行计算接着使用try语句块进行处理，语法错误或是0当作除数，给与友好型提示。def Compute(flag): global exprs global sum exprs = exprs.replace('^', '**') # 将^替换为** if flag == 'continue': exprs = str(sum) + exprs try: sum = eval(exprs) print(exprs) print("=" + str(sum)) except SyntaxError: print("错误：继续计算时出现语法错误，程序返回\n") except ZeroDivisionError: print("错误：除数不能为0，程序返回\n") 锦上添花至此所有的需求都已经实现，在主函数里面串起来即可。当然还可以添加一些锦上添花的功能，比如添加版权信息或是使用pyinstaller进行函数打包成exe都是可以的。具体怎么优化就看你了。 附录-源码完整源码请点击这里获取。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>eval</tag>
        <tag>计算器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eval函数]]></title>
    <url>%2F2018%2F03%2F17%2Feval%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在Python中有个神级函数，没错，神级函数，就是eval，它可以实现一些非常牛逼的操作。 语法它可以将字符串str当成有效的表达式来求值并返回计算结果。 eval(expression，globals=None, locals=None) 参数 参数 描述 expression 一个参与计算的python表达式 globals 可选的参数，如果设置属性不为None的话，就必须是dictionary对象了 locals 一个可选的对象，如果设置属性不为None的话，可以是任何map对象了 用法既然说是神级函数，那么他到底有什么用呢？ 类型转化可以把list,tuple,dict和string相互转化。 str转换成lista = "[[1,2], [3,4], [5,6], [7,8], [9,0]]"b = eval(a)print(b)print(type(b)) [[1, 2], [3, 4], [5, 6], [7, 8], [9, 0]]&lt;class 'list'&gt; str转换成dicta = "&#123;1: 'a', 2: 'b'&#125;"b = eval(a)print(b)print(type(b)) &#123;1: 'a', 2: 'b'&#125;&lt;class 'dict'&gt; 用于计算可以直接输入计算的表达式，就可以直接返回结果，所以用这个函数来写计算器函数是非常好写的，仅仅几行就可以写一个计算器的基本功能。 if __name__ == '__main__': while True : result = eval(input("请输入计算式：")) print(type(result)) print(result) 请输入计算式：3*7+9&lt;class 'int'&gt;30 使用eval实现完整功能的计算器，请点击这里 插曲-变量寻址x = 1y = 1num1 = eval("x+y")print(num1)def func(): x = 2 y = 2 num2 = eval("x+y") print(num2) num3 = eval("x+y", globals()) # num3 = eval("x+y", locals()) print(num3) 上面的x，y为全局变量，函数func内的为局部变量。在使用eval函数是可以定义要寻找变量的类型。重点看下上面代码的num3的值，如果是设定找的是全局变量，那么会返回2，设定局部变量表达式会返回4.如果并没有设定，默认先寻找local(), # 搜索变量的优先级顺序是：L &gt; E &gt; G &gt; B# L：local 局部作用域，即函数中的变量# E：enclosing，嵌套的父级函数的作用域，即，此函数的上级函数的局部作用域，但不是全聚德# G：global：全局变量，就是米会计别定义的变量# B：build-in 系统固定模块里面的变量，如int byte等 存在的问题与解决办法存在的问题就是安全问题了，当然就自己在本地跑脚本玩，也没什么问题， 如果python写的cgi程序中如果使用eval()而非int()来转换诸如年龄这样的输入框中的内容时是非常危险的。不仅可以看见列出系统的全部文件，还可以执行删除文件，察看文件源代码等危险操作！ 解决办法1.法1 eval接受3个参数: eval(source[, globals[, locals]]) -&gt; value 只要将2个命名空间置空即可隔绝上下文的代码进行安全执行表达式。 eval('&#123;1:2&#125;',&#123;&#125;,&#123;&#125;) 不过！ 通过builtins内置的方法仍有可能绕过:import(‘os’).system(‘dir’)、 eval(“globals()”, {}, {})。 2.法2 ast模块就是帮助Python应用来处理抽象的语法解析的。而该模块下的literal_eval()函数：则会判断需要计算的内容计算后是不是合法的python类型，如果是则进行运算，否则就不进行运算。 比如说上面的计算操作，及危险操作，如果换成了ast.literal_eval()，都会拒绝执行。 嗯，如果使用这个函数做计算器是没戏的。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>eval</tag>
        <tag>内置函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[头信息自动添加]]></title>
    <url>%2F2018%2F03%2F16%2F%E5%A4%B4%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E6%B7%BB%E5%8A%A0%2F</url>
    <content type="text"><![CDATA[每次写Header部分真的很烦，即使每次都只是从原来写好的模板上复制过来改一改，都是一件很麻烦的事情，时间浪费在这种琐碎的事情上真的很不值得。这篇记录自己平时使用Pycharm的一个小技巧吧，如何在创建文件时候自动添加文件信息，时间，工程信息还有个人的一些信息，希望能节省下大家一些宝贵的时间。 这种小技巧，可能真的很简单，可是真的非常有用，还有必要分享一下。 操作按照下面的顺序操作： Pycharm →→ File→→Settings→→Editor→→File and code Templates 在右侧的选项中找到Python Script，如下图： 在右侧输入你想要的模板格式，拿我的举例，实现了自动添加文件名称，时间自动填充： 如果每天手打这些东西是真的很累，即使是复制，日积月累的工作量也并不小的。 语法$ &#123;&lt;variable_name&gt;&#125; 预定义变量下面列举下IDE中预先定义好的变量。 $&#123;PROJECT_NAME&#125; - the name of the current project.$&#123;NAME&#125; - the name of the new file which you specify in the New File dialog box during the file creation.$&#123;USER&#125; - the login name of the current user.$&#123;DATE&#125; - the current system date.$&#123;TIME&#125; - the current system time.$&#123;YEAR&#125; - the current year.$&#123;MONTH&#125; - the current month.$&#123;DAY&#125; - the current day of the month.$&#123;HOUR&#125; - the current hour.$&#123;MINUTE&#125; - the current minute.$&#123;PRODUCT_NAME&#125; - the name of the IDE in which the file will be created.$&#123;MONTH_NAME_SHORT&#125; - the first 3 letters of the month name. Example: Jan, Feb, etc.$&#123;MONTH_NAME_FULL&#125; - full name of a month. Example: January, February, etc. 更改预变量预定义变量也是可以自己进行更改的，当然自己创建变量再引用也是完全OK的，但有什么必要呢，直接写死不就好了。#set($USER = "Handsome") Hearder还是很重要的，我的头格式仅仅对大家当作一个参考，内容不多，希望对大家能有所帮助。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Pycharm</tag>
        <tag>头信息</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[嵌套列表合并为一维列表]]></title>
    <url>%2F2018%2F03%2F14%2F%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E5%90%88%E5%B9%B6%E4%B8%BA%E4%B8%80%E7%BB%B4%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[今天看到一个题，觉得很有意思，就是一个列表里面嵌套了几层列表，那么如何将他们全部转换到一个列表里？可能应用有限，但确实很有趣，实现方式也很多，适合用来拓展下思维。 需求我们有一个嵌套列表，他是这个样子的： a = [[1, 2], 3, [4, 5], &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 然后需要将其转为一维列表：a_new = [1, 2, 3, 4, 5, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] 方法一：递归最简单的办法，就是递归。 把列表传进去 定义一个列表用来接收新的列表元素 开始循环遍历列表 如果当前元素不是列表，就直接附到新列表后面 如果当前元素为列表，进行递归操作 遍历结束后，返回新列表def expand_list1(nested_list, em=[]): for x in nested_list: if type(x) != list: em.append(x) else: expand_list1(x) return em 方法二：生成器+递归在上面递归的思想下，在使用生成器的方法，不是列表和元组的直接使用yield语法糖，是列表或元组的直接递归即可。def expand_list2(nested_list): for item in nested_list: if isinstance(item, (list, tuple)): for sub_item in expand_list1(item): yield sub_item else: yield item 方法三：字符串替换可能这种是最好理解的，但不是最容易想到的。惯性思维下，都会先考虑列表的操作。思路就是：先转成字符串，匹配两端的方括号，再替换里面的方括号def expand_list2(nested_list): return eval(&apos;[%s]&apos; % repr(nested_list).replace(&apos;[&apos;, &apos;&apos;).replace(&apos;]&apos;, &apos;&apos;)) 方法四：列表推导式说实话，这是第一种想到的办法，毕竟这个列表嵌套最多就有两层，但是失败了！看了报错，恍然大悟。我们的列表中，有个单独的int类型，他并不是一个可迭代对象。 a = [[1, 2], 3, [4, 5], &apos;a&apos;, &apos;b&apos;, &apos;c&apos;] def expand_list4(nested_list): return [i for item in nested_list for i in item] 其实即使没有单独的int类型，还是可以实现需求的，但是，这样的话就会将字符串进行迭代，就是说如果有个单独的“abc”，也会被拆分成单独的字母。显然，这不是我们想要的效果。 这个题其实限制还是有点多，如果是单纯的数字，没有字符串的话，其实解法话有很多。 import itertoolsa = [[1,2,3],[4,5,6], [7], [8,9]]out = list(itertools.chain.from_iterable(a)) import numpy as npa = [[1,2,3], [5, 2, 8], [7,8,9]]out = list(np.ravel(a)) 还有什么好方法，请猛戳这里告诉我]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>列表</tag>
        <tag>迭代</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML标签元素]]></title>
    <url>%2F2018%2F03%2F14%2FHTML%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[接触web难免会用到一些HTML语法，这里记录了一些常用的标签的用法，更多的再用到的时候再更新到这里。还有一点想说的是markdown是兼容这些语法的，如果有些想要实现的markdown不支持，完全可以使用HTML来代替，也算个小技巧吧。 HTML基本语法XHTML文档的扩展名通常是.html或者.htm。XHTML元素使用XHTML标记定义，每个标记都出现一对尖括号中&lt;&gt;，第一个标记为开始标记，后一个标记为结束标记。在开始标记与结束标记之间的内容叫元素内容。 HTML总体结构所有的XHTML文档都有三个文档级的元素：html、head和body。 html元素的标记之间是XHTML文档的内容，这个元素告诉客户端浏览器文档的开头和结尾； head元素定义XHTML文档的标题部分； meta标签声明字符编码集； body标记定义网页正文部分。 在一个XHTML文档中，html、head、body元素必须出现，且head元素中必须包含有title标签. HTML文档正文正文标题XHTML提供了六个标题标签，h1、h2、h3、h4、h5、h6，分别代表六个级别的标题，其重要性依次递减。&lt;h1&gt;h1标记，表示一级标题&lt;/h1&gt;&lt;h2&gt;h2标记，表示二级标题&lt;/h2&gt;&lt;h3&gt;h3标记，表示三级标题&lt;/h3&gt;&lt;h4&gt;h4标记，表示四级标题&lt;/h4&gt;&lt;h5&gt;h5标记，表示五级标题&lt;/h5&gt;&lt;h6&gt;h6标记，表示六级标题&lt;/h6&gt; 定义段落XHTNL文档中p标签表示一个段落（Paragraph）&lt;p&gt;这是p标记，它表示一个段落。&lt;/p&gt; 引用文本在XHTML文档中使用&lt;blockquote&gt;标签界定引用文本块。 这里是引用文本区域 定义列表有序列表：用ol标签（Ordered Lis）&lt;ol&gt; &lt;li&gt;有序标记，每个列表以数字形式标识&lt;/li&gt; &lt;li&gt;有序标记，每个列表以数字形式标识&lt;/li&gt; &lt;/ol&gt; 有序标记，每个列表以数字形式标识 有序标记，每个列表以数字形式标识 无序列表：用ul标签（Unordered List）&lt;ul&gt; &lt;li&gt;无序标记，每个列表以小黑点标识&lt;/li&gt; &lt;li&gt;无序标记，每个列表以小黑点标识&lt;/li&gt; &lt;/ul&gt; 无序标记，每个列表以小黑点标识 无序标记，每个列表以小黑点标识 定义列表：用dl标签（Defined List）&lt;dl&gt; &lt;dt&gt;猫&lt;/dt&gt; &lt;dd&gt;一种可爱的动物&lt;/dd&gt; &lt;/dl&gt;` 猫 一种可爱的动物 预排文本在XHTML中有时我们需要保持文本原来的格式，于是我们需要用到pre标签。 &lt;pre&gt; 2.9+ 1.2—————— 4.1&lt;/pre&gt; 分块或分节&lt;div&gt; 标签可以把文档分割为独立的、不同的部分。它可以用作严格的组织工具，并且不使用任何格式与其关联。如果用 id 或 class 来标记 &lt;div&gt;，那么该标签的作用会变得更加有效。 &lt;div style=&quot;color:#00FF00&quot;&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/div&gt; This is a paragraph. 组合行内元素&lt;p&gt;这是&lt;span style=&quot;color:blue;&quot;&gt;一行中&lt;/span&gt;的文字&lt;/p&gt; 这是一行中的文字]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Web</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django框架和基本命令]]></title>
    <url>%2F2018%2F03%2F14%2FDjango%E6%A1%86%E6%9E%B6%E5%92%8C%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[这篇记录了web框架的简单介绍，django的结构和基本django命令，一切才刚刚开始，新的一天也要有新的收获。愿时光不负以往。 web框架即framework，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构，使用框架可以帮你快速开发特定的系统，简单地说，就是你用别人搭建好的舞台来做表演。 对于所有的Web应用，本质上其实就是一个socket服务端，用户的浏览器其实就是一个socket客户端。最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。 如果要动态生成HTML，就需要把上述步骤自己来实现。不过，接受HTTP请求、解析HTTP请求、发送HTTP响应都是苦力活，如果我们自己来写这些底层代码，还没开始写动态HTML呢，就得花个把月去读HTTP规范。 正确的做法是底层代码由专门的服务器软件实现，我们用Python专注于生成HTML文档。因为我们不希望接触到TCP连接、HTTP原始请求和响应格式，所以，需要一个统一的接口，让我们专心用Python编写Web业务。 这个接口就是WSGI：Web Server Gateway Interface。下面是一个简单的框架，可以了解一下。 点击这里，查看代码 from wsgiref.simple_server import make_serverimport timedef f1(req): print(req) print(req["QUERY_STRING"]) f1 = open("index1.html", "rb") data1 = f1.read() return [data1]def f2(req): f2 = open("index2.html", "rb") data2 = f2.read() return [data2]def f3(req): # 模版以及数据库 f3 = open("index3.html", "rb") data3 = f3.read() times = time.strftime("%Y-%m-%d %X", time.localtime()) data3 = str(data3, "utf8").replace("!time!", str(times)) return [data3.encode("utf8")]def routers(): urlpatterns = ( ('/person1', f1), ('/person2', f2), ("/cur_time", f3) ) return urlpatternsdef application(environ, start_response): print(environ['PATH_INFO']) path = environ['PATH_INFO'] start_response('200 OK', [('Content-Type', 'text/html')]) urlpatterns = routers() func = None for item in urlpatterns: if item[0] == path: func = item[1] break if func: return func(environ) else: return ["&lt;h1&gt;404&lt;/h1&gt;".encode("utf8")]httpd = make_server('', 8518, application)print('Serving HTTP on port 8084...')# 开始监听HTTP请求:httpd.serve_forever() MVC和MTV模式Django的MTV模式本质是各组件之间为了保持松耦合关系,Django的MTV分别代表： Model(模型)：负责业务对象与数据库的对象(ORM) Template(模版)：负责如何把页面展示给用户 View(视图)：负责业务逻辑，并在适当的时候调用Model和Template 此外，Django还有一个url分发器，它的作用是将一个个URL的页面请求分发给不同的view处理，view再调用相应的Model和Template。 Django命令有些坑要说在创建之前，你需要先安装sqlite，在创建应用，不然你会掉进坑里的， 创建django project在你想创建项目的路径下：django-admin.py startproject [project name] [project name] 填写你的项目名称 当然这里可能会遇到一个问题，为什么我这里什么都没有啊，两个问题：一就是你没有将django的目录放进环境变量；二就是你的默认打开.py文件的不是python。 其实还有另一种解决方案：如果你是Django 3.x，完全可以不加.py: django-admin startproject [project name] 以生成mysite为例，目录结构是这样的： manage.py —– Django项目里面的工具，通过它可以调用django shell和数据库等。 settings.py —- 包含了项目的默认设置，包括数据库信息，调试标志以及其他一些工作的变量。 urls.py —– 负责把URL模式映射到应用程序。 创建应用在mysite目录下创建应用，比如blog: python manage.py startapp blog 启动项目这样我们的django就启动起来了！当我们访问：http://127.0.0.1:4000/时就可以看到我们的效果。当然，你访问localhost:4000也是一样的。python manage.py runserver 4000 同步更改数据库表或字段python manage.py makemigrationspython manage.py migrate 这种方法可以创建表，当你在models.py中新增了类时，运行它就可以自动在数据库中创建表了，不用手动创建。 清空数据库python manage.py flush 此命令会询问是 yes 还是 no, 选择 yes 会把数据全部清空掉，只留下空表。 创建超级管理员python manage.py createsuperuser # 按照提示输入用户名和对应的密码就好了邮箱可以留空，用户名和密码必填 修改用户密码python manage.py changepassword username 环境终端python manage.py shell 这个命令和 直接运行 python 进入 shell 的区别是：你可以在这个 shell 里面调用当前项目的 models.py 中的 API，对于操作数据的测试非常方便。 python manage.py dbshell Django 会自动进入在settings.py中设置的数据库，如果是 MySQL 或 postgreSQL,会要求输入数据库用户密码。 在这个终端可以执行数据库的SQL语句 查看所有命令python manage.py]]></content>
      <categories>
        <category>Web Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map实现并行]]></title>
    <url>%2F2018%2F03%2F13%2Fmap%E5%AE%9E%E7%8E%B0%E5%B9%B6%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[在Python中有个两个库包含了map函数：multiprocessing和它鲜为人知的子库dummy。它是multiprocessing模块的完整克隆，唯一的不同在于multiprocessing作用于进程，而dummy模块作用于线程（因此也包括了Python所有常见的多线程限制）。所以选择使用这两个库异常容易。你可以针对IO密集型任务和CPU密集型任务来选择不同的库。 导入from multiprocessing import Poolfrom multiprocessing.dummy import Pool as ThreadPool 实例化Pool 对象有一些参数，这里我所需要关注的只是它的第一个参数：processes. 这一参数用于设定线程池中的线程数。其默认值为当前机器 CPU 的核数。 一般来说，执行 CPU 密集型任务时，调用越多的核速度就越快。但是当处理网络密集型任务时，事情有有些难以预计了，通过实验来确定线程池的大小才是明智的。 pool = ThreadPool(4) # Sets the pool size to 4 线程数过多时，切换线程所消耗的时间甚至会超过实际工作时间。对于不同的工作，通过尝试来找到线程池大小的最优值。创建好 Pool 对象后，并行化的程序 多线程例子import timeimport urllib.requestfrom multiprocessing.dummy import Pool as ThreadPoolurls = [ &apos;http://www.python.org&apos;, &apos;http://www.python.org/about/&apos;, &apos;http://www.python.org/doc/&apos;, &apos;http://www.python.org/download/&apos;, &apos;http://www.python.org/getit/&apos;, &apos;http://www.python.org/community/&apos;, &apos;https://wiki.python.org/moin/&apos;, &apos;http://planet.python.org/&apos;, &apos;https://wiki.python.org/moin/LocalUserGroups&apos;, &apos;http://www.python.org/psf/&apos;, &apos;http://docs.python.org/devguide/&apos;, &apos;http://www.python.org/community/awards/&apos; # etc..]pool_num = 4start_time = time.time()# 实例化线程池，并规定线程池大小pool = ThreadPool(pool_num)# 打开每个网站在线程中results = pool.map(urllib.request.urlopen, urls)pool.close()pool.join() # 等待进程结束end_time = time.time()print(&quot;pool=%s总用时：&quot; % pool_num, end_time - start_time, &quot;s&quot;) 为了找到最优的线程池大小，通过修改pool_num大小得到的总时间对比，当然这种方法比较笨，需要每次修改，完全可以写进循环for i in range(min=0,max=8):，再将 i 赋值给pool_num,当然这里就不改了，也比较简单。 pool=2总用时： 7.664671182632446 spool=3总用时： 5.713357210159302 spool=4总用时： 5.139662504196167 spool=5总用时： 7.917045593261719 spool=6总用时： 23.377182006835938 s 从数据上验证了，上面的说法，并不是线程池越大，用时最短。 多进程例子生成图片的缩略图，这是一个 CPU 密集型的任务，并且十分适合进行并行化。 import os, timefrom multiprocessing import Poolfrom PIL import ImageSIZE = (75, 75)SAVE_DIRECTORY = 'thumbs'def get_image_paths(folder): return (os.path.join(folder, f) for f in os.listdir(folder) if 'jpg' in f)def create_thumbnail(filename): im = Image.open(filename) im.thumbnail(SIZE, Image.ANTIALIAS) base,fname = os.path.split(filename) print(fname) save_path = os.path.join(base, SAVE_DIRECTORY, fname) im.save(save_path)if __name__ == '__main__': pool_num = 4 start_time = time.time() folder = os.path.realpath(r'C:\Users\Liu\Pictures\最近') try: # 查看是否已存在相同文件夹 os.mkdir(os.path.join(folder, SAVE_DIRECTORY)) except FileExistsError: pass # 注意这里返回的不再是列表,而是迭代器 images = get_image_paths(folder) # 列表化 images = list(images) print(images) try: pool = Pool(pool_num) pool.map(create_thumbnail, images) pool.close() pool.join() except: pass end_time = time.time() print("pool=%s总用时：" % pool_num, end_time - start_time, "s") 这里同上面的例子一样可以进行寻找最优的pool_num,这里就不找了，想要实验的可以直接把代码copy过去，改个路径，python3直接可以运行。 总结在生产环境中，我们可以为 CPU 密集型任务和 IO 密集型任务分别选择多进程和多线程库来进一步提高执行速度——这也是解决死锁问题的良方。此外，由于 map 函数并不支持手动线程管理，反而使得相关的 debug 工作也变得异常简单。 声明本篇文章来自这里(点击这里查看原文)，并根据python3与python2的区别对代码做了适当修改，python2的代码请参考原文。还有一点要注意的是python3中大多数原来返回列表的已经改为返回迭代器，查看网上资料的时候，一不小心就会被坑一下。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
        <tag>多进程</tag>
        <tag>map</tag>
        <tag>multiprocessing.dummy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程]]></title>
    <url>%2F2018%2F03%2F12%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[虽然Python多线程有缺陷，总被人说成是鸡肋，但也不是一无用处，它很适合用在IO密集型任务中。I/O密集型执行期间大部分是时间都用在I/O上，如数据库I/O，较少时间用在CPU计算上。因此该应用场景可以使用Python多线程，当一个任务阻塞在IO操作上时，我们可以立即切换执行其他线程上执行其他IO操作请求。 导入import threading Python中使用线程有两种方式：函数或者用类来包装线程对象。 基于函数线程调用 threading 模块中的Thread()函数来产生新线程。语法如下: threading.Thread( function, args[, kwargs] ) 参数说明: 参数 描述 function 线程函数。 args 传递给线程函数的参数,他必须是个tuple类型。 kwargs 可选参数。 下面来看一个实例： import threading, timedef test(s): print("线程%d开始" % s) start_time = time.time() time.sleep(3) print("线程%d结束" % s) end_time = time.time() print("线程%d花费的时间为：" % s, end_time - start_time)if __name__ == '__main__': threads_list = [] # 定义一个线程空列表 start = time.time() # 总的开始时间 for i in range(0, 4): # 生成四个线程实例，并将他们存到列表里 t = threading.Thread(target=test, args=(i,)) threads_list.append(t) for t in threads_list: # 循环遍历列表，启动每一个线程 t.start() for t in threads_list: # 循环遍历列表，等待每一个线程结束 t.join() end = time.time() # 总的结束时间 print("总共花费的时间：", end - start) 运行结果：线程0开始线程1开始线程2开始线程3开始线程1结束线程1花费的时间为： 3.000976085662842线程0结束线程2结束线程0花费的时间为： 3.000976085662842线程2花费的时间为： 3.000976085662842线程3结束线程3花费的时间为： 3.0009756088256836总共花费的时间： 3.0027308464050293 四个线程，每个线程单独完成的时间基本上一样，但是经过多线程的处理，总共的运行时间也才3秒多一点，可见多线程IO阻塞情况下还是可以大大提高我们的运行效率的。 基于类的线程将上面的例子，改为基于类实现，方便对比： class Test(threading.Thread): def __init__(self, name=0): # 继承父类的两种方式 # super().__init__() threading.Thread.__init__(self) self.name = name def run(self): print(&quot;线程%s开始&quot; % self.name) start_time = time.time() time.sleep(3) print(&quot;线程%s结束&quot; % self.name) end_time = time.time() print(&quot;线程%s花费的时间为：&quot; % self.name, end_time - start_time)if __name__ == &apos;__main__&apos;: threads_list = [] # 定义一个线程空列表 start = time.time() # 总的开始时间 for i in range(0, 4): # 生成四个线程实例，并将他们存到列表里 t = Test(name=i) threads_list.append(t) for t in threads_list: # 循环遍历列表，启动每一个线程 t.start() for t in threads_list: # 循环遍历列表，等待每一个线程结束 t.join() end = time.time() # 总的结束时间 print(&quot;总共花费的时间：&quot;, end - start) 两者实现的效果相同，条条大路通罗马，只是走的路不同而已。 线程模块中其他方法 方法名 描述 run() 用以表示线程活动的方法。 start() 启动线程活动。 join([time]) 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。 isAlive() 返回线程是否活动的。 getName() 返回线程名。 setName() 设置线程名。 线程锁如果多个线程共同对某个数据修改，则可能出现不可预料的结果，为了保证数据的正确性，需要保证每次只有一个线程对其修改，这就需要用到我们的线程锁。 Thread 对象的 Lock 和 Rlock 可以实现这样的功能，这两个对象都有 acquire 方法和 release 方法，对于那些需要每次只允许一个线程操作的数据，可以将其操作放到 acquire 和 release 方法之间。 看个例子，使用十个线程对同一个全局变量进行修改：import threading, timeglobal_num = 0lock = threading.RLock() # 获得锁def show(): lock.acquire() # 上锁 global global_num time.sleep(1) global_num += 1 print(global_num) lock.release() # 解锁if __name__ == &apos;__main__&apos;: for i in range(10): # 启动十个线程 t = threading.Thread(target=show) t.start() 上面说了Lock和RLock方法都可以获得锁，那么两者的区别是什么呢？ Lock和RLock的区别 RLock允许在同一线程中被多次acquire。而Lock却不允许这种情况。注意：如果使用RLock，那么acquire和release必须成对出现，即调用了n次acquire，必须调用n次的release才能真正释放所占用的琐。 Condition方法在threading中除了Lock和RLock，还可以使用Condition(条件)方法达到想要的效果。可以把Condiftion理解为一把高级的琐，它提供了比Lock, RLock更高级的功能，允许我们能够控制复杂的线程同步问题。threadiong.Condition在内部维护一个琐对象（默认是RLock），可以在创建Condigtion对象的时候把琐对象作为参数传入。Condition也提供了acquire, release方法，其含义与琐的acquire, release方法一致，其实它只是简单的调用内部琐对象的对应的方法而已。 Condition还提供了如下方法(注意：这些方法只有在占用琐(acquire)之后才能调用，否则将会报RuntimeError异常。)： Condition.wait([timeout]): wait方法释放内部所占用的琐，同时线程被挂起，直至接收到通知被唤醒或超时（如果提供了timeout参数的话）。当线程被唤醒并重新占有琐的时候，程序才会继续执行下去。 Condition.notify(): 唤醒一个挂起的线程（如果存在挂起的线程）。注意：notify()方法不会释放所占用的琐。 Condition.notifyAll()： 唤醒所有挂起的线程（如果存在挂起的线程）。注意：这些方法不会释放所占用的琐。 处于waiting状态的线程只能通过notify方法唤醒，所以notifyAll的作用在于防止有线程永远处于沉默状态。 附上经典的消费者与生产者模型：2个生成者生产products ，而接下来的10个消费者将会消耗products。import threading, timecondition = threading.Condition()products = 0class Producer(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global condition, products while True: if condition.acquire(): if products &lt; 10: products += 1 print("Producer(%s):deliver one, now products:%s" % (self.name, products)) condition.notify() else: print("Producer(%s):already 10, stop deliver, now products:%s" % (self.name, products)) condition.wait(); condition.release() time.sleep(2)class Consumer(threading.Thread): def __init__(self): threading.Thread.__init__(self) def run(self): global condition, products while True: if condition.acquire(): if products &gt; 1: products -= 1 print( "Consumer(%s):consume one, now products:%s" % (self.name, products)) condition.notify() else: print("Consumer(%s):only 1, stop consume, products:%s" % (self.name, products)) condition.wait() condition.release() time.sleep(2)if __name__ == "__main__": for p in range(0, 2): p = Producer() p.start() for c in range(0, 10): c = Consumer() c.start() Thread.Local方法当不想将变量共享给其他线程时，可以使用局部变量，但在函数中定义局部变量会使得在函数之间传递特别麻烦。ThreadLocal解决了全局变量需要枷锁，局部变量传递麻烦的两个问题。通过在线程中定义： local_school = threading.local() 此时这个local_school就变成了一个全局变量，但这个全局变量只在该线程中为全局变量，对于其他线程来说是局部变量，别的线程不可更改。 def process_thread(name):# 绑定ThreadLocal的student: local_school.student = name 这个student属性只有本线程可以修改，别的线程不可以。 local = threading.local()def func(name): print(&apos;current thread:%s&apos; % threading.currentThread().name) local.name = name print(&quot;%s in %s&quot; % (local.name,threading.currentThread().name))t1 = threading.Thread(target=func,args=(&apos;haibo&apos;,))t2 = threading.Thread(target=func,args=(&apos;lina&apos;,))t1.start()t2.start()]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPMITOOL指令]]></title>
    <url>%2F2018%2F03%2F12%2FIPMITOOL%2F</url>
    <content type="text"><![CDATA[IPMITOOL是一种可用在 Linux/Unix 系统下的基于命令行方式的 ipmi 平台管理工具。利用它可以实现获取传感器的信息、显示系统日志内容、网络远程开关机等功能。其主要功能包括读取和显示传感器数据（SDR），显示System Evernt Log（SEL）的内容，显示打印Field Replaceable Unit（FRU）信息，读取和设置BMC模块的LAN配置，远程控制服务器主机的电源。 开关机，重启1. 查看开关机状态：ipmitool -H (IP) -I lanplus -U (用户) -P (密码) power status 2. 开机：ipmitool -H (IP) -I lanplus -U (用户) -P (密码) power on 3. 关机：ipmitool -H (IP) -I lanplus -U (用户) -P (密码) power off 4. 重启：ipmitool -H (IP) -I lanplus -U (用户) -P (密码) power reset 用户管理 [ChannelNo] 字段是可选的，ChannoNo为1或者8；BMC默认有2个用户：user id为1的匿名用户，user id为2的ADMIN用户；&lt;&gt;字段为必选内容；&lt;privilege level&gt; 2为user权限，3为Operator权限，4为Administrator权限； 1. 查看用户信息ipmitool -H (IP) -I lanplus -U (用户) -P (密码) user list [ChannelNo] 2. 增加用户ipmitool -H (IP) -I lanplus -U (用户) -P (密码) user set name &lt;user id&gt; &lt;username&gt; 3. 设置密码ipmitool -H (IP) -I lanplus -U (用户) -P (密码) user set password &lt;user id&gt; &lt;password&gt; 4. 设置用户权限ipmitool -H (IP) -I lanplus -U (用户) -P (密码) user priv &lt;user id&gt; &lt;privilege level&gt; [ChannelNo] 5. 启用/禁用用户ipmitool -H (IP) -I lanplus -U (用户) -P (密码) user enable/disable &lt;user id&gt; Watchdog配置1. 查看当前的watchdog信息ipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc watchdog get 2. 设置，开启watchdogipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc watchdog get 设置一个OS WDT的watchdog, 超时时间为60秒（自己看IPMI 2.0手册,351页的27.6 Set Watchdog Timer Command）(60x10=600 = 0x258) ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x06 0x24 0x04 0x01 0x00 0x10 0x58 0x2 ipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc watchdog get 开启该watchdog ipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc watchdog reset ipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc watchdog get 禁止watchdog动作(Hard reset-&gt; no action)ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x06 0x24 0x04 0x00 0x00 0x10 0x58 0xFF 上面的命令把时间改为非常大，提示第1个0x00表示没有动作，0x04表示是SMS/OS的watchdog, 0xFF58是超时的时间，单位为100ms。 IP网络设置 [ChannelNo] 字段是可选的，ChannoNo为1(Share Nic网络)或者8（BMC独立管理网络）；设置网络参数，必须首先设置IP为静态，然后再进行其他设置； 1. 查看网络信息ipmitool -H (IP) -I lanplus -U (用户) -P (密码) lan print [ChannelNo] 2. 修改IP为静态还是DHCP模式ipmitool -H (IP) -I lanplus -U (用户) -P (密码) lan set &lt;ChannelNo&gt; ipsrc &lt;static/dhcp&gt; 3. 修改IPipmitool -H (IP) -I lanplus -U (用户) -P (密码) lan set &lt;ChannelNo&gt; ipaddr &lt;IPAddress&gt; 4. 修改子网掩码ipmitool -H (IP) -I lanplus -U (用户) -P (密码) lan set &lt;ChannelNo&gt; netmask &lt;NetMask&gt; 5. 修改默认网关ipmitool -H (IP) -I lanplus -U (用户) -P (密码) lan set &lt;ChannelNo&gt; defgw ipaddr &lt;默认网关&gt; SOL功能 &lt;9.6/19.2/38.4/57.6/115.2&gt;其中115.2代表115200，即*1000是表示的波特率。 1. 设置SOL串口波特率ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sol set volatile-bit-rate &lt;9.6/19.2/38.4/57.6/115.2&gt; 2. 打开SOL功能ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sol activate 3. 关闭SOL功能ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sol deactivate SEL日志查看1. 查看当前的SEL summary信息ipmitool -H (IP) -I lanplus -U (用户) -P (密码) selipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel info 2. 列示所有SEL记录详细信息ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel listipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel list 10 3. 删除指定的SEL记录ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel delete 1 4. 清除所有的SEL记录ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel clear 5. 获取和修改SEL当前时钟ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel time getipmitool -H (IP) -I lanplus -U (用户) -P (密码) sel time set &quot;04/24/2018 18:44:44&quot; 6. 以RAW方式查看制定的SEL数据ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0xa 0x43 0 0 111 0 0 0xFF 0xa 0x43为Get SEL Entry Command； 0 0 保留值，111 0 表示取第112条记录（从0开始），0 为offset，保留；0xFF为读取的字节数，FF表示取整条记录 FRU信息查看1. 查看FRU信息ipmitool -H (IP) -I lanplus -U (用户) -P (密码) fru list SDR，Sensor信息查看1. 查看SDR Sensor信息ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sdr 2. 查看Sensor信息ipmitool -H (IP) -I lanplus -U (用户) -P (密码) sensor list mc状态和控制1. 重启动BMCipmitool -H (IP) -I lanplus -U (用户) -P (密码) mc reset &lt;warm/cold&gt; 设置BMC的iptables防火墙1. 设置某一段IP可以访问BMCipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x01 0x01 ip1(0xa 0xa 0xa 0xa) ip2(0xb 0xb 0xb 0xb) ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x09 2. 设置某个IP可以访问BMCipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x00 0x01 ip1(0xa 0xa 0xa 0xa) ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x09 3. 取消设置ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x08 4．获取防火墙设置ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x77 0x01 0x00 5. 阻止/开启某个端口ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x02 0x00/0x01 0x00 (portno)0x22 0x00 6. 取消某个端口的设置（6是5的对应取消操作）ipmitool -H (IP) -I lanplus -U (用户) -P (密码) raw 0x32 0x76 0x06 0x00/0x01 0x00 (portno)0x22 0x00 附录ipimitool 使用规则：ipmitool [options...] &lt;command&gt; 参数 参数 描述 -h 帮助 -V 显示版本信息 -v 详细（可以使用多次） -c 以逗号分隔格式显示输出 -d 指定要使用的/ dev / ipmiN设备（默认值= 0） -I 要使用的接口 -H LAN接口的远程主机名 -p 远程RMCP端口[默认= 623] -U 远程会话用户 -f 从文件读取远程会话密码 -z 通信通道（OEM）的尺寸更改大小 -S 使用本地文件进行远程SDR缓存 -D ttyb[:s]指定要使用的串行设备，波特率并且可选地指定该接口是系统接口 -a 提示输入远程密码 -Y 提示用于IPMIv2身份验证的Kg密钥 -e 设置SOL转义字符 -C 加密套件将被lanplus接口使用 -k 使用Kg键进行IPMIv2身份验证 -y 使用十六进制编码的Kg密钥进行IPMIv2身份验证 -L 远程会话权限[默认=管理员] 附加一个’+’以在RAKP1中使用名称/特权查找 -A 强制使用auth type NONE，PASSWORD，MD2，MD5或OEM -P 远程会话密码 -E 从IPMI_PASSWORD环境变量读取密码 -K 从IPMI_KGKEY环境变量中读取kgkey -m 设置本地IPMB地址 -b 通道为桥接请求设置目标通道 -t 将桥接请求发送到远程目标地址 -B 为桥接请求设置传输通道（双桥） -T 设置桥接请求的传输地址（双桥） -l 设置原始命令的目的地lun -o OEM设置（使用’list’查看可用的OEM类型） -O 将文件用于OEM SEL事件描述 -N 指定lan [default = 2] / lanplus [default = 1]接口的超时时间 -R 设置lan / lanplus接口的重试次数[默认= 4] Interfaces 接口 描述 open Linux OpenIPMI Interface [default] imb Intel IMB Interface lan IPMI v1.5 LAN Interface lanplus IPMI v2.0 RMCP+ LAN Interface serial-terminal Serial Interface, Terminal Mode serial-basic Serial Interface, Basic Mode Commands 命令 描述 raw Send a RAW IPMI request and print response i2c Send an I2C Master Write-Read command and print response spd Print SPD info from remote I2C device lan Configure LAN Channels chassis Get chassis status and set power state power Shortcut to chassis power commands event Send pre-defined events to MC mc Management Controller status and global enables sdr Print Sensor Data Repository entries and readings sensor Print detailed sensor information fru Print built-in FRU and scan SDR for FRU locators gendev Read/Write Device associated with Generic Device locators sdr sel Print System Event Log (SEL) pef Configure Platform Event Filtering (PEF) sol Configure and connect IPMIv2.0 Serial-over-LAN tsol Configure and connect with Tyan IPMIv1.5 Serial-over-LAN isol Configure IPMIv1.5 Serial-over-LAN user Configure Management Controller users channel Configure Management Controller channels session Print session information dcmi Data Center Management Interface sunoem OEM Commands for Sun servers kontronoem OEM Commands for Kontron devices picmg Run a PICMG/ATCA extended cmd fwum Update IPMC using Kontron OEM Firmware Update Manager firewall Configure Firmware Firewall delloem OEM Commands for Dell systems exec Run list of commands from file set Set runtime variable for shell and exec hpm Update HPM components using PICMG HPM.1 file ekanalyzer run FRU-Ekeying analyzer using FRU files ime Update Intel Manageability Engine Firmware]]></content>
      <categories>
        <category>BMC Study Notes</category>
      </categories>
      <tags>
        <tag>BMC</tag>
        <tag>IPMI</tag>
        <tag>IPMITOOL</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPMI笔记]]></title>
    <url>%2F2018%2F03%2F12%2FIPMI%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[IPMI是一种协议，也是一种对外的接口的标准 。IPMI协议被广泛用于服务器监控中，包括采集CPU温度、风扇转速、主板温度，以及远程开关机等等。而且IPMI独立于硬件和操作系统，无论是CPU、BIOS，还是OS出现故障，都不会影响IPMI的工作。因为IPMI的硬件设备BMC(Baseboard Management Controller)是一个独立的板卡，独立供电。 IPMI的模式本地本地安装： IPMI驱动（硬件设备被操作系统识别）ipmitool或其他工具（通过驱动获取服务器信息） 远程 只需要在客户端安装ipmitool或其他工具 远程模式下，IPMI使用RMCP，RMCP基于UDP协议实现。 远程监控也就是基于UDP的网络通信。 服务器IPMI使用的端口一般是623。 IPMI的原理IPMI的核心是一个专用芯片/控制器(叫做服务器处理器或基板管理控制器(BMC))，其并不依赖于服务器的处理器、BIOS或操作系统来工作，可谓非常地独立，是一个单独在系统内运行的无代理管理子系统，只要有BMC与IPMI固件其便可开始工作，而BMC通常是一个安装自爱服务器主板上的独立的板卡，现在也有服务器主板提供对IPMI支持的。IPMI良好的自治特性便克服了以往基于操作系统的管理方式所受的限制，例如操作系统不响应或未加载的情况下其仍然可以进行开关机、信息提取等操作。在工作时，所有的IPMI功能都是向BMC发送命令来完成的，命令使用IPMI规范中规定的指令，BMC接收并在系统事件日志中记录事件消息，维护描述系统中传感器情况的传感器数据记录。在需要远程访问系统时，IPMI新的LAN上串行(SOL)特性很有用。SOL改变IPMI会话过程中本地串口传送方向，从而提供对紧急管理服务、Windows专用管理控制台或Linux串行控制台的远程访问。BMC通过在LAN上改变传送给串行端口的信息的方向来做到这点，提供了一种与厂商无关的远程查看启 动、操作系统加载器或紧急管理控制台来诊断和维修故障的标准方式。 IPMI的功能  开机，关机，重启，查看机器当前的通电状态  安装系统。有些服务器的IPMI，没有内置iKVM，无法实现系统的安装。这个估计和成本有关  修改IPMI的网络和IP地址  获取一些硬件监控指标，监控数据，例如风扇转速，电源电压，cpu温度等  修改bios设置，可以通过IPMI进入bios  设置Raid。 IPMI的接口IPMI SYSTEM INTERFACE KCS: KEYBOARD CONTROLLER STYLE 键盘控制 SMIC: SYSTEM MANAGEMENT INTERFACE CHIP 系统管理界面芯片 BT: BLOCK TRANSFER 块传输 SMBUS: SYSTEM INTERFACE 系统接口 OTHER MESSAGING INTERFACE LAN (局域网) SERIAL (串口)/ MODEM(调制解调器) ICMB: INTELLIGENT CHASSIS MANAGEMENT BUS (智能机箱管理总线) PCI MANAGEMENT BUS IPMITOOL关于IPMITOOL指令的相关，请点击这里。 附录KEYWORD]]></content>
      <categories>
        <category>BMC Study Notes</category>
      </categories>
      <tags>
        <tag>BMC</tag>
        <tag>IPMI</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。一般情况下，在Python无法正常处理程序时就会发生一个异常。异常是Python对象，表示一个错误。发生异常时我们需要捕获处理它，否则程序会终止执行。[TOC]异常在python中，按分法，将错误分成语法错误和异常。 错误常见的语法错误有很多，这里将缩进错误单独提出来，是因为太常见，报错也很容易分辨，也很容易犯这个错误。 缩进错误a=10 print(a) 这里的print缩进错误，导致程序无法运行。IndentationError: unexpected indent 语法错误for i in range(10) print(i) 这里的for循环缺少个冒号，造成语法错误，报错如下：SyntaxError: invalid syntax 异常即便Python程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。大多数的异常都不会被程序处理，都以错误信息的形式展现在这里: print(1/0) ZeroDivisionError: division by zero 异常以不同的类型出现，这些类型都作为信息的一部分打印出来,这里不多举例，常见异常及含义见附录。 异常处理其实异常处理都是套路，将可能发生异常的语句块放进try：，except捕获异常即可，看下面的例子，尝试将一个输入转换为int类型：try: x = int(input("Please enter a number: "))except ValueError: print("Oops! That was no valid number. Try again") try语句按照如下方式工作； 首先，执行try子句（在关键字try和关键字except之间的语句） 如果没有异常发生，忽略except子句，try子句执行后结束。 如果在执行try子句的过程中发生了异常，那么try子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的except子句将被执行。最后执行 try 语句之后的代码。 如果一个异常没有与任何的except匹配，那么这个异常将会传递给上层的try中。 一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。 处理程序将只针对对应的try子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。 一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。except (RuntimeError, TypeError, NameError): pass else子句try except 语句还有一个可选的else子句，如果使用这个子句，那么必须放在所有的except子句之后。这个子句将在try子句没有发生任何异常的时候执行。 但是,真的并不推荐！！！ 使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到的、而except又没有捕获的异常。 finally子句不管 try 子句里面有没有发生异常，finally 子句都会执行。 如果一个异常在 try 子句里（或者在 except 和 else 子句里）被抛出，而又没有任何的 except 把它截住，那么这个异常会在 finally 子句执行后再次被抛出。def divide(x, y): try: result = x / y except ZeroDivisionError: print("division by zero!") else: print("result is", result) finally: print("executing finally clause")if __name__ == '__main__': divide(1, 0) 无论是否接住了异常，finally语句依旧执行。division by zero!executing finally clause 抛出异常使用 raise 语句抛出一个指定的异常。 raise NameError('名字错了') 附录 -python异常表 异常名称 描述 BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>异常</tag>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BMC测试]]></title>
    <url>%2F2018%2F03%2F10%2FBMC%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[BMC测试的主要内容。 Web：通过浏览器用BMC IP 访问BMC 登录方式：http://xx.xx.xx.xx BMC的IP地址。 查看BMC 的版本等一些基本信息 查看sensor的读值，threshold及状态 查看、删除SEL 设置BMC Network，如IP的获取方式，enable/disable VLAN等。 设置Trap、Email、LDAP等 查看、修改BMC 用户 连接iKVM远程监控 其他设置 IOL: 利用ipmitool或者其他软件通过LAN访问BMC. ipmitool连接方式： ipmitool –I lanplus(lan) –H 192.x.x .x -U admin -P admin –L administrator(operator/user) raw &lt;NetFn&gt; &lt;cmd&gt; &lt;data&gt; 可以通过IOL连接对BMC发送命令对BMC进行设置，如设置BMC IP的获取方式，重启BMC，重启/关闭系统等。 SOL: Serial Over Lan SOL 提供了一种机制，使得远程管理系统的串口控制器通过基于IP网络的IPMI会话能够重定向到本地。 串口是修复系统故障和BIOS异常不可或缺的工具。当机器发生故障时，系统管理人员可以通过串口进行BIOS、操作系统和网络的相关配置，修复系统。在以往的情况下,管理人员不得不回到嘈杂的机房,重新接入串口,再进行修复工作。 SOL为管理人员提供了基于IPIP的远程系统串口的访问,只要机房内网络不出现故障，管理人员便可以通过任何一台支持SOL的主机访问发生故障的机器的串口 SOL 被设计为RMCP+协议负载的一种 Serial：通过串口连接BMC 超级终端或者其他软件通过串口与BMC进行连接 可以进入BMC linux通过命令查看、设置BMC的相关内容，如查看SEL，查看网络配置，重启BMC等。 Sensor测试 对每一个sensor创造条件，使其产生对应的事件，查看LED、SEL、Trap、Mail、PEF等。 PEF/Trap/Email测试 创造满足PEF条件的事件，查看BMC是否会根据PEF的设置做出相应的反应，如记录log，重启或者关闭系统，发送alert trap及mail等。 Command测试 验证BMC Spec中定义的command是否可用正确运行并返回正确的值。]]></content>
      <categories>
        <category>BMC Study Notes</category>
      </categories>
      <tags>
        <tag>BMC</tag>
        <tag>IPMI</tag>
        <tag>IPMITOOL</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高阶函数]]></title>
    <url>%2F2018%2F03%2F09%2F%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[这篇博文主要介绍下python中特别重要的内置高阶函数filter()，map()，reduce()，以及它们的应用。其中也涉及了一些它们在python2与python3中的不同。 filter()函数filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的迭代器。注意，在python2.x返回的是列表，在python3中返回为迭代器，有惰性运算的特性, 相对python2提升了性能, 可以节约内存。 语法filter(function, iterable) 该函数接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素保留。 参数 function – 判断函数。 iterable – 可迭代对象。 返回值返回迭代器。 应用def is_odd(n): return n % 2 == 1new = filter(is_odd, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])print(new)print(new.__next__())print(list(new)) # 列表化 1&lt;filter object at 0x04EA22F0&gt;[3, 5, 7, 9] 上面的例子很好的看出，filter函数将偶数过滤掉，返回了一个迭代器类型。 map()函数map() 会根据提供的函数对指定序列做映射。 语法第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。map(function, iterable, ...) 参数 function 函数，有两个参数 iterable 一个或多个序列 返回值 Python 2.x 返回列表。 Python 3.x 返回迭代器。 应用先定义一个函数，用来计算平方数def square(x): # 计算平方数 return x ** 2 使用map函数计算一个列表的每个元素的平方数，并返回对应迭代器。m1=map(square, [1, 2, 3, 4, 5])print(m1)print(m1.__next__()) &lt;map object at 0x051922F0&gt;1 使用 lambda 匿名函数，实现上面的功能。m2=map(lambda x: x ** 2, [1, 2, 3, 4, 5])print(m2)print(m2.__next__()) &lt;map object at 0x05209490&gt;1 提供了两个列表，对相同位置的列表数据进行相加m3=map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10])print(list(m3)) [3, 7, 11, 15, 19] 如果，两个列表长度不同，则返回长度为短的那个。 reduce()函数reduce() 函数会对参数序列中元素进行累积。 函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给reduce中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。 在python3中不在内置，不可以直接调用，需要先进行导入。 导入from functools import reduce 语法reduce(function, iterable[, initializer]) 参数 function – 函数，有两个参数 iterable – 可迭代对象 initializer – 可选，初始参数 应用先定义个函数def add(x, y): # 两数相加 return x + y 调用reduce计算累加和reduce(add, [1,2,3,4,5]) # 计算列表和：1+2+3+4+5&gt;&gt;&gt;15 使用 lambda 匿名函数，计算累乘reduce(lambda x, y: x*y, [1,2,3,4,5])]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>map</tag>
        <tag>filter</tag>
        <tag>reduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名函数]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在Python中，lambda作为一个关键字，作为引入表达式的语法。想比较def函数，lambda是单一的表达式，而不是语句块.[TOC] 匿名函数的特点所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。 lambda 只是一个表达式，函数体比 def 简单很多。 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 匿名函数的语法lambda 函数的语法只包含一个语句，如下：lambda [arg1 [,arg2,.....argn]]:expression# lambda 参数列表：return [表达式] 变量# 由于lambda返回的是函数对象（构建的是一个函数对象），所以需要定义一个变量去接收 匿名函数的优点 使用Python写一些脚本时，使用lambda可以省去定义函数的过程，让代码更加精简。 对于一些抽象的，不会被别的地方再重复使用的函数，有时候函数起个名字也是个难题，使用lambda不需要考虑命名的问题 使用lambda在某些时候然后代码更容易理解 匿名函数的应用定义简单函数# sum加法函数sum = lambda arg1, arg2: arg1 + arg2# 调用sum函数print("结果为 : %0.1f" %sum(10, 20)) 结果为 : 30.0 排序中的应用infors = [&#123;"name":"宋长武","age":23&#125;,&#123;"name":"刘洋","age":22&#125;, &#123;"name":"施名阳","age":24&#125;,&#123;"name":"马云伟","age":23&#125;]# 使用匿名函数,根据age对字典排序infors.sort(key=lambda x:x['age'])print(infors) # 或者使用sorted函数# infors_new=sorted(infors,key=lambda x:x['age'])# print(infors_new) [&#123;'name': '刘洋', 'age': 22&#125;, &#123;'name': '宋长武', 'age': 23&#125;, &#123;'name': '马云伟', 'age': 23&#125;, &#123;'name': '施名阳', 'age': 24&#125;] 函数当作变量def test(a,b,func): result = func(a,b) return result# 调用num = test(11,22,lambda x,y:x+y)print('结果为:%.1f'%num) 结果为 : 33.0]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>匿名函数</tag>
        <tag>lambda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器]]></title>
    <url>%2F2018%2F03%2F09%2F%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器本质上是可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用.[TOC] 装饰器的写法比如说，我们有两个函数，它们分别实现了一个功能,但是其中一个模块的函数出了问题,需要为每个函数添加debug信息,方便找到问题,下方是两个函数:def say_hello(): print("hello") def say_world(): print("world") 以及想要实现的效果:[DEBUG]: enter say_hello()hello[DEBUG]: enter say_world()world 那么,你可能会想,不就是在每个函数加入个print的事嘛,但是我的老哥们,这仅仅是两个函数,这要是几百个函数,那岂不是得累死,所以我们不能这么干. 这时候我们的装饰器就闪亮登场了.先来看下代码.def debug(func): def wrapper(*args, **kwargs): print("[DEBUG]: enter &#123;&#125;()".format(func.__name__)) return func() return wrapper 我们来看下这个装饰器函数,他的执行过程是什么样的呢 首先,它接受的参数是个函数 然后将接受的函数进行包装,即,为其添加了一些新的功能特性 最后返回了一个新的包装好的函数 最后执行这个函数 好的,装饰器的执行过程我们知道了,那么我们如何调用这个装饰器为我们服务呢?很简单,直接使用python的@语法糖就可以调用了,我们看下面的例子.@debugdef say_hello(): print("hello") 看看这样的实现过程,是不是很简单,很实用,而且很优雅. 带参数装饰器有小伙伴就可能要问了,我们debug完成了,难道我们还让他是输出debug字样的log嘛?是不是很不好(low)啊,这时候有的同学就要说了,很简单啊,在重新写个装饰器不就好了,可以是可以,但是改来改去的,你不会觉得很麻烦嘛?这是我们想到了给装饰器加个参数,如果正常运行的时候就让他显示[执行]xxx,调试的时候我们就让他显示[debug]xxx,这样是不是就舒服多了.def logging(level): def wrapper(func): def inner_wrapper(*args, **kwargs): print ("[&#123;level&#125;]: enter function &#123;func&#125;()".format( level=level, func=func.__name__)) return func(*args, **kwargs) return inner_wrapper return wrapper 这样我们就定义好了一个带参数的装饰器,其实也就是加了一层嵌套,传了一个参数进去.这样我们只要指定level的值就可以了,完全不用再写一个参数,也更方便后期维护.@logging(level='执行')def say_hello(): print("hello") 类装饰器前面讲的都是基于函数去实现一个装饰器,下面讲讲如何通过类来实现装饰器。回到装饰器上的概念上来，装饰器要求接受一个callable对象，并返回一个callable对象。那么用类来实现也是也可以的。我们可以让类的构造函数__init__()接受一个函数，然后重载__call__()并返回一个函数，也可以达到装饰器函数的效果。class logging1(object): def __init__(self, level='默认'): self.level = level def __call__(self, func): # 接受函数 def wrapper(*args, **kwargs): print("[&#123;level&#125;]: enter function &#123;func&#125;()".format( level=self.level, func=func.__name__)) func(*args, **kwargs) return wrapper # 返回函数 调用还是使用@语法糖,这里就不多赘述了. 装饰器嵌套有的时候。我们并不是在原有的基础上增加一个功能，而是几个功能。那可不可以使用几个装饰器呢？Python告诉你，它是可以的。@A@B@Cdef xxx(...): ... 这样就可以实现装饰器的嵌套。实际上他的执行过程是这样的,先执行接近函数的那一个：f = A(B(C(f))) # first C, seconds B, third A 内置装饰器内置的装饰器和普通的装饰器原理是一样的，只不过返回的不是函数，而是类对象,在Python中有三个内置的装饰器，都是跟class相关的：staticmethod、classmethod 和property。 staticmethod 是类静态方法，其跟成员方法的区别是没有 self 参数，并且可以在类不进行实例化的情况下调用 classmethod 与成员方法的区别在于所接收的第一个参数不是 self （类实例的指针），而是cls（当前类的具体类型） property 是属性的意思，表示可以通过通过类实例直接访问的信息 @propertyPython内置的@property装饰器是负责把一个方法变成属性调用的,这里其实查了很多资料但没有很好的讲解，我就查看了函数的内部，发现了里面给讲解了这个装饰器的使用，而且很形象。class C(object): @property def x(self): return self._x @x.setter def x(self, value): self._x = value @x.deleter def x(self): del self._x @property、x.setter x.deleter实现了属性的读取、赋值、和删除。上实例，便于理解,这里以一个学生的成绩修改进行操作。class Stu(object): @property def score(self): return self._score @score.setter def score(self, value): self._score = value @score.deleter def score(self): del self._score if __name__ == '__main__': stu = Stu() #实例化 stu.score = 60 #赋值 print(stu.score) del stu.score #删除 print(stu.score) &gt;&gt;&gt;60AttributeError: 'Stu' object has no attribute '_score' @classmethod类方法,按照我的理解就是,可以在类的内部定义函数,并且将这个函数的返回值作为参数,传给这个类。听起来好像有点拗口，下面我们来看个实例：class Date_test(object): day, month, year = 0, 0, 0 def __init__(self, year=0, month=0, day=0): self.day = day self.month = month self.year = year @classmethod def get_date(cls, string_date): # 这里第一个参数是cls， 表示调用当前的类名 year, month, day = map(int, string_date.split(&apos;-&apos;)) date1 = cls(year, month, day) # 返回的是一个初始化后的类 return date1 def out_date(self): print(&quot;日期: %4d年 %2d月 %2d日&quot; %(self.year, self.month, self.day))if __name__ == &apos;__main__&apos;: date = Date_test(2012, 6, 6) date.out_date() date1 = Data_test.get_date(&apos;2013-12-1&apos;) date1.out_date() 日期: 2012年 6月 6日日期: 2013年 12月 1日 上面代码中的date1,就是将时间戳转换成该类可接受的参数,再重新调用这个class. @staticmethod静态方法，该方法不强制要求传递参数，也不需要实例化，可以直接调用。class Foo: @staticmethod # 静态方法 def spam(x,y,z): print(x,y,z)if __name__ == '__main__': Foo.spam(1,2,3) 当然也可以实例化调用，这里就不演示了。 应用场景:编写类时需要采用很多不同的方式来创建实例，而我们只有一个__init__函数，此时静态方法就派上用场了. class Date: def __init__(self, year, month, day): self.year = year self.month = month self.day = day @staticmethod def now(): # 用Date.now()的形式去产生实例,该实例用的是当前时间 t = time.localtime() # 获取结构化的时间格式 return Date(t.tm_year, t.tm_mon, t.tm_mday) # 新建实例并且返回 @staticmethod def tomorrow(): # 用Date.tomorrow()的形式去产生实例,该实例用的是明天的时间 t = time.localtime(time.time() + 86400) return Date(t.tm_year, t.tm_mon, t.tm_mday) if __name__ == '__main__': a = Date('1987', 11, 27) # 自己定义时间 b = Date.now() # 采用当前时间 c = Date.tomorrow() # 采用明天的时间 print(a.year, a.month, a.day) print(b.year, b.month, b.day) print(c.year, c.month, c.day) 1987 11 272018 3 92018 3 10]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成器]]></title>
    <url>%2F2018%2F03%2F07%2F%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用return返回，而是用yield一次返回一个结果，在每个结果之间挂起和继续它们的状态，来自动实现迭代协议。也就是说，yield是一个语法糖，内部实现支持了迭代器协议，同时yield内部是一个状态机，维护着挂起和继续的状态。[TOC] 简单使用我们先定义了一个生成器函数，函数返回一个生成器对象，然后就可以通过for语句或者next()进行迭代访问.这里我们直接让迭代器列表化打印.def Lrange(n): i = 0 while i &lt; n : yield i i += 1lrange=Lrange(3)list_l = list(lrange)print(lrange)print(list_l)&gt;&gt;&gt;&lt;generator object Lrange at 0x0EAA3D80&gt;[0, 1, 2] 其实，生成器函数返回生成器的迭代器。 “生成器的迭代器”这个术语通常被称作”生成器”。要注意的是生成器就是一类特殊的迭代器。作为一个迭代器，生成器必须要定义一些方法，其中一个就是next()。如同迭代器一样，我们可以使用next()函数来获取下一个值。 执行过程 当调用生成器函数的时候，函数只是返回了一个生成器对象，并没有 执行。 当next()方法第一次被调用的时候，生成器函数才开始执行，执行到yield语句处停止 next()方法的返回值就是yield语句处的参数（yielded value） 当继续调用next()方法的时候，函数将接着上一次停止的yield语句处继续执行，并到下一个yield处停止；如果后面没有yield就抛出StopIteration异常 生成器推导式说到推导式,你可能首先会想到列表推导式,其实两者还是真的很相似.举个栗子,哈哈现在的需求是:我们要生成1到20的奇数一个列表.[i for i in range(1,20) if i%2] 那么将这个列表元素不直接都存到列表里,而是以迭代器的方式,每次取一个.这样就是生成器了,是不是还是蛮好理解的.那么怎么将这个列表推导式改成生成器推导式呢?很简单,把方括号改成小括号就可以了,这时候我们返回的就不是一个列表,而是一个迭代器.ge = (i for i in range(1,20) if i%2)ge2=[i for i in range(1,20) if i%2]print(ge)print(ge.__next__())print(ge2)&gt;&gt;&gt;&lt;generator object &lt;genexpr&gt; at 0x0E053D80&gt;1[1, 3, 5, 7, 9, 11, 13, 15, 17, 19] 这样的对比是不是直观多了. 那生成器是不是完全就是迭代器,当然不是,他还有其他的方法, send()方法Python 2.5中，yield语句变成了yield表达式，也就是说yield可以有一个值，而这个值就是send()方法的参数，所以send(None)和next()是等效的。同样，next()和send()的返回值都是yield语句处的参数（yielded value） 关于send()方法需要注意的是： 调用send传入非None值前，生成器必须处于挂起状态，否则将抛出异常。也就是说，第一次调用时，要用next()语句或send(None)，因为没有yield语句来接收这个值。 close()方法这个方法用于关闭生成器，对关闭的生成器后再次调用next或send将抛出StopIteration异常。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器]]></title>
    <url>%2F2018%2F03%2F07%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器指能够被内置函数 next调用并不断返回下一个值，直到最后抛出 StopIteration错误表示无法继续返回下一个值的对象称为迭代器( Iterator)。这里主要讲一下迭代器的特性，和如何简单的实现一个迭代器。 迭代器类型[TOC] 其实在 python中，没有内置迭代器类型的对象，但是可以通过内置函数 iter()将 str、 tuple、 list、 dict、 set等类型转换成一个迭代器类型。 简单的说，就是列表，字符串，元祖并不是迭代器类型，但可以转换成迭代器类型。 我们来看下代码。可能会更好理解。&gt;&gt;&gt; s = [1,2,3]&gt;&gt;&gt; next(s)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'list' object is not an iterator&gt;&gt;&gt; n="abc"&gt;&gt;&gt; next(n)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'str' object is not an iterator 从上面的报错可以很好地看出str和list并不是一个iterator,即迭代器.我们尝试使用iter()函数去将其转换成iterator&gt;&gt;&gt; it_n = iter(n)&gt;&gt;&gt; next(it_n)'a'&gt;&gt;&gt; next(it_n)'b' 很明显现在的字符串已经是一个迭代器对象了,我们使用type()函数来验证下我们的猜想.&gt;&gt;&gt; type(it_n)&lt;class 'str_iterator'&gt;&gt;&gt;&gt; type(n)&lt;class 'str'&gt; 很好,python已经很明确的告诉我们它已经是个str_iterator了已经弄懂了什么是迭代器,那么我们是否自己写一个迭代器呢? 实现一个迭代器思路: 定义一个类,用来表示我们的迭代器 定义初始化函数,初始化当前值,和最大迭代的次数 定义next()方法,用来实现迭代,如果没到最大迭代数就将当前次数加一,达到最大次数则抛出StopIteration停止迭代. 实例化我们的迭代器 class My_iterator(): def __init__(self,max_value): self.current_value = 0 self.max_value= max_value def __next__(self): if self.current_value &lt; self.max_value: result = self.current_value self.current_value +=1 return result else: raise StopIteration 下面我们实例化我们的迭代器,来验证下是否成功实现了. if __name__ == '__main__': my_iter = My_iterator(3) print(next(my_iter)) print(next(my_iter)) print(next(my_iter)) print(next(my_iter)) print(next(my_iter)) 运行我们的代码python K:/hexo/source/_posts/迭代器.py012 看起来好像已经实现了我们的效果,我们尝试使用list()函数将其封装到一个列表里l = list(my_iter)然后可怕的事情发生了,解释器抛出了一个异常TypeError: 'My_iterator' object is not iterable 它说我们所写的并不是iterable,这我也一脸懵逼啊不过可以看出仅仅实现 next()方法的对象还不是迭代器，真正的迭代器还需要实现一个可迭代接口 Iterable。 通过查找资料: 迭代器类型 Iterator继承自可迭代类型 Iterable，可迭代 Iterable继承自 object基类，迭代器 Iterator类型包含 iter()和 next()方法，而可迭代类型 Iteratble仅仅包含 iter()。可迭代对象，通过 iter()返回一个迭代器对象，迭代器对象的 next()方法则实际用于被循环。 所以,我们只需要在我们类里再定义一个iter(),用来返回迭代器对象即可 def __iter__(self): return self 导入模块检验下我们现在的my_iter是不是已经是迭代器类型from collections import Iterator,Iterable 调用isinstance()函数进行比较,如果跟返回True,说明已经是一个迭代器类型print(isinstance(my_iter,Iterator))print(isinstance(my_iter,Iterable)) TrueTrue 好了,我们已经完成了一个很基本的迭代器了. 总结笔记 凡是可作用于 for语句循环的对象都是 Iterable可迭代类型。 凡是可作用于 next()函数的对象都是 Iterator迭代器类型。 str、 tuple、 list、 dict、 set等类型是Iterable可迭代类型，但不是 Iterator迭代器；通过 Iterable可迭代类型的 iter()方法可以获得一个Iterator迭代器对象，从而使得它们可以被for语句循环。 Python的for循环本质上就是通过调用Iterable可迭代对象的 iter()方法获得一个 Iterator迭代器对象,然后不断调用 Iterator迭代器对象 next()方法实现的。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib绘图]]></title>
    <url>%2F2018%2F03%2F05%2Fmatplotlib%E7%BB%98%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍下如何使用matplotlib进行数据可视化绘图,解决了不能显示中文的问题.绘制了气泡散点图,七彩散点图,堆叠条形图,倒影条形图,水平条形图等.[TOC] 导入我先导入所需要的库:import matplotlibimport matplotlib.pyplot as pltimport numpy as npimport random 解决中文显示 先指定字体 2. 使用中文时,加上fontproperties=font参数# 指定要使用的字体,防止出现中文乱码font=matplotlib.font_manager.FontProperties(fname=r"C:\Windows\Fonts\Deng.ttf") 散点图使用plt.scater()绘制散点图 七彩散点图 导入所需的库 所有的都需要导入上面的库,后面不在赘述 拿到所需要的x轴,y轴数据,我们这里选择直接生成,你可以把需要的数据添加进去. # 输入横坐标x序列x=np.array([x for x in range(1,21)])# 输入y序列,或者y与x的关系y=x**2 之后我们生成一个颜色的列表 colors=['red','green','gray','purple','yellow','orange','blue'] 然后调用随机数模块,进行随机抽取 random_colors=random.sample(colors,7) 调用plt进行绘图,c=用来规定颜色,s=用来控制每个点的大小 plt.scatter(x,y,s=100,c=random_colors,alpha=0.8)#- 最后我们来显示所画的图 plt.show() 气泡散点图 导入所需的库 所有的都需要导入上面的库,后面不在赘述 拿到所需要的x轴,y轴数据,我们这里选择直接生成,你可以把需要的数据添加进去. N=80# 随机获取x&lt;1的数字八十个x=np.random.rand(N)# 随机获取y&lt;1的数字八十个y=np.random.rand(N) 同样我们生成一个颜色的列表 colors=['red','green','gray','purple','yellow','orange','blue'] 然后调用随机数模块,进行随机抽取 # 随机排列颜色random_colors=random.sample(colors,7) 然后这里我们加入一个随机生成点的大小 area=np.pi * (np.random.rand(N)*10)**2 调用进行绘图,c=用来规定颜色,s=用来控制每个点的大小 plt.scatter(x,y,c=random_colors,s=area) 最后我们来显示所画的图 plt.show() 条形图使用plt.bar()进行条形图绘制 双层条形图 先生成一个画布 fig=plt.figure() 生成数据,将两个x数据间隔开,宽度等于差值 x1=[x-0.2 for x in range(1,9)]y1=[n*2 for n in range(1,9)]x2=[x+0.2 for x in range(1,9)]y2=[x**2 for x in x2] 开始画条形图1 l1=plt.bar(x1,y1,color='g',width=0.4) 开始画条形图2,使宽度等于x1,x2的差值 l2=plt.bar(x2,y2,color='b',width=0.4) 添加x,y轴,和头部信息 plt.xlabel('x轴信息',fontproperties=font)plt.ylabel('y轴信息',fontproperties=font)plt.title('双层条形图',fontproperties=font) 给图像加上注解信息 plt.legend(handles = [l1, l2,], labels = ['去年', '今年'], loc = 'best',prop=font) 添加每个条形图的数据 for x1,x2, y1, y2 in zip(x1,x2, y1, y2): plt.text(x1 , y1, '%.0f' % y1, ha='center', va='bottom') plt.text(x2 , y2, '%.0f' % y2, ha='center', va='bottom') 看看最终的效果图,是不是看起来很炫酷,当然后面的更炫酷. plt.show() 堆叠条形图 先生成一个画布 fig=plt.figure() 生成数据 x1=[x for x in range(1,9)]y1=[n*2 for n in range(1,9)]x2=[x for x in range(1,9)]y2=[x**2 for x in x2] 开始画条形图2,先画数值大的,数值小的直接在原图覆盖 l2=plt.bar(x2,y2,color='b',width=0.4) 开始画条形图1 l1=plt.bar(x1,y1,color='g',width=0.4) 设置x标签 plt.xlabel(u'x轴',fontproperties=font) 设置y轴标签 plt.ylabel('y轴',fontproperties=font) 设置标题 plt.title(u'堆叠柱状图',fontproperties=font) 设置注解狂 plt.legend(handles = [l1, l2,], labels = ['去年', '今年'], loc = 'best',prop=font) 把确切数字显示出来 for x1,x2, y1, y2 in zip(x1,x2, y1, y2): plt.text(x1 , y1, '%.0f' % y1, ha='center', va='bottom') plt.text(x2 , y2, '%.0f' % y2, ha='center') 显示 plt.show() 看效果图 倒影条形图 先生成一个画布 fig=plt.figure() 生成数据 x1=[x-0.2 for x in range(1,9)]y1=[n*2 for n in range(1,9)]y2=[-x for x in y1] 画水平直方图 l1=plt.bar(x1,y1,color='g')l2=plt.bar(x1,y2,color='b') 设置 plt.title("倒影直方图",fontproperties=font) 设置x，y轴标签 plt.xlabel('数量',fontproperties=font)plt.ylabel('产品',fontproperties=font) 设置刻度 plt.yticks([x for x in range(-18,21,4)])plt.xticks([y for y in range(0,9,1)])for x1, y1 in zip(x1, y1): # 添加文本时可添加偏移量使其显示更加美观 plt.text(x1, y1, '%.0f' % y1, ha='center', va='bottom') 显示 plt.show() 水平条形图 先生成一个画布 fig = plt.figure() 生成数据 x1 = [x for x in range(1, 9)]y1 = [n * 2 for n in range(1, 9)]x2 = [x for x in range(1, 9)]y2 = [x ** 2 for x in x2] 画水平条形图 l2=plt.barh(x2,y2,color='b')l1=plt.barh(x1,y1,color='g') 设置头 plt.title("水平条形图",fontproperties=font) 设置x，y轴标签 plt.xlabel('数量',fontproperties=font)plt.ylabel('产品',fontproperties=font) 设置刻度 plt.xticks([x for x in range(0,80,4)])plt.yticks([y for y in range(0,9,1)]) 设置注解图示 plt.legend(handles = [l1, l2,], labels = ['去年', '今年'], loc = 'best',prop=font)for x1,x2, y1, y2 in zip(x1,x2, y1, y2): # 添加文本时添加偏移量使其显示更加美观 plt.text(y1+1.5 , x1-0.25, '%.0f' % y1, ha='center', va='bottom') plt.text(y2+1.5 , x2-0.25, '%.0f' % y2, ha='center', va='bottom') 显示 plt.show()]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2018%2F03%2F01%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。本文简单讲述了re模块的六大匹配方法和一些匹配模式。[TOC] 导入import re 语法 有一点要注意Python的字符串本身也用’\’转义，所以要特别注意,一般我们都建议使用Python的r前缀，就不用考虑转义的问题了。 匹配位置的元字符 符号 符号 在正则中的含义 ^ 脱字符 匹配一行开头的字符 $ 美元符 匹配一行结束的位置 \b 单词分界 匹配单词的边界 匹配单个字符的元字符 符号 符号 在正则中的含义 . 点号 匹配单个任意字符 […] 字符组 匹配里面列出来的字符 [^…] 排除字符组 匹配非其中列出的字符 提供计数功能的元字符 符号 符号 在正则中的含义 ? 问号 可以匹配一次,但不必须匹配 * 星号 可以匹配任意次,但不必须匹配 + 加号 至少匹配一次,最多可以匹配任意次 {min,max} 区间 至少匹配min次,最多可匹配max次 模式更加详尽的模式请参考附录 匹配行的开头先说一个简单的例子：匹配以cat开头的patt=re.compile(r'^cat') 表示匹配以c作为一行的第一个字符，后面跟着a,后面跟着t所以’vocative’就不会被匹配到，原因是因为cat在字符的里面 匹配行的结尾如何我们要是以某一个字符串结尾的,比如我们要查邮件是以BR或者Bestregards结尾的,如何匹配：我们用美元符号$来处理import resentence='''Hi Jack:\n Python is a beautiful language\n BR'''patt=re.compile(r'(BR|Bestregards)$')m=re.search(patt,sentence)if m : print ('match')else: print ('not match')&gt;&gt;&gt;match 匹配单词的边界前面介绍了匹配行的开头和结尾，那么如何匹配单词的边界呢,正则里面有2个特殊字符\b and \B来匹配单词的边界 :\b 匹配的模式是一个单词的边界(不论这个单词的前面是有字符还是没有字符)\B 匹配出现在一个单词中间的模式例如:the #匹配包含有'the'的字符串\bthe #匹配任何以'the'开始的字符串\bthe\b #仅仅匹配单词'the'\Bthe #匹配任意包含'the'但不以'the'开头的单词 匹配字符组比如我们需要匹配’grey’或者’gray’的时候，怎么办,可以用正则的[]来表示,gr[ea]y,表示先找到g,然后找到r,然后找到e或者a,最后是一个yimport reword='grey'patt=re.compile(r'gr[ea]y')m=re.match(patt,word)if m : print ('match')else: print ('not match')&gt;&gt;&gt;match 匹配中的多选模式我们可以用’|’来匹配任意子表达式,‘|’是一个非常简便的元字符,它的意思是”或”，通过它我们能把不同的子表达式组合成一个总的表达式,比如’am’|’pm’就是能够同时匹配其中任意一个的正则表达式,回头再看上面的例子’gr[ea]y’,其实能写成’grey|gray’,或者’gr(e|a)y’ 匹配中的可选匹配(非必需匹配)比如6月4号，这个6月可能写成’June’也可以写成’Jun’,而且日期也有可能写作’fourth’或者’4th’或者4,我们可以写成(June|Jun)(fourth|4th|4),但是有没有其他办法呢,可以用问号?表示可选项我们分步来处理:第一部分:(June|Jun)改为(June?),什么意思呢意思是说’?’出现在一个e后面，表示e是可选的第二部分:(fourth|4th|4)改为(fourth|4(th)?),什么意思呢意思是说’?’出现在一个括号后面,表示这个括号内的内容是可选的 最后这个复杂的(June|Jun)(fourth|4th|4)就可以变成了June?(fourth|4(th)?) 匹配重复出现的字符重复出现用+和*表示,但是二者有一些小的区别 加号(+)表示:前面紧邻的元素出现一次或者多次，也就是至少出现一次 星号(*)表示:前面紧邻的元素出现任意多次，或者不出现. 即:a*表示0个或者多个a,所以为0的时候，就是空字符 a+表示1个或者多个a,所以a至少要有1次 匹配重复出现n次的内容 比如我们想匹配前面的内容重复出现的次数，比如3次,或者是一个区间,比如1-3次,如何匹配: import renum_str='123aa45'patt=re.compile(r'([1-9]&#123;3&#125;)')m=re.match(patt,num_str)if m: print (m.group())&gt;&gt;&gt;123 为重复匹配次数设定一个区间 比如美国股票的代码，都是字符有大写的也有小写，基本都是在1到5个字母，如何用正则表达呢? [a-zA-Z]{1,5},就可以来匹配美国股票代码(1到5个字母) 匹配中去除不想匹配的字符比如我们想匹配除了1到6以外的任何字符串,怎么办，简单用[^1-6],这个字符组中开头的^表示”排除的意思”.有同学会说，你刚才不是说^表示开头吗，怎么现在变成排除型了? 下面就是我要解释的,正则的复杂性: 当^在字符组的外面的时候”表示一个行的开头” 当^在字符组的内部(而且是必须紧接着字符组的第一个方括号之后)，它就是一个元字符，表示排除型 例子:找出字母g后面的字母不是u的import rewords=['gold','Google','Sogu','Guess']patt=re.compile(r'.*g[^u]')for w in words: m=re.match(patt,w) if m: print (w)&gt;&gt;&gt;goldGoogle 函数re.match方法re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回None 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 re.match例子import reline = "Cats are smarter than dogs"matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)if matchObj: print ("matchObj.group() : ", matchObj.group()) print ("matchObj.group(1) : ", matchObj.group(1)) print ("matchObj.group(2) : ", matchObj.group(2))else: print ("No match!!")&gt;&gt;&gt;matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter re.search方法re.search 扫描整个字符串并返回第一个成功的匹配。 re.search(pattern, string, flags=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 匹配成功re.search方法返回一个匹配的对象，否则返回None。同样，可以用group()来获得结果. 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 re.search例子import reline = "Cats are smarter than dogs";searchObj = re.search( r'(.*) are (.*?) .*', line, re.M|re.I)if searchObj: print "searchObj.group() : ", searchObj.group() print "searchObj.group(1) : ", searchObj.group(1) print "searchObj.group(2) : ", searchObj.group(2)else: print "Nothing found!!"&gt;&gt;&gt;searchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter re.match和re.search的区别 match在只能str开头寻找,不匹配则返回None search则在str任意位置寻找re.sub方法Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。re.sub(pattern, repl, string, count=0, flags=0) 参数 描述 pattern 正则中的模式字符串 repl 替换的字符串，也可为一个函数 string 要被查找替换的原始字符串 count 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配 re.sub例子import rephone = "2004-959-559 # 这是一个国外电话号码" # 删除字符串中的 Python注释 num = re.sub(r'#.*$', "", phone)print ("电话号码是: ", num)# 删除非数字(-)的字符串 num = re.sub(r'\D', "", phone)print ("电话号码是 : ", num)&gt;&gt;&gt;电话号码是: 2004-959-559 电话号码是 : 2004959559 repl 参数是一个函数时以下实例中将字符串中的匹配的数字乘于 2：import re# 将匹配的数字乘于 2def double(matched): value = int(matched.group('value')) return str(value * 2)s = 'A23G4HFD567'print(re.sub('(?P&lt;value&gt;\d+)', double, s))&gt;&gt;&gt;A46G8HFD1134 re.compile方法ompile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： re.compile(pattern[, flags]) 参数 描述 pattern 一个字符串形式的正则表达式 flags 可选，表示匹配模式，比如忽略大小写，多行模式等 re.compile例子import repattern = re.compile(r'([a-z]+) ([a-z]+)', re.I) # re.I 表示忽略大小写m = pattern.match('Hello World Wide Web')&gt;&gt;&gt; m.group(1) # 返回第一个分组匹配成功的子串'Hello'&gt;&gt;&gt; m.span(1) # 返回第一个分组匹配成功的子串的索引(0, 5)&gt;&gt;&gt; m.groups() # 等价于 (m.group(1), m.group(2), ...)('Hello', 'World') re.finditer方法在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 re.finditer(pattern, string, flags=0) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 re.finditer例子import reit = re.finditer(r"\d+","12a32bc43jf3") for match in it: print (match.group() )&gt;&gt;&gt;12 32 43 3 re.split方法re.split 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： re.split(pattern, string[, maxsplit=0, flags=0]) 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串 maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 re.split例子&gt;&gt;&gt; re.split('\W+', ' runoob, runoob, runoob.', 1) #\W 匹配非字母数字及下划线,匹配一次['', 'runoob, runoob, runoob.'] &gt;&gt;&gt; re.split('a*', 'hello world') # 对于一个找不到匹配的字符串而言，split 不会对其作出分割['hello world'] 附录正则修饰符正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志flags修饰符: 参数 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则模式详表 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 匹配n个前面表达式。。例如，”o{2}”不能匹配”Bob”中的”o”，但是能匹配”food”中的两个o。 re{ n,} 精确匹配n个前面表达式。例如，”o{2,}”不能匹配”Bob”中的”o”，但能匹配”foooood”中的所有o。”o{1,}”等价于”o+”。”o{0,}”则等价于”o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 (re) 匹配括号内的表达式，也表示一个组 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \w 匹配字母数字及下划线 \W 匹配非字母数字及下划线 \s 匹配任意空白字符，等价于 [\t\n\r\f]. \S 匹配任意非空字符 \d 匹配任意数字，等价于 [0-9]. \D 匹配任意非数字 \A 匹配字符串开始 \Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \z 匹配字符串结束 \G 匹配最后匹配完成的位置。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \n, \t, 匹配一个换行符。匹配一个制表符。等 \1…\9 匹配第n个分组的内容。 \10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 常用匹配字符类 实例 描述 [Pp]ython 匹配 “Python” 或 “python” rub[ye] 匹配 “ruby” 或 “rube” [aeiou] 匹配中括号内的任意一个字母 [0-9] 匹配任何数字。类似于 [0123456789] [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 [a-zA-Z0-9] 匹配任何字母及数字 [^aeiou] 除了aeiou字母以外的所有字符 [^0-9] 匹配除了数字外的字符 特殊字符类 实例 描述 . 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。 声明本文中的部分例子来自菜鸟教程。]]></content>
      <categories>
        <category>Python Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这是我搭建博客的第一篇文章，很多的功能都是通过这篇文章进行测试，本想搭建完成就将其删除，仔细斟酌之后还是选择将其保留，仅当作留念。 Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Others</category>
      </categories>
  </entry>
</search>
